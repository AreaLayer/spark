// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: spark.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { SignatureIntent, signatureIntentFromJSON, signatureIntentToJSON, SigningCommitment } from "./common";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "spark";

export enum TransferStatus {
  TRANSFER_STATUS_INITIATED = 0,
  TRANSFER_STATUS_KEY_TWEAKED = 1,
  TRANSFER_STATUSR_REFUND_SIGNED = 2,
  TRANSFER_STATUS_COMPLETED = 3,
  TRANSFER_STATUS_EXPIRED = 4,
  UNRECOGNIZED = -1,
}

export function transferStatusFromJSON(object: any): TransferStatus {
  switch (object) {
    case 0:
    case "TRANSFER_STATUS_INITIATED":
      return TransferStatus.TRANSFER_STATUS_INITIATED;
    case 1:
    case "TRANSFER_STATUS_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_KEY_TWEAKED;
    case 2:
    case "TRANSFER_STATUSR_REFUND_SIGNED":
      return TransferStatus.TRANSFER_STATUSR_REFUND_SIGNED;
    case 3:
    case "TRANSFER_STATUS_COMPLETED":
      return TransferStatus.TRANSFER_STATUS_COMPLETED;
    case 4:
    case "TRANSFER_STATUS_EXPIRED":
      return TransferStatus.TRANSFER_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferStatus.UNRECOGNIZED;
  }
}

export function transferStatusToJSON(object: TransferStatus): string {
  switch (object) {
    case TransferStatus.TRANSFER_STATUS_INITIATED:
      return "TRANSFER_STATUS_INITIATED";
    case TransferStatus.TRANSFER_STATUS_KEY_TWEAKED:
      return "TRANSFER_STATUS_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUSR_REFUND_SIGNED:
      return "TRANSFER_STATUSR_REFUND_SIGNED";
    case TransferStatus.TRANSFER_STATUS_COMPLETED:
      return "TRANSFER_STATUS_COMPLETED";
    case TransferStatus.TRANSFER_STATUS_EXPIRED:
      return "TRANSFER_STATUS_EXPIRED";
    case TransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DepositAddressProof {
  addressSignatures: { [key: string]: Uint8Array };
  proofOfPossessionSignature: Uint8Array;
}

export interface DepositAddressProof_AddressSignaturesEntry {
  key: string;
  value: Uint8Array;
}

export interface GenerateDepositAddressRequest {
  signingPublicKey: Uint8Array;
  identityPublicKey: Uint8Array;
}

export interface Address {
  address: string;
  verifyingKey: Uint8Array;
  depositAddressProof: DepositAddressProof | undefined;
}

export interface GenerateDepositAddressResponse {
  depositAddress: Address | undefined;
}

export interface UTXO {
  txid: string;
  vout: number;
}

export interface SigningJob {
  signingPublicKey: Uint8Array;
  rawTx: Uint8Array;
  signingNonceCommitment: SigningCommitment | undefined;
}

export interface SigningResult {
  publicKeys: { [key: string]: Uint8Array };
  signingNonceCommitments: { [key: string]: SigningCommitment };
  signatureShares: { [key: string]: Uint8Array };
}

export interface SigningResult_PublicKeysEntry {
  key: string;
  value: Uint8Array;
}

export interface SigningResult_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface SigningResult_SignatureSharesEntry {
  key: string;
  value: Uint8Array;
}

export interface NodeSignatureShares {
  nodeId: string;
  nodeTxSigningResult: SigningResult | undefined;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface NodeSignatures {
  nodeId: string;
  nodeTxSignature: Uint8Array;
  refundTxSignature: Uint8Array;
}

export interface StartTreeCreationRequest {
  identityPublicKey: Uint8Array;
  onChainUtxo: UTXO | undefined;
  rootTxSigningJob: SigningJob | undefined;
  refundTxSigningJob: SigningJob | undefined;
}

export interface StartTreeCreationResponse {
  treeId: string;
  rootNodeSignatureShares: NodeSignatureShares | undefined;
}

export interface TreeNode {
  id: string;
  treeId: string;
  value: number;
  parentNodeId?: string | undefined;
  nodeTx: Uint8Array;
  refundTx: Uint8Array;
  vout: number;
  verifyingPublicKey: Uint8Array;
  ownerIdentityPublicKey: Uint8Array;
  refundTimelock: number;
}

export interface Split {
  signingPublicKey: Uint8Array;
  refundSigningJob: SigningJob | undefined;
  value: number;
  vout: number;
}

export interface SplitNodeRequest {
  nodeId: string;
  parentTxSigningJob: SigningJob | undefined;
  splits: Split[];
}

export interface SplitResult {
  nodeId: string;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
  userPublicKey: Uint8Array;
}

export interface SplitNodeResponse {
  parentNodeId: string;
  parentTxSigningResult: SigningResult | undefined;
  splitResults: SplitResult[];
}

export interface FinalizeNodeSignaturesRequest {
  intent: SignatureIntent;
  nodeSignatures: NodeSignatures[];
}

export interface FinalizeNodeSignaturesResponse {
  nodes: TreeNode[];
}

export interface PrepareSplitAddressRequest {
  nodeId: string;
  signingPublicKeys: Uint8Array[];
}

export interface PrepareSplitAddressResponse {
  addresses: Address[];
}

export interface SecretShare {
  secretShare: Uint8Array;
  proofs: Uint8Array[];
}

export interface SendLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
  secretCipher: Uint8Array;
  /** Signature over Sha256(leaf_id||transfer_id||secret_cipher) */
  signature: Uint8Array;
}

export interface SendLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface SendTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: SendLeafKeyTweak[];
  receiverIdentityPublicKey: Uint8Array;
  expiryTime: Date | undefined;
}

export interface Transfer {
  id: string;
  senderIdentityPublicKey: Uint8Array;
  receiverIdentityPublicKey: Uint8Array;
  status: TransferStatus;
  totalValue: number;
  expiryTime: Date | undefined;
  leaves: TransferLeaf[];
}

export interface TransferLeaf {
  leaf: TreeNode | undefined;
  secretCipher: Uint8Array;
  signature: Uint8Array;
}

export interface SendTransferResponse {
  transfer: Transfer | undefined;
}

export interface QueryPendingTransfersRequest {
  receiverIdentityPublicKey: Uint8Array;
}

export interface QueryPendingTransfersResponse {
  transfers: Transfer[];
}

export interface ClaimLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
}

export interface ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface ClaimTransferTweakKeysRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToReceive: ClaimLeafKeyTweak[];
}

export interface ClaimLeafSigningJob {
  leafId: string;
  refundTxSigningJob: SigningJob | undefined;
}

export interface ClaimTransferSignRefundsRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs: ClaimLeafSigningJob[];
}

export interface ClaimLeafSigningResult {
  leafId: string;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface ClaimTransferSignRefundsResponse {
  signingResults: ClaimLeafSigningResult[];
}

export interface AggregateNodesRequest {
  nodeIds: string[];
  signingJob:
    | SigningJob
    | undefined;
  /** Serves as a temporary identity public key, this should be get from auth process. */
  ownerIdentityPublicKey: Uint8Array;
}

export interface AggregateNodesResponse {
  aggregateSignature: SigningResult | undefined;
  verifyingKey: Uint8Array;
  parentNodeTx: Uint8Array;
  parentNodeVout: number;
}

export interface StorePreimageShareRequest {
  paymentHash: Uint8Array;
  preimageShare: SecretShare | undefined;
  threshold: Uint8Array;
}

export interface RequestedSigningCommitments {
  signingNonceCommitments: { [key: string]: SigningCommitment };
}

export interface RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface GetSigningCommitmentsRequest {
  nodeIds: string[];
}

export interface GetSigningCommitmentsResponse {
  signingCommitments: RequestedSigningCommitments[];
}

function createBaseDepositAddressProof(): DepositAddressProof {
  return { addressSignatures: {}, proofOfPossessionSignature: new Uint8Array(0) };
}

export const DepositAddressProof: MessageFns<DepositAddressProof> = {
  encode(message: DepositAddressProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.addressSignatures).forEach(([key, value]) => {
      DepositAddressProof_AddressSignaturesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.proofOfPossessionSignature.length !== 0) {
      writer.uint32(18).bytes(message.proofOfPossessionSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DepositAddressProof_AddressSignaturesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.addressSignatures[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofOfPossessionSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof {
    return {
      addressSignatures: isObject(object.addressSignatures)
        ? Object.entries(object.addressSignatures).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      proofOfPossessionSignature: isSet(object.proofOfPossessionSignature)
        ? bytesFromBase64(object.proofOfPossessionSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof): unknown {
    const obj: any = {};
    if (message.addressSignatures) {
      const entries = Object.entries(message.addressSignatures);
      if (entries.length > 0) {
        obj.addressSignatures = {};
        entries.forEach(([k, v]) => {
          obj.addressSignatures[k] = base64FromBytes(v);
        });
      }
    }
    if (message.proofOfPossessionSignature.length !== 0) {
      obj.proofOfPossessionSignature = base64FromBytes(message.proofOfPossessionSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof>): DepositAddressProof {
    return DepositAddressProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositAddressProof>): DepositAddressProof {
    const message = createBaseDepositAddressProof();
    message.addressSignatures = Object.entries(object.addressSignatures ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.proofOfPossessionSignature = object.proofOfPossessionSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDepositAddressProof_AddressSignaturesEntry(): DepositAddressProof_AddressSignaturesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const DepositAddressProof_AddressSignaturesEntry: MessageFns<DepositAddressProof_AddressSignaturesEntry> = {
  encode(message: DepositAddressProof_AddressSignaturesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressProof_AddressSignaturesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof_AddressSignaturesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof_AddressSignaturesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof_AddressSignaturesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof_AddressSignaturesEntry>): DepositAddressProof_AddressSignaturesEntry {
    return DepositAddressProof_AddressSignaturesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DepositAddressProof_AddressSignaturesEntry>,
  ): DepositAddressProof_AddressSignaturesEntry {
    const message = createBaseDepositAddressProof_AddressSignaturesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGenerateDepositAddressRequest(): GenerateDepositAddressRequest {
  return { signingPublicKey: new Uint8Array(0), identityPublicKey: new Uint8Array(0) };
}

export const GenerateDepositAddressRequest: MessageFns<GenerateDepositAddressRequest> = {
  encode(message: GenerateDepositAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDepositAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDepositAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDepositAddressRequest {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: GenerateDepositAddressRequest): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDepositAddressRequest>): GenerateDepositAddressRequest {
    return GenerateDepositAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDepositAddressRequest>): GenerateDepositAddressRequest {
    const message = createBaseGenerateDepositAddressRequest();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAddress(): Address {
  return { address: "", verifyingKey: new Uint8Array(0), depositAddressProof: undefined };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      DepositAddressProof.encode(message.depositAddressProof, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.depositAddressProof = DepositAddressProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      depositAddressProof: isSet(object.depositAddressProof)
        ? DepositAddressProof.fromJSON(object.depositAddressProof)
        : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      obj.depositAddressProof = DepositAddressProof.toJSON(message.depositAddressProof);
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.address = object.address ?? "";
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.depositAddressProof = (object.depositAddressProof !== undefined && object.depositAddressProof !== null)
      ? DepositAddressProof.fromPartial(object.depositAddressProof)
      : undefined;
    return message;
  },
};

function createBaseGenerateDepositAddressResponse(): GenerateDepositAddressResponse {
  return { depositAddress: undefined };
}

export const GenerateDepositAddressResponse: MessageFns<GenerateDepositAddressResponse> = {
  encode(message: GenerateDepositAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.depositAddress !== undefined) {
      Address.encode(message.depositAddress, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDepositAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDepositAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddress = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDepositAddressResponse {
    return { depositAddress: isSet(object.depositAddress) ? Address.fromJSON(object.depositAddress) : undefined };
  },

  toJSON(message: GenerateDepositAddressResponse): unknown {
    const obj: any = {};
    if (message.depositAddress !== undefined) {
      obj.depositAddress = Address.toJSON(message.depositAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDepositAddressResponse>): GenerateDepositAddressResponse {
    return GenerateDepositAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDepositAddressResponse>): GenerateDepositAddressResponse {
    const message = createBaseGenerateDepositAddressResponse();
    message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
      ? Address.fromPartial(object.depositAddress)
      : undefined;
    return message;
  },
};

function createBaseUTXO(): UTXO {
  return { txid: "", vout: 0 };
}

export const UTXO: MessageFns<UTXO> = {
  encode(message: UTXO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UTXO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXO {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: UTXO): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<UTXO>): UTXO {
    return UTXO.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXO>): UTXO {
    const message = createBaseUTXO();
    message.txid = object.txid ?? "";
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseSigningJob(): SigningJob {
  return { signingPublicKey: new Uint8Array(0), rawTx: new Uint8Array(0), signingNonceCommitment: undefined };
}

export const SigningJob: MessageFns<SigningJob> = {
  encode(message: SigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(18).bytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(message.signingNonceCommitment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningJob {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
    };
  },

  toJSON(message: SigningJob): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(message.signingNonceCommitment);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningJob>): SigningJob {
    return SigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningJob>): SigningJob {
    const message = createBaseSigningJob();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.signingNonceCommitment =
      (object.signingNonceCommitment !== undefined && object.signingNonceCommitment !== null)
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    return message;
  },
};

function createBaseSigningResult(): SigningResult {
  return { publicKeys: {}, signingNonceCommitments: {}, signatureShares: {} };
}

export const SigningResult: MessageFns<SigningResult> = {
  encode(message: SigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.publicKeys).forEach(([key, value]) => {
      SigningResult_PublicKeysEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      SigningResult_SigningNonceCommitmentsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.signatureShares).forEach(([key, value]) => {
      SigningResult_SignatureSharesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningResult_PublicKeysEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.publicKeys[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SigningResult_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.signingNonceCommitments[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SigningResult_SignatureSharesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.signatureShares[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult {
    return {
      publicKeys: isObject(object.publicKeys)
        ? Object.entries(object.publicKeys).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      signatureShares: isObject(object.signatureShares)
        ? Object.entries(object.signatureShares).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SigningResult): unknown {
    const obj: any = {};
    if (message.publicKeys) {
      const entries = Object.entries(message.publicKeys);
      if (entries.length > 0) {
        obj.publicKeys = {};
        entries.forEach(([k, v]) => {
          obj.publicKeys[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    if (message.signatureShares) {
      const entries = Object.entries(message.signatureShares);
      if (entries.length > 0) {
        obj.signatureShares = {};
        entries.forEach(([k, v]) => {
          obj.signatureShares[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult>): SigningResult {
    return SigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult>): SigningResult {
    const message = createBaseSigningResult();
    message.publicKeys = Object.entries(object.publicKeys ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    message.signatureShares = Object.entries(object.signatureShares ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSigningResult_PublicKeysEntry(): SigningResult_PublicKeysEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_PublicKeysEntry: MessageFns<SigningResult_PublicKeysEntry> = {
  encode(message: SigningResult_PublicKeysEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_PublicKeysEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_PublicKeysEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_PublicKeysEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningResult_PublicKeysEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_PublicKeysEntry>): SigningResult_PublicKeysEntry {
    return SigningResult_PublicKeysEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult_PublicKeysEntry>): SigningResult_PublicKeysEntry {
    const message = createBaseSigningResult_PublicKeysEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSigningResult_SigningNonceCommitmentsEntry(): SigningResult_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningResult_SigningNonceCommitmentsEntry: MessageFns<SigningResult_SigningNonceCommitmentsEntry> = {
  encode(message: SigningResult_SigningNonceCommitmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_SigningNonceCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_SigningNonceCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SigningResult_SigningNonceCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>): SigningResult_SigningNonceCommitmentsEntry {
    return SigningResult_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>,
  ): SigningResult_SigningNonceCommitmentsEntry {
    const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSigningResult_SignatureSharesEntry(): SigningResult_SignatureSharesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_SignatureSharesEntry: MessageFns<SigningResult_SignatureSharesEntry> = {
  encode(message: SigningResult_SignatureSharesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_SignatureSharesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_SignatureSharesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_SignatureSharesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningResult_SignatureSharesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_SignatureSharesEntry>): SigningResult_SignatureSharesEntry {
    return SigningResult_SignatureSharesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult_SignatureSharesEntry>): SigningResult_SignatureSharesEntry {
    const message = createBaseSigningResult_SignatureSharesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeSignatureShares(): NodeSignatureShares {
  return {
    nodeId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
  };
}

export const NodeSignatureShares: MessageFns<NodeSignatureShares> = {
  encode(message: NodeSignatureShares, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(34).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatureShares {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatureShares();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatureShares {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatureShares): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    return NodeSignatureShares.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    const message = createBaseNodeSignatureShares();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
      ? SigningResult.fromPartial(object.nodeTxSigningResult)
      : undefined;
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeSignatures(): NodeSignatures {
  return { nodeId: "", nodeTxSignature: new Uint8Array(0), refundTxSignature: new Uint8Array(0) };
}

export const NodeSignatures: MessageFns<NodeSignatures> = {
  encode(message: NodeSignatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSignature.length !== 0) {
      writer.uint32(18).bytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      writer.uint32(26).bytes(message.refundTxSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatures {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSignature: isSet(object.nodeTxSignature) ? bytesFromBase64(object.nodeTxSignature) : new Uint8Array(0),
      refundTxSignature: isSet(object.refundTxSignature)
        ? bytesFromBase64(object.refundTxSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatures): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSignature.length !== 0) {
      obj.nodeTxSignature = base64FromBytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      obj.refundTxSignature = base64FromBytes(message.refundTxSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatures>): NodeSignatures {
    return NodeSignatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatures>): NodeSignatures {
    const message = createBaseNodeSignatures();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSignature = object.nodeTxSignature ?? new Uint8Array(0);
    message.refundTxSignature = object.refundTxSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartTreeCreationRequest(): StartTreeCreationRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    onChainUtxo: undefined,
    rootTxSigningJob: undefined,
    refundTxSigningJob: undefined,
  };
}

export const StartTreeCreationRequest: MessageFns<StartTreeCreationRequest> = {
  encode(message: StartTreeCreationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.rootTxSigningJob !== undefined) {
      SigningJob.encode(message.rootTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTreeCreationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      rootTxSigningJob: isSet(object.rootTxSigningJob) ? SigningJob.fromJSON(object.rootTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
    };
  },

  toJSON(message: StartTreeCreationRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.rootTxSigningJob !== undefined) {
      obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTreeCreationRequest>): StartTreeCreationRequest {
    return StartTreeCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTreeCreationRequest>): StartTreeCreationRequest {
    const message = createBaseStartTreeCreationRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.rootTxSigningJob = (object.rootTxSigningJob !== undefined && object.rootTxSigningJob !== null)
      ? SigningJob.fromPartial(object.rootTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    return message;
  },
};

function createBaseStartTreeCreationResponse(): StartTreeCreationResponse {
  return { treeId: "", rootNodeSignatureShares: undefined };
}

export const StartTreeCreationResponse: MessageFns<StartTreeCreationResponse> = {
  encode(message: StartTreeCreationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeId !== "") {
      writer.uint32(10).string(message.treeId);
    }
    if (message.rootNodeSignatureShares !== undefined) {
      NodeSignatureShares.encode(message.rootNodeSignatureShares, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTreeCreationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rootNodeSignatureShares = NodeSignatureShares.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationResponse {
    return {
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
        ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
        : undefined,
    };
  },

  toJSON(message: StartTreeCreationResponse): unknown {
    const obj: any = {};
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.rootNodeSignatureShares !== undefined) {
      obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(message.rootNodeSignatureShares);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTreeCreationResponse>): StartTreeCreationResponse {
    return StartTreeCreationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTreeCreationResponse>): StartTreeCreationResponse {
    const message = createBaseStartTreeCreationResponse();
    message.treeId = object.treeId ?? "";
    message.rootNodeSignatureShares =
      (object.rootNodeSignatureShares !== undefined && object.rootNodeSignatureShares !== null)
        ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
        : undefined;
    return message;
  },
};

function createBaseTreeNode(): TreeNode {
  return {
    id: "",
    treeId: "",
    value: 0,
    parentNodeId: undefined,
    nodeTx: new Uint8Array(0),
    refundTx: new Uint8Array(0),
    vout: 0,
    verifyingPublicKey: new Uint8Array(0),
    ownerIdentityPublicKey: new Uint8Array(0),
    refundTimelock: 0,
  };
}

export const TreeNode: MessageFns<TreeNode> = {
  encode(message: TreeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.treeId !== "") {
      writer.uint32(18).string(message.treeId);
    }
    if (message.value !== 0) {
      writer.uint32(24).uint64(message.value);
    }
    if (message.parentNodeId !== undefined) {
      writer.uint32(34).string(message.parentNodeId);
    }
    if (message.nodeTx.length !== 0) {
      writer.uint32(42).bytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(50).bytes(message.refundTx);
    }
    if (message.vout !== 0) {
      writer.uint32(56).uint32(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(74).bytes(message.ownerIdentityPublicKey);
    }
    if (message.refundTimelock !== 0) {
      writer.uint32(80).uint32(message.refundTimelock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentNodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nodeTx = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.verifyingPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.refundTimelock = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      parentNodeId: isSet(object.parentNodeId) ? globalThis.String(object.parentNodeId) : undefined,
      nodeTx: isSet(object.nodeTx) ? bytesFromBase64(object.nodeTx) : new Uint8Array(0),
      refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      verifyingPublicKey: isSet(object.verifyingPublicKey)
        ? bytesFromBase64(object.verifyingPublicKey)
        : new Uint8Array(0),
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      refundTimelock: isSet(object.refundTimelock) ? globalThis.Number(object.refundTimelock) : 0,
    };
  },

  toJSON(message: TreeNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.parentNodeId !== undefined) {
      obj.parentNodeId = message.parentNodeId;
    }
    if (message.nodeTx.length !== 0) {
      obj.nodeTx = base64FromBytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.refundTimelock !== 0) {
      obj.refundTimelock = Math.round(message.refundTimelock);
    }
    return obj;
  },

  create(base?: DeepPartial<TreeNode>): TreeNode {
    return TreeNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreeNode>): TreeNode {
    const message = createBaseTreeNode();
    message.id = object.id ?? "";
    message.treeId = object.treeId ?? "";
    message.value = object.value ?? 0;
    message.parentNodeId = object.parentNodeId ?? undefined;
    message.nodeTx = object.nodeTx ?? new Uint8Array(0);
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.refundTimelock = object.refundTimelock ?? 0;
    return message;
  },
};

function createBaseSplit(): Split {
  return { signingPublicKey: new Uint8Array(0), refundSigningJob: undefined, value: 0, vout: 0 };
}

export const Split: MessageFns<Split> = {
  encode(message: Split, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.refundSigningJob !== undefined) {
      SigningJob.encode(message.refundSigningJob, writer.uint32(18).fork()).join();
    }
    if (message.value !== 0) {
      writer.uint32(24).uint64(message.value);
    }
    if (message.vout !== 0) {
      writer.uint32(32).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Split {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Split {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      refundSigningJob: isSet(object.refundSigningJob) ? SigningJob.fromJSON(object.refundSigningJob) : undefined,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: Split): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.refundSigningJob !== undefined) {
      obj.refundSigningJob = SigningJob.toJSON(message.refundSigningJob);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<Split>): Split {
    return Split.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Split>): Split {
    const message = createBaseSplit();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.refundSigningJob = (object.refundSigningJob !== undefined && object.refundSigningJob !== null)
      ? SigningJob.fromPartial(object.refundSigningJob)
      : undefined;
    message.value = object.value ?? 0;
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseSplitNodeRequest(): SplitNodeRequest {
  return { nodeId: "", parentTxSigningJob: undefined, splits: [] };
}

export const SplitNodeRequest: MessageFns<SplitNodeRequest> = {
  encode(message: SplitNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.parentTxSigningJob !== undefined) {
      SigningJob.encode(message.parentTxSigningJob, writer.uint32(18).fork()).join();
    }
    for (const v of message.splits) {
      Split.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parentTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.splits.push(Split.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitNodeRequest {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      parentTxSigningJob: isSet(object.parentTxSigningJob) ? SigningJob.fromJSON(object.parentTxSigningJob) : undefined,
      splits: globalThis.Array.isArray(object?.splits) ? object.splits.map((e: any) => Split.fromJSON(e)) : [],
    };
  },

  toJSON(message: SplitNodeRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.parentTxSigningJob !== undefined) {
      obj.parentTxSigningJob = SigningJob.toJSON(message.parentTxSigningJob);
    }
    if (message.splits?.length) {
      obj.splits = message.splits.map((e) => Split.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SplitNodeRequest>): SplitNodeRequest {
    return SplitNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SplitNodeRequest>): SplitNodeRequest {
    const message = createBaseSplitNodeRequest();
    message.nodeId = object.nodeId ?? "";
    message.parentTxSigningJob = (object.parentTxSigningJob !== undefined && object.parentTxSigningJob !== null)
      ? SigningJob.fromPartial(object.parentTxSigningJob)
      : undefined;
    message.splits = object.splits?.map((e) => Split.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSplitResult(): SplitResult {
  return {
    nodeId: "",
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
    userPublicKey: new Uint8Array(0),
  };
}

export const SplitResult: MessageFns<SplitResult> = {
  encode(message: SplitResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingKey);
    }
    if (message.userPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.userPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitResult {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      userPublicKey: isSet(object.userPublicKey) ? bytesFromBase64(object.userPublicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: SplitResult): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.userPublicKey.length !== 0) {
      obj.userPublicKey = base64FromBytes(message.userPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<SplitResult>): SplitResult {
    return SplitResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SplitResult>): SplitResult {
    const message = createBaseSplitResult();
    message.nodeId = object.nodeId ?? "";
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.userPublicKey = object.userPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSplitNodeResponse(): SplitNodeResponse {
  return { parentNodeId: "", parentTxSigningResult: undefined, splitResults: [] };
}

export const SplitNodeResponse: MessageFns<SplitNodeResponse> = {
  encode(message: SplitNodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentNodeId !== "") {
      writer.uint32(10).string(message.parentNodeId);
    }
    if (message.parentTxSigningResult !== undefined) {
      SigningResult.encode(message.parentTxSigningResult, writer.uint32(18).fork()).join();
    }
    for (const v of message.splitResults) {
      SplitResult.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitNodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentNodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parentTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.splitResults.push(SplitResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitNodeResponse {
    return {
      parentNodeId: isSet(object.parentNodeId) ? globalThis.String(object.parentNodeId) : "",
      parentTxSigningResult: isSet(object.parentTxSigningResult)
        ? SigningResult.fromJSON(object.parentTxSigningResult)
        : undefined,
      splitResults: globalThis.Array.isArray(object?.splitResults)
        ? object.splitResults.map((e: any) => SplitResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SplitNodeResponse): unknown {
    const obj: any = {};
    if (message.parentNodeId !== "") {
      obj.parentNodeId = message.parentNodeId;
    }
    if (message.parentTxSigningResult !== undefined) {
      obj.parentTxSigningResult = SigningResult.toJSON(message.parentTxSigningResult);
    }
    if (message.splitResults?.length) {
      obj.splitResults = message.splitResults.map((e) => SplitResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SplitNodeResponse>): SplitNodeResponse {
    return SplitNodeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SplitNodeResponse>): SplitNodeResponse {
    const message = createBaseSplitNodeResponse();
    message.parentNodeId = object.parentNodeId ?? "";
    message.parentTxSigningResult =
      (object.parentTxSigningResult !== undefined && object.parentTxSigningResult !== null)
        ? SigningResult.fromPartial(object.parentTxSigningResult)
        : undefined;
    message.splitResults = object.splitResults?.map((e) => SplitResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizeNodeSignaturesRequest(): FinalizeNodeSignaturesRequest {
  return { intent: 0, nodeSignatures: [] };
}

export const FinalizeNodeSignaturesRequest: MessageFns<FinalizeNodeSignaturesRequest> = {
  encode(message: FinalizeNodeSignaturesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== 0) {
      writer.uint32(8).int32(message.intent);
    }
    for (const v of message.nodeSignatures) {
      NodeSignatures.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeNodeSignaturesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeNodeSignaturesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.intent = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeSignatures.push(NodeSignatures.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeNodeSignaturesRequest {
    return {
      intent: isSet(object.intent) ? signatureIntentFromJSON(object.intent) : 0,
      nodeSignatures: globalThis.Array.isArray(object?.nodeSignatures)
        ? object.nodeSignatures.map((e: any) => NodeSignatures.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinalizeNodeSignaturesRequest): unknown {
    const obj: any = {};
    if (message.intent !== 0) {
      obj.intent = signatureIntentToJSON(message.intent);
    }
    if (message.nodeSignatures?.length) {
      obj.nodeSignatures = message.nodeSignatures.map((e) => NodeSignatures.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeNodeSignaturesRequest>): FinalizeNodeSignaturesRequest {
    return FinalizeNodeSignaturesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeNodeSignaturesRequest>): FinalizeNodeSignaturesRequest {
    const message = createBaseFinalizeNodeSignaturesRequest();
    message.intent = object.intent ?? 0;
    message.nodeSignatures = object.nodeSignatures?.map((e) => NodeSignatures.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizeNodeSignaturesResponse(): FinalizeNodeSignaturesResponse {
  return { nodes: [] };
}

export const FinalizeNodeSignaturesResponse: MessageFns<FinalizeNodeSignaturesResponse> = {
  encode(message: FinalizeNodeSignaturesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      TreeNode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeNodeSignaturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeNodeSignaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(TreeNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeNodeSignaturesResponse {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => TreeNode.fromJSON(e)) : [] };
  },

  toJSON(message: FinalizeNodeSignaturesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => TreeNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeNodeSignaturesResponse>): FinalizeNodeSignaturesResponse {
    return FinalizeNodeSignaturesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeNodeSignaturesResponse>): FinalizeNodeSignaturesResponse {
    const message = createBaseFinalizeNodeSignaturesResponse();
    message.nodes = object.nodes?.map((e) => TreeNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareSplitAddressRequest(): PrepareSplitAddressRequest {
  return { nodeId: "", signingPublicKeys: [] };
}

export const PrepareSplitAddressRequest: MessageFns<PrepareSplitAddressRequest> = {
  encode(message: PrepareSplitAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    for (const v of message.signingPublicKeys) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareSplitAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareSplitAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingPublicKeys.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareSplitAddressRequest {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      signingPublicKeys: globalThis.Array.isArray(object?.signingPublicKeys)
        ? object.signingPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: PrepareSplitAddressRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.signingPublicKeys?.length) {
      obj.signingPublicKeys = message.signingPublicKeys.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareSplitAddressRequest>): PrepareSplitAddressRequest {
    return PrepareSplitAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrepareSplitAddressRequest>): PrepareSplitAddressRequest {
    const message = createBasePrepareSplitAddressRequest();
    message.nodeId = object.nodeId ?? "";
    message.signingPublicKeys = object.signingPublicKeys?.map((e) => e) || [];
    return message;
  },
};

function createBasePrepareSplitAddressResponse(): PrepareSplitAddressResponse {
  return { addresses: [] };
}

export const PrepareSplitAddressResponse: MessageFns<PrepareSplitAddressResponse> = {
  encode(message: PrepareSplitAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      Address.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareSplitAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareSplitAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(Address.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareSplitAddressResponse {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => Address.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PrepareSplitAddressResponse): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => Address.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareSplitAddressResponse>): PrepareSplitAddressResponse {
    return PrepareSplitAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrepareSplitAddressResponse>): PrepareSplitAddressResponse {
    const message = createBasePrepareSplitAddressResponse();
    message.addresses = object.addresses?.map((e) => Address.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSecretShare(): SecretShare {
  return { secretShare: new Uint8Array(0), proofs: [] };
}

export const SecretShare: MessageFns<SecretShare> = {
  encode(message: SecretShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretShare.length !== 0) {
      writer.uint32(10).bytes(message.secretShare);
    }
    for (const v of message.proofs) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretShare = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretShare {
    return {
      secretShare: isSet(object.secretShare) ? bytesFromBase64(object.secretShare) : new Uint8Array(0),
      proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: SecretShare): unknown {
    const obj: any = {};
    if (message.secretShare.length !== 0) {
      obj.secretShare = base64FromBytes(message.secretShare);
    }
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SecretShare>): SecretShare {
    return SecretShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretShare>): SecretShare {
    const message = createBaseSecretShare();
    message.secretShare = object.secretShare ?? new Uint8Array(0);
    message.proofs = object.proofs?.map((e) => e) || [];
    return message;
  },
};

function createBaseSendLeafKeyTweak(): SendLeafKeyTweak {
  return {
    leafId: "",
    secretShareTweak: undefined,
    pubkeySharesTweak: {},
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
  };
}

export const SendLeafKeyTweak: MessageFns<SendLeafKeyTweak> = {
  encode(message: SendLeafKeyTweak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      SendLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.secretCipher.length !== 0) {
      writer.uint32(34).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(42).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SendLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    return SendLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    const message = createBaseSendLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
      ? SecretShare.fromPartial(object.secretShareTweak)
      : undefined;
    message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendLeafKeyTweak_PubkeySharesTweakEntry(): SendLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SendLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<SendLeafKeyTweak_PubkeySharesTweakEntry> = {
  encode(message: SendLeafKeyTweak_PubkeySharesTweakEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak_PubkeySharesTweakEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak_PubkeySharesTweakEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak_PubkeySharesTweakEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>): SendLeafKeyTweak_PubkeySharesTweakEntry {
    return SendLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>): SendLeafKeyTweak_PubkeySharesTweakEntry {
    const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendTransferRequest(): SendTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
    receiverIdentityPublicKey: new Uint8Array(0),
    expiryTime: undefined,
  };
}

export const SendTransferRequest: MessageFns<SendTransferRequest> = {
  encode(message: SendTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      SendLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(SendLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => SendLeafKeyTweak.fromJSON(e))
        : [],
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
    };
  },

  toJSON(message: SendTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => SendLeafKeyTweak.toJSON(e));
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SendTransferRequest>): SendTransferRequest {
    return SendTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendTransferRequest>): SendTransferRequest {
    const message = createBaseSendTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend = object.leavesToSend?.map((e) => SendLeafKeyTweak.fromPartial(e)) || [];
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.expiryTime = object.expiryTime ?? undefined;
    return message;
  },
};

function createBaseTransfer(): Transfer {
  return {
    id: "",
    senderIdentityPublicKey: new Uint8Array(0),
    receiverIdentityPublicKey: new Uint8Array(0),
    status: 0,
    totalValue: 0,
    expiryTime: undefined,
    leaves: [],
  };
}

export const Transfer: MessageFns<Transfer> = {
  encode(message: Transfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.totalValue !== 0) {
      writer.uint32(40).uint64(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.leaves) {
      TransferLeaf.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalValue = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.leaves.push(TransferLeaf.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transfer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
        ? bytesFromBase64(object.senderIdentityPublicKey)
        : new Uint8Array(0),
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      status: isSet(object.status) ? transferStatusFromJSON(object.status) : 0,
      totalValue: isSet(object.totalValue) ? globalThis.Number(object.totalValue) : 0,
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e: any) => TransferLeaf.fromJSON(e)) : [],
    };
  },

  toJSON(message: Transfer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      obj.senderIdentityPublicKey = base64FromBytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      obj.status = transferStatusToJSON(message.status);
    }
    if (message.totalValue !== 0) {
      obj.totalValue = Math.round(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => TransferLeaf.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Transfer>): Transfer {
    return Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transfer>): Transfer {
    const message = createBaseTransfer();
    message.id = object.id ?? "";
    message.senderIdentityPublicKey = object.senderIdentityPublicKey ?? new Uint8Array(0);
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.totalValue = object.totalValue ?? 0;
    message.expiryTime = object.expiryTime ?? undefined;
    message.leaves = object.leaves?.map((e) => TransferLeaf.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferLeaf(): TransferLeaf {
  return { leaf: undefined, secretCipher: new Uint8Array(0), signature: new Uint8Array(0) };
}

export const TransferLeaf: MessageFns<TransferLeaf> = {
  encode(message: TransferLeaf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaf !== undefined) {
      TreeNode.encode(message.leaf, writer.uint32(10).fork()).join();
    }
    if (message.secretCipher.length !== 0) {
      writer.uint32(18).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferLeaf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferLeaf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaf = TreeNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferLeaf {
    return {
      leaf: isSet(object.leaf) ? TreeNode.fromJSON(object.leaf) : undefined,
      secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: TransferLeaf): unknown {
    const obj: any = {};
    if (message.leaf !== undefined) {
      obj.leaf = TreeNode.toJSON(message.leaf);
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferLeaf>): TransferLeaf {
    return TransferLeaf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferLeaf>): TransferLeaf {
    const message = createBaseTransferLeaf();
    message.leaf = (object.leaf !== undefined && object.leaf !== null) ? TreeNode.fromPartial(object.leaf) : undefined;
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendTransferResponse(): SendTransferResponse {
  return { transfer: undefined };
}

export const SendTransferResponse: MessageFns<SendTransferResponse> = {
  encode(message: SendTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendTransferResponse {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: SendTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<SendTransferResponse>): SendTransferResponse {
    return SendTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendTransferResponse>): SendTransferResponse {
    const message = createBaseSendTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseQueryPendingTransfersRequest(): QueryPendingTransfersRequest {
  return { receiverIdentityPublicKey: new Uint8Array(0) };
}

export const QueryPendingTransfersRequest: MessageFns<QueryPendingTransfersRequest> = {
  encode(message: QueryPendingTransfersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.receiverIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingTransfersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingTransfersRequest {
    return {
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryPendingTransfersRequest): unknown {
    const obj: any = {};
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPendingTransfersRequest>): QueryPendingTransfersRequest {
    return QueryPendingTransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPendingTransfersRequest>): QueryPendingTransfersRequest {
    const message = createBaseQueryPendingTransfersRequest();
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryPendingTransfersResponse(): QueryPendingTransfersResponse {
  return { transfers: [] };
}

export const QueryPendingTransfersResponse: MessageFns<QueryPendingTransfersResponse> = {
  encode(message: QueryPendingTransfersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transfers) {
      Transfer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingTransfersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfers.push(Transfer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingTransfersResponse {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => Transfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryPendingTransfersResponse): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => Transfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPendingTransfersResponse>): QueryPendingTransfersResponse {
    return QueryPendingTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPendingTransfersResponse>): QueryPendingTransfersResponse {
    const message = createBaseQueryPendingTransfersResponse();
    message.transfers = object.transfers?.map((e) => Transfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimLeafKeyTweak(): ClaimLeafKeyTweak {
  return { leafId: "", secretShareTweak: undefined, pubkeySharesTweak: {} };
}

export const ClaimLeafKeyTweak: MessageFns<ClaimLeafKeyTweak> = {
  encode(message: ClaimLeafKeyTweak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      ClaimLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClaimLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ClaimLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    return ClaimLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    const message = createBaseClaimLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
      ? SecretShare.fromPartial(object.secretShareTweak)
      : undefined;
    message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry(): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const ClaimLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<ClaimLeafKeyTweak_PubkeySharesTweakEntry> = {
  encode(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    return ClaimLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTransferTweakKeysRequest(): ClaimTransferTweakKeysRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToReceive: [] };
}

export const ClaimTransferTweakKeysRequest: MessageFns<ClaimTransferTweakKeysRequest> = {
  encode(message: ClaimTransferTweakKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToReceive) {
      ClaimLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferTweakKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferTweakKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToReceive.push(ClaimLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferTweakKeysRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToReceive: globalThis.Array.isArray(object?.leavesToReceive)
        ? object.leavesToReceive.map((e: any) => ClaimLeafKeyTweak.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferTweakKeysRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToReceive?.length) {
      obj.leavesToReceive = message.leavesToReceive.map((e) => ClaimLeafKeyTweak.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferTweakKeysRequest>): ClaimTransferTweakKeysRequest {
    return ClaimTransferTweakKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferTweakKeysRequest>): ClaimTransferTweakKeysRequest {
    const message = createBaseClaimTransferTweakKeysRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToReceive = object.leavesToReceive?.map((e) => ClaimLeafKeyTweak.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimLeafSigningJob(): ClaimLeafSigningJob {
  return { leafId: "", refundTxSigningJob: undefined };
}

export const ClaimLeafSigningJob: MessageFns<ClaimLeafSigningJob> = {
  encode(message: ClaimLeafSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafSigningJob {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
    };
  },

  toJSON(message: ClaimLeafSigningJob): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafSigningJob>): ClaimLeafSigningJob {
    return ClaimLeafSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafSigningJob>): ClaimLeafSigningJob {
    const message = createBaseClaimLeafSigningJob();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    return message;
  },
};

function createBaseClaimTransferSignRefundsRequest(): ClaimTransferSignRefundsRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: [] };
}

export const ClaimTransferSignRefundsRequest: MessageFns<ClaimTransferSignRefundsRequest> = {
  encode(message: ClaimTransferSignRefundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.signingJobs) {
      ClaimLeafSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferSignRefundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferSignRefundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingJobs.push(ClaimLeafSigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferSignRefundsRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingJobs: globalThis.Array.isArray(object?.signingJobs)
        ? object.signingJobs.map((e: any) => ClaimLeafSigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferSignRefundsRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.signingJobs?.length) {
      obj.signingJobs = message.signingJobs.map((e) => ClaimLeafSigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferSignRefundsRequest>): ClaimTransferSignRefundsRequest {
    return ClaimTransferSignRefundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferSignRefundsRequest>): ClaimTransferSignRefundsRequest {
    const message = createBaseClaimTransferSignRefundsRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingJobs = object.signingJobs?.map((e) => ClaimLeafSigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimLeafSigningResult(): ClaimLeafSigningResult {
  return { leafId: "", refundTxSigningResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const ClaimLeafSigningResult: MessageFns<ClaimLeafSigningResult> = {
  encode(message: ClaimLeafSigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafSigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafSigningResult {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimLeafSigningResult): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafSigningResult>): ClaimLeafSigningResult {
    return ClaimLeafSigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafSigningResult>): ClaimLeafSigningResult {
    const message = createBaseClaimLeafSigningResult();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTransferSignRefundsResponse(): ClaimTransferSignRefundsResponse {
  return { signingResults: [] };
}

export const ClaimTransferSignRefundsResponse: MessageFns<ClaimTransferSignRefundsResponse> = {
  encode(message: ClaimTransferSignRefundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingResults) {
      ClaimLeafSigningResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferSignRefundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferSignRefundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResults.push(ClaimLeafSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferSignRefundsResponse {
    return {
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => ClaimLeafSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferSignRefundsResponse): unknown {
    const obj: any = {};
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => ClaimLeafSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferSignRefundsResponse>): ClaimTransferSignRefundsResponse {
    return ClaimTransferSignRefundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferSignRefundsResponse>): ClaimTransferSignRefundsResponse {
    const message = createBaseClaimTransferSignRefundsResponse();
    message.signingResults = object.signingResults?.map((e) => ClaimLeafSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAggregateNodesRequest(): AggregateNodesRequest {
  return { nodeIds: [], signingJob: undefined, ownerIdentityPublicKey: new Uint8Array(0) };
}

export const AggregateNodesRequest: MessageFns<AggregateNodesRequest> = {
  encode(message: AggregateNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    if (message.signingJob !== undefined) {
      SigningJob.encode(message.signingJob, writer.uint32(18).fork()).join();
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.ownerIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateNodesRequest {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
      signingJob: isSet(object.signingJob) ? SigningJob.fromJSON(object.signingJob) : undefined,
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AggregateNodesRequest): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    if (message.signingJob !== undefined) {
      obj.signingJob = SigningJob.toJSON(message.signingJob);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateNodesRequest>): AggregateNodesRequest {
    return AggregateNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateNodesRequest>): AggregateNodesRequest {
    const message = createBaseAggregateNodesRequest();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.signingJob = (object.signingJob !== undefined && object.signingJob !== null)
      ? SigningJob.fromPartial(object.signingJob)
      : undefined;
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAggregateNodesResponse(): AggregateNodesResponse {
  return {
    aggregateSignature: undefined,
    verifyingKey: new Uint8Array(0),
    parentNodeTx: new Uint8Array(0),
    parentNodeVout: 0,
  };
}

export const AggregateNodesResponse: MessageFns<AggregateNodesResponse> = {
  encode(message: AggregateNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregateSignature !== undefined) {
      SigningResult.encode(message.aggregateSignature, writer.uint32(10).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.parentNodeTx.length !== 0) {
      writer.uint32(26).bytes(message.parentNodeTx);
    }
    if (message.parentNodeVout !== 0) {
      writer.uint32(32).uint32(message.parentNodeVout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.aggregateSignature = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentNodeTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parentNodeVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateNodesResponse {
    return {
      aggregateSignature: isSet(object.aggregateSignature)
        ? SigningResult.fromJSON(object.aggregateSignature)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      parentNodeTx: isSet(object.parentNodeTx) ? bytesFromBase64(object.parentNodeTx) : new Uint8Array(0),
      parentNodeVout: isSet(object.parentNodeVout) ? globalThis.Number(object.parentNodeVout) : 0,
    };
  },

  toJSON(message: AggregateNodesResponse): unknown {
    const obj: any = {};
    if (message.aggregateSignature !== undefined) {
      obj.aggregateSignature = SigningResult.toJSON(message.aggregateSignature);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.parentNodeTx.length !== 0) {
      obj.parentNodeTx = base64FromBytes(message.parentNodeTx);
    }
    if (message.parentNodeVout !== 0) {
      obj.parentNodeVout = Math.round(message.parentNodeVout);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateNodesResponse>): AggregateNodesResponse {
    return AggregateNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateNodesResponse>): AggregateNodesResponse {
    const message = createBaseAggregateNodesResponse();
    message.aggregateSignature = (object.aggregateSignature !== undefined && object.aggregateSignature !== null)
      ? SigningResult.fromPartial(object.aggregateSignature)
      : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.parentNodeTx = object.parentNodeTx ?? new Uint8Array(0);
    message.parentNodeVout = object.parentNodeVout ?? 0;
    return message;
  },
};

function createBaseStorePreimageShareRequest(): StorePreimageShareRequest {
  return { paymentHash: new Uint8Array(0), preimageShare: undefined, threshold: new Uint8Array(0) };
}

export const StorePreimageShareRequest: MessageFns<StorePreimageShareRequest> = {
  encode(message: StorePreimageShareRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.preimageShare !== undefined) {
      SecretShare.encode(message.preimageShare, writer.uint32(18).fork()).join();
    }
    if (message.threshold.length !== 0) {
      writer.uint32(26).bytes(message.threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorePreimageShareRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorePreimageShareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimageShare = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.threshold = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorePreimageShareRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      preimageShare: isSet(object.preimageShare) ? SecretShare.fromJSON(object.preimageShare) : undefined,
      threshold: isSet(object.threshold) ? bytesFromBase64(object.threshold) : new Uint8Array(0),
    };
  },

  toJSON(message: StorePreimageShareRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.preimageShare !== undefined) {
      obj.preimageShare = SecretShare.toJSON(message.preimageShare);
    }
    if (message.threshold.length !== 0) {
      obj.threshold = base64FromBytes(message.threshold);
    }
    return obj;
  },

  create(base?: DeepPartial<StorePreimageShareRequest>): StorePreimageShareRequest {
    return StorePreimageShareRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorePreimageShareRequest>): StorePreimageShareRequest {
    const message = createBaseStorePreimageShareRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.preimageShare = (object.preimageShare !== undefined && object.preimageShare !== null)
      ? SecretShare.fromPartial(object.preimageShare)
      : undefined;
    message.threshold = object.threshold ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestedSigningCommitments(): RequestedSigningCommitments {
  return { signingNonceCommitments: {} };
}

export const RequestedSigningCommitments: MessageFns<RequestedSigningCommitments> = {
  encode(message: RequestedSigningCommitments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      RequestedSigningCommitments_SigningNonceCommitmentsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestedSigningCommitments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestedSigningCommitments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = RequestedSigningCommitments_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingNonceCommitments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestedSigningCommitments {
    return {
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: RequestedSigningCommitments): unknown {
    const obj: any = {};
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RequestedSigningCommitments>): RequestedSigningCommitments {
    return RequestedSigningCommitments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestedSigningCommitments>): RequestedSigningCommitments {
    const message = createBaseRequestedSigningCommitments();
    message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry(): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const RequestedSigningCommitments_SigningNonceCommitmentsEntry: MessageFns<
  RequestedSigningCommitments_SigningNonceCommitmentsEntry
> = {
  encode(
    message: RequestedSigningCommitments_SigningNonceCommitmentsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RequestedSigningCommitments_SigningNonceCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
  ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    return RequestedSigningCommitments_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
  ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetSigningCommitmentsRequest(): GetSigningCommitmentsRequest {
  return { nodeIds: [] };
}

export const GetSigningCommitmentsRequest: MessageFns<GetSigningCommitmentsRequest> = {
  encode(message: GetSigningCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningCommitmentsRequest {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetSigningCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningCommitmentsRequest>): GetSigningCommitmentsRequest {
    return GetSigningCommitmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningCommitmentsRequest>): GetSigningCommitmentsRequest {
    const message = createBaseGetSigningCommitmentsRequest();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSigningCommitmentsResponse(): GetSigningCommitmentsResponse {
  return { signingCommitments: [] };
}

export const GetSigningCommitmentsResponse: MessageFns<GetSigningCommitmentsResponse> = {
  encode(message: GetSigningCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingCommitments) {
      RequestedSigningCommitments.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingCommitments.push(RequestedSigningCommitments.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningCommitmentsResponse {
    return {
      signingCommitments: globalThis.Array.isArray(object?.signingCommitments)
        ? object.signingCommitments.map((e: any) => RequestedSigningCommitments.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSigningCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.signingCommitments?.length) {
      obj.signingCommitments = message.signingCommitments.map((e) => RequestedSigningCommitments.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningCommitmentsResponse>): GetSigningCommitmentsResponse {
    return GetSigningCommitmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningCommitmentsResponse>): GetSigningCommitmentsResponse {
    const message = createBaseGetSigningCommitmentsResponse();
    message.signingCommitments = object.signingCommitments?.map((e) => RequestedSigningCommitments.fromPartial(e)) ||
      [];
    return message;
  },
};

export type SparkServiceDefinition = typeof SparkServiceDefinition;
export const SparkServiceDefinition = {
  name: "SparkService",
  fullName: "spark.SparkService",
  methods: {
    generate_deposit_address: {
      name: "generate_deposit_address",
      requestType: GenerateDepositAddressRequest,
      requestStream: false,
      responseType: GenerateDepositAddressResponse,
      responseStream: false,
      options: {},
    },
    start_tree_creation: {
      name: "start_tree_creation",
      requestType: StartTreeCreationRequest,
      requestStream: false,
      responseType: StartTreeCreationResponse,
      responseStream: false,
      options: {},
    },
    prepare_split_address: {
      name: "prepare_split_address",
      requestType: PrepareSplitAddressRequest,
      requestStream: false,
      responseType: PrepareSplitAddressResponse,
      responseStream: false,
      options: {},
    },
    split_node: {
      name: "split_node",
      requestType: SplitNodeRequest,
      requestStream: false,
      responseType: SplitNodeResponse,
      responseStream: false,
      options: {},
    },
    finalize_node_signatures: {
      name: "finalize_node_signatures",
      requestType: FinalizeNodeSignaturesRequest,
      requestStream: false,
      responseType: FinalizeNodeSignaturesResponse,
      responseStream: false,
      options: {},
    },
    send_transfer: {
      name: "send_transfer",
      requestType: SendTransferRequest,
      requestStream: false,
      responseType: SendTransferResponse,
      responseStream: false,
      options: {},
    },
    query_pending_transfers: {
      name: "query_pending_transfers",
      requestType: QueryPendingTransfersRequest,
      requestStream: false,
      responseType: QueryPendingTransfersResponse,
      responseStream: false,
      options: {},
    },
    claim_transfer_tweak_keys: {
      name: "claim_transfer_tweak_keys",
      requestType: ClaimTransferTweakKeysRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    claim_transfer_sign_refunds: {
      name: "claim_transfer_sign_refunds",
      requestType: ClaimTransferSignRefundsRequest,
      requestStream: false,
      responseType: ClaimTransferSignRefundsResponse,
      responseStream: false,
      options: {},
    },
    aggregate_nodes: {
      name: "aggregate_nodes",
      requestType: AggregateNodesRequest,
      requestStream: false,
      responseType: AggregateNodesResponse,
      responseStream: false,
      options: {},
    },
    store_preimage_share: {
      name: "store_preimage_share",
      requestType: StorePreimageShareRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    get_signing_commitments: {
      name: "get_signing_commitments",
      requestType: GetSigningCommitmentsRequest,
      requestStream: false,
      responseType: GetSigningCommitmentsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SparkServiceImplementation<CallContextExt = {}> {
  generate_deposit_address(
    request: GenerateDepositAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateDepositAddressResponse>>;
  start_tree_creation(
    request: StartTreeCreationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTreeCreationResponse>>;
  prepare_split_address(
    request: PrepareSplitAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PrepareSplitAddressResponse>>;
  split_node(request: SplitNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SplitNodeResponse>>;
  finalize_node_signatures(
    request: FinalizeNodeSignaturesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeNodeSignaturesResponse>>;
  send_transfer(
    request: SendTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SendTransferResponse>>;
  query_pending_transfers(
    request: QueryPendingTransfersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryPendingTransfersResponse>>;
  claim_transfer_tweak_keys(
    request: ClaimTransferTweakKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  claim_transfer_sign_refunds(
    request: ClaimTransferSignRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ClaimTransferSignRefundsResponse>>;
  aggregate_nodes(
    request: AggregateNodesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AggregateNodesResponse>>;
  store_preimage_share(
    request: StorePreimageShareRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  get_signing_commitments(
    request: GetSigningCommitmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningCommitmentsResponse>>;
}

export interface SparkServiceClient<CallOptionsExt = {}> {
  generate_deposit_address(
    request: DeepPartial<GenerateDepositAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateDepositAddressResponse>;
  start_tree_creation(
    request: DeepPartial<StartTreeCreationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTreeCreationResponse>;
  prepare_split_address(
    request: DeepPartial<PrepareSplitAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PrepareSplitAddressResponse>;
  split_node(
    request: DeepPartial<SplitNodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SplitNodeResponse>;
  finalize_node_signatures(
    request: DeepPartial<FinalizeNodeSignaturesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeNodeSignaturesResponse>;
  send_transfer(
    request: DeepPartial<SendTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SendTransferResponse>;
  query_pending_transfers(
    request: DeepPartial<QueryPendingTransfersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryPendingTransfersResponse>;
  claim_transfer_tweak_keys(
    request: DeepPartial<ClaimTransferTweakKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  claim_transfer_sign_refunds(
    request: DeepPartial<ClaimTransferSignRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ClaimTransferSignRefundsResponse>;
  aggregate_nodes(
    request: DeepPartial<AggregateNodesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AggregateNodesResponse>;
  store_preimage_share(
    request: DeepPartial<StorePreimageShareRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  get_signing_commitments(
    request: DeepPartial<GetSigningCommitmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningCommitmentsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
