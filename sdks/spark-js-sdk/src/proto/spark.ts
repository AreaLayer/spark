// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: spark.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { SignatureIntent, signatureIntentFromJSON, signatureIntentToJSON, SigningCommitment } from "./common";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "spark";

export enum TransferStatus {
  TRANSFER_STATUS_SENDER_INITIATED = 0,
  TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING = 1,
  TRANSFER_STATUS_SENDER_KEY_TWEAKED = 2,
  TRANSFER_STATUS_RECEIVER_KEY_TWEAKED = 3,
  TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED = 4,
  TRANSFER_STATUS_COMPLETED = 5,
  TRANSFER_STATUS_EXPIRED = 6,
  UNRECOGNIZED = -1,
}

export function transferStatusFromJSON(object: any): TransferStatus {
  switch (object) {
    case 0:
    case "TRANSFER_STATUS_SENDER_INITIATED":
      return TransferStatus.TRANSFER_STATUS_SENDER_INITIATED;
    case 1:
    case "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING":
      return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING;
    case 2:
    case "TRANSFER_STATUS_SENDER_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED;
    case 3:
    case "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED":
      return TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED;
    case 4:
    case "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED":
      return TransferStatus.TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED;
    case 5:
    case "TRANSFER_STATUS_COMPLETED":
      return TransferStatus.TRANSFER_STATUS_COMPLETED;
    case 6:
    case "TRANSFER_STATUS_EXPIRED":
      return TransferStatus.TRANSFER_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferStatus.UNRECOGNIZED;
  }
}

export function transferStatusToJSON(object: TransferStatus): string {
  switch (object) {
    case TransferStatus.TRANSFER_STATUS_SENDER_INITIATED:
      return "TRANSFER_STATUS_SENDER_INITIATED";
    case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING:
      return "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING";
    case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED:
      return "TRANSFER_STATUS_SENDER_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED:
      return "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED";
    case TransferStatus.TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED:
      return "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED";
    case TransferStatus.TRANSFER_STATUS_COMPLETED:
      return "TRANSFER_STATUS_COMPLETED";
    case TransferStatus.TRANSFER_STATUS_EXPIRED:
      return "TRANSFER_STATUS_EXPIRED";
    case TransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DepositAddressProof {
  addressSignatures: { [key: string]: Uint8Array };
  proofOfPossessionSignature: Uint8Array;
}

export interface DepositAddressProof_AddressSignaturesEntry {
  key: string;
  value: Uint8Array;
}

export interface GenerateDepositAddressRequest {
  signingPublicKey: Uint8Array;
  identityPublicKey: Uint8Array;
}

export interface Address {
  address: string;
  verifyingKey: Uint8Array;
  depositAddressProof: DepositAddressProof | undefined;
}

export interface GenerateDepositAddressResponse {
  depositAddress: Address | undefined;
}

export interface UTXO {
  txid: string;
  vout: number;
  rawTx: Uint8Array;
}

export interface NodeOutput {
  nodeId: string;
  vout: number;
}

export interface SigningJob {
  signingPublicKey: Uint8Array;
  rawTx: Uint8Array;
  signingNonceCommitment: SigningCommitment | undefined;
}

export interface SigningKeyshare {
  ownerIdentifiers: string[];
  threshold: number;
}

export interface SigningResult {
  publicKeys: { [key: string]: Uint8Array };
  signingNonceCommitments: { [key: string]: SigningCommitment };
  signatureShares: { [key: string]: Uint8Array };
  signingKeyshare: SigningKeyshare | undefined;
}

export interface SigningResult_PublicKeysEntry {
  key: string;
  value: Uint8Array;
}

export interface SigningResult_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface SigningResult_SignatureSharesEntry {
  key: string;
  value: Uint8Array;
}

export interface NodeSignatureShares {
  nodeId: string;
  nodeTxSigningResult: SigningResult | undefined;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface NodeSignatures {
  nodeId: string;
  nodeTxSignature: Uint8Array;
  refundTxSignature: Uint8Array;
}

export interface StartTreeCreationRequest {
  identityPublicKey: Uint8Array;
  onChainUtxo: UTXO | undefined;
  rootTxSigningJob: SigningJob | undefined;
  refundTxSigningJob: SigningJob | undefined;
}

export interface StartTreeCreationResponse {
  treeId: string;
  rootNodeSignatureShares: NodeSignatureShares | undefined;
}

/**
 * This proto is included by the wallet in a token transaction request
 * to inform the SO set of the nonce and signing public key that the
 * wallet will use for this token transaction.
 */
export interface TokenTransactionSigningJob {
  leafId: Uint8Array;
  signingNonceCommitment:
    | SigningCommitment
    | undefined;
  /**
   * Signature of the partial token transaction hash to prove that the requesting
   * wallet has the signing key necessary to spend the leaves before SO's resolve
   * the revocation private key.
   * Note that actual combined signing will happen later.
   */
  ownershipSignature: Uint8Array;
}

/**
 * This proto is returned to the wallet after the initial token transaction
 * request so that it can verify the SE combined signature, generate the final
 * aggregate signature, and finalize the transaction with the SE.
 */
export interface TokenTransactionSignatureShares {
  tokenTransactionHash: Uint8Array;
  tokenTransactionSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

/**
 * This proto is constructed by the wallet (without a revocation private key initially)
 * to specify leaves it wants to spend as part of a token transaction. Upon starting
 * the private key field will be filled and returned by the Coordinator SO so that the
 * wallet can validate the full transaction hash before finalizng the transaction.
 */
export interface TokenLeafToSpend {
  tokenTransactionHash: Uint8Array;
  tokenLeafIndex: number;
  revocationPrivateKey: Uint8Array;
}

/**
 * This proto is constructed by the wallet to specify leaves it wants to create
 * as part of a token transaction.
 */
export interface TokenLeafToCreate {
  id: string;
  verifyingKey: Uint8Array;
  ownerIdentityPublicKey: Uint8Array;
  revocationPublicKey: Uint8Array;
  withdrawalBondSats: number;
  withdrawalLocktime: number;
  tokenPublicKey: Uint8Array;
  /** Decoded uint128 */
  tokenAmount: Uint8Array;
}

/**
 * This proto is constructed by the wallet and is the core transaction data structure.
 * This proto is deterministically hashed to generate the token_transaction_hash that
 * is cooperatively signed by the SO group to confirm a token transaction.
 */
export interface TokenTransaction {
  /**
   * For issuance transactions there will be 0 input leaves and one or more output leaves.
   * For transfer transactions the token amount in the input leaves must match the token amount in the output leaves.
   */
  leavesToSpend: TokenLeafToSpend[];
  leavesToCreate: TokenLeafToCreate[];
}

export interface GenerateRevocationPublicKeyResponse {
  revocationPublicKey: Uint8Array;
}

export interface StartTokenTransactionRequest {
  identityPublicKey: Uint8Array;
  partialTokenTransaction:
    | TokenTransaction
    | undefined;
  /**
   * For issuance transactions this should have one signing job where the signing public key
   * is the same as the wallets identity public key (which is also the token public key).
   * For transfer transactions this should have one signing job for each leaf in
   * leaves_to_spend within the token transaction.
   */
  signingJobs: TokenTransactionSigningJob[];
}

export interface StartTokenTransactionResponse {
  /**
   * This is the same token transaction sent by the wallet with the revocation
   * private key for each spent leaf filled in by the SO.  This is the final transaction
   * that will be signed and used for the token transaction hash.
   * Note that for issuance (because no leaves are spent) this will match the
   * token transaction provided by the wallet.
   */
  finalizedTokenTransaction: TokenTransaction | undefined;
  signatureShares: TokenTransactionSignatureShares[];
}

export interface FinalizeTokenTransactionRequest {
  /** Deterministic hash of token transaction payload */
  tokenTransactionHash: Uint8Array;
  /**
   * Combined signatures by the SO set and User.
   * For issuance this will be one signature for the entire operation.
   * For transfer this will be multiple signatures in the same order as the provided TokenLeafToSpend objects
   * when constructing the TokenTransaction.
   */
  signatures: Uint8Array[];
}

export interface TreeNode {
  id: string;
  treeId: string;
  value: number;
  parentNodeId?: string | undefined;
  nodeTx: Uint8Array;
  refundTx: Uint8Array;
  vout: number;
  verifyingPublicKey: Uint8Array;
  ownerIdentityPublicKey: Uint8Array;
  refundTimelock: number;
}

export interface FinalizeNodeSignaturesRequest {
  intent: SignatureIntent;
  nodeSignatures: NodeSignatures[];
}

export interface FinalizeNodeSignaturesResponse {
  nodes: TreeNode[];
}

export interface SecretShare {
  secretShare: Uint8Array;
  proofs: Uint8Array[];
}

export interface LeafRefundTxSigningJob {
  leafId: string;
  refundTxSigningJob: SigningJob | undefined;
}

export interface LeafRefundTxSigningResult {
  leafId: string;
  refundTxSigningResult: SigningResult | undefined;
  verifyingKey: Uint8Array;
}

export interface StartSendTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: LeafRefundTxSigningJob[];
  receiverIdentityPublicKey: Uint8Array;
  expiryTime: Date | undefined;
}

export interface StartSendTransferResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface SendLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
  secretCipher: Uint8Array;
  /** Signature over Sha256(leaf_id||transfer_id||secret_cipher) */
  signature: Uint8Array;
  refundSignature: Uint8Array;
}

export interface SendLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface CompleteSendTransferRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToSend: SendLeafKeyTweak[];
}

export interface Transfer {
  id: string;
  senderIdentityPublicKey: Uint8Array;
  receiverIdentityPublicKey: Uint8Array;
  status: TransferStatus;
  totalValue: number;
  expiryTime: Date | undefined;
  leaves: TransferLeaf[];
}

export interface TransferLeaf {
  leaf: TreeNode | undefined;
  secretCipher: Uint8Array;
  signature: Uint8Array;
  intermediateRefundTx: Uint8Array;
  signingKeyshare: SigningKeyshare | undefined;
}

export interface CompleteSendTransferResponse {
  transfer: Transfer | undefined;
}

export interface QueryPendingTransfersRequest {
  receiverIdentityPublicKey: Uint8Array;
}

export interface QueryPendingTransfersResponse {
  transfers: Transfer[];
}

export interface ClaimLeafKeyTweak {
  leafId: string;
  secretShareTweak: SecretShare | undefined;
  pubkeySharesTweak: { [key: string]: Uint8Array };
}

export interface ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  key: string;
  value: Uint8Array;
}

export interface ClaimTransferTweakKeysRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  leavesToReceive: ClaimLeafKeyTweak[];
}

export interface ClaimTransferSignRefundsRequest {
  transferId: string;
  ownerIdentityPublicKey: Uint8Array;
  signingJobs: LeafRefundTxSigningJob[];
}

export interface ClaimTransferSignRefundsResponse {
  signingResults: LeafRefundTxSigningResult[];
}

export interface AggregateNodesRequest {
  nodeIds: string[];
  signingJob:
    | SigningJob
    | undefined;
  /** Serves as a temporary identity public key, this should be get from auth process. */
  ownerIdentityPublicKey: Uint8Array;
}

export interface AggregateNodesResponse {
  aggregateSignature: SigningResult | undefined;
  verifyingKey: Uint8Array;
  parentNodeTx: Uint8Array;
  parentNodeVout: number;
}

export interface StorePreimageShareRequest {
  paymentHash: Uint8Array;
  preimageShare: SecretShare | undefined;
  threshold: number;
  invoiceString: string;
  /** TODO: This should be removed once we have a proper auth process. */
  userIdentityPublicKey: Uint8Array;
}

export interface RequestedSigningCommitments {
  signingNonceCommitments: { [key: string]: SigningCommitment };
}

export interface RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface GetSigningCommitmentsRequest {
  nodeIds: string[];
}

export interface GetSigningCommitmentsResponse {
  signingCommitments: RequestedSigningCommitments[];
}

export interface SigningCommitments {
  signingCommitments: { [key: string]: SigningCommitment };
}

export interface SigningCommitments_SigningCommitmentsEntry {
  key: string;
  value: SigningCommitment | undefined;
}

export interface UserSignedRefund {
  nodeId: string;
  refundTx: Uint8Array;
  userSignature: Uint8Array;
  signingCommitments: SigningCommitments | undefined;
  userSignatureCommitment: SigningCommitment | undefined;
}

export interface InvoiceAmountProof {
  bolt11Invoice: string;
}

export interface InvoiceAmount {
  valueSats: number;
  invoiceAmountProof: InvoiceAmountProof | undefined;
}

export interface InitiatePreimageSwapRequest {
  paymentHash: Uint8Array;
  userSignedRefunds: UserSignedRefund[];
  invoiceAmount: InvoiceAmount | undefined;
  reason: InitiatePreimageSwapRequest_Reason;
  transfer: StartSendTransferRequest | undefined;
  receiverIdentityPublicKey: Uint8Array;
}

export enum InitiatePreimageSwapRequest_Reason {
  REASON_SEND = 0,
  REASON_RECEIVE = 1,
  UNRECOGNIZED = -1,
}

export function initiatePreimageSwapRequest_ReasonFromJSON(object: any): InitiatePreimageSwapRequest_Reason {
  switch (object) {
    case 0:
    case "REASON_SEND":
      return InitiatePreimageSwapRequest_Reason.REASON_SEND;
    case 1:
    case "REASON_RECEIVE":
      return InitiatePreimageSwapRequest_Reason.REASON_RECEIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InitiatePreimageSwapRequest_Reason.UNRECOGNIZED;
  }
}

export function initiatePreimageSwapRequest_ReasonToJSON(object: InitiatePreimageSwapRequest_Reason): string {
  switch (object) {
    case InitiatePreimageSwapRequest_Reason.REASON_SEND:
      return "REASON_SEND";
    case InitiatePreimageSwapRequest_Reason.REASON_RECEIVE:
      return "REASON_RECEIVE";
    case InitiatePreimageSwapRequest_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InitiatePreimageSwapResponse {
  preimage: Uint8Array;
  transfer: Transfer | undefined;
}

export interface OutPoint {
  txid: Uint8Array;
  vout: number;
}

export interface CooperativeExitRequest {
  transfer: StartSendTransferRequest | undefined;
  exitId: string;
  /** TODO: provide signatures for the leaves so SE can be watchtower */
  exitTxid: Uint8Array;
}

export interface CooperativeExitResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface LeafSwapRequest {
  transfer: StartSendTransferRequest | undefined;
  swapId: string;
  adaptorPublicKey: Uint8Array;
}

export interface LeafSwapResponse {
  transfer: Transfer | undefined;
  signingResults: LeafRefundTxSigningResult[];
}

export interface AddressRequestNode {
  userPublicKey: Uint8Array;
  children: AddressRequestNode[];
}

export interface PrepareTreeAddressRequest {
  parentNodeOutput?: NodeOutput | undefined;
  onChainUtxo?:
    | UTXO
    | undefined;
  /**
   * The tx on this node is to spend the source's utxo.
   * The user's public key should already be registered with the SE for the root node.
   */
  node:
    | AddressRequestNode
    | undefined;
  /** TODO: This should be removed once we have a proper auth process. */
  userIdentityPublicKey: Uint8Array;
}

export interface AddressNode {
  address: Address | undefined;
  children: AddressNode[];
}

export interface PrepareTreeAddressResponse {
  node: AddressNode | undefined;
}

export interface CreationNode {
  /** This is the tx that spends the parent node's output. */
  nodeTxSigningJob:
    | SigningJob
    | undefined;
  /** The refund tx can only exist if there's no children. */
  refundTxSigningJob:
    | SigningJob
    | undefined;
  /** The children will spend the output of the node's tx. Vout is the index of the child. */
  children: CreationNode[];
}

export interface CreateTreeRequest {
  parentNodeOutput?: NodeOutput | undefined;
  onChainUtxo?:
    | UTXO
    | undefined;
  /** The node should contain the tx that spends the source's utxo. */
  node:
    | CreationNode
    | undefined;
  /** The owner of the tree. */
  userIdentityPublicKey: Uint8Array;
}

export interface CreationResponseNode {
  nodeId: string;
  nodeTxSigningResult: SigningResult | undefined;
  refundTxSigningResult: SigningResult | undefined;
  children: CreationResponseNode[];
}

export interface CreateTreeResponse {
  node: CreationResponseNode | undefined;
}

export interface SigningOperatorInfo {
  index: number;
  identifier: string;
  publicKey: Uint8Array;
  address: string;
}

export interface GetSigningOperatorListResponse {
  signingOperators: { [key: string]: SigningOperatorInfo };
}

export interface GetSigningOperatorListResponse_SigningOperatorsEntry {
  key: string;
  value: SigningOperatorInfo | undefined;
}

export interface QueryUserSignedRefundsRequest {
  paymentHash: Uint8Array;
}

export interface QueryUserSignedRefundsResponse {
  userSignedRefunds: UserSignedRefund[];
}

export interface ProvidePreimageRequest {
  paymentHash: Uint8Array;
  preimage: Uint8Array;
}

export interface ProvidePreimageResponse {
  transfer: Transfer | undefined;
}

function createBaseDepositAddressProof(): DepositAddressProof {
  return { addressSignatures: {}, proofOfPossessionSignature: new Uint8Array(0) };
}

export const DepositAddressProof: MessageFns<DepositAddressProof> = {
  encode(message: DepositAddressProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.addressSignatures).forEach(([key, value]) => {
      DepositAddressProof_AddressSignaturesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.proofOfPossessionSignature.length !== 0) {
      writer.uint32(18).bytes(message.proofOfPossessionSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DepositAddressProof_AddressSignaturesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.addressSignatures[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofOfPossessionSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof {
    return {
      addressSignatures: isObject(object.addressSignatures)
        ? Object.entries(object.addressSignatures).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      proofOfPossessionSignature: isSet(object.proofOfPossessionSignature)
        ? bytesFromBase64(object.proofOfPossessionSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof): unknown {
    const obj: any = {};
    if (message.addressSignatures) {
      const entries = Object.entries(message.addressSignatures);
      if (entries.length > 0) {
        obj.addressSignatures = {};
        entries.forEach(([k, v]) => {
          obj.addressSignatures[k] = base64FromBytes(v);
        });
      }
    }
    if (message.proofOfPossessionSignature.length !== 0) {
      obj.proofOfPossessionSignature = base64FromBytes(message.proofOfPossessionSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof>): DepositAddressProof {
    return DepositAddressProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DepositAddressProof>): DepositAddressProof {
    const message = createBaseDepositAddressProof();
    message.addressSignatures = Object.entries(object.addressSignatures ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.proofOfPossessionSignature = object.proofOfPossessionSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDepositAddressProof_AddressSignaturesEntry(): DepositAddressProof_AddressSignaturesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const DepositAddressProof_AddressSignaturesEntry: MessageFns<DepositAddressProof_AddressSignaturesEntry> = {
  encode(message: DepositAddressProof_AddressSignaturesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositAddressProof_AddressSignaturesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositAddressProof_AddressSignaturesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositAddressProof_AddressSignaturesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: DepositAddressProof_AddressSignaturesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DepositAddressProof_AddressSignaturesEntry>): DepositAddressProof_AddressSignaturesEntry {
    return DepositAddressProof_AddressSignaturesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DepositAddressProof_AddressSignaturesEntry>,
  ): DepositAddressProof_AddressSignaturesEntry {
    const message = createBaseDepositAddressProof_AddressSignaturesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGenerateDepositAddressRequest(): GenerateDepositAddressRequest {
  return { signingPublicKey: new Uint8Array(0), identityPublicKey: new Uint8Array(0) };
}

export const GenerateDepositAddressRequest: MessageFns<GenerateDepositAddressRequest> = {
  encode(message: GenerateDepositAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.identityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDepositAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDepositAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDepositAddressRequest {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: GenerateDepositAddressRequest): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDepositAddressRequest>): GenerateDepositAddressRequest {
    return GenerateDepositAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDepositAddressRequest>): GenerateDepositAddressRequest {
    const message = createBaseGenerateDepositAddressRequest();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAddress(): Address {
  return { address: "", verifyingKey: new Uint8Array(0), depositAddressProof: undefined };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      DepositAddressProof.encode(message.depositAddressProof, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.depositAddressProof = DepositAddressProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      depositAddressProof: isSet(object.depositAddressProof)
        ? DepositAddressProof.fromJSON(object.depositAddressProof)
        : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.depositAddressProof !== undefined) {
      obj.depositAddressProof = DepositAddressProof.toJSON(message.depositAddressProof);
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.address = object.address ?? "";
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.depositAddressProof = (object.depositAddressProof !== undefined && object.depositAddressProof !== null)
      ? DepositAddressProof.fromPartial(object.depositAddressProof)
      : undefined;
    return message;
  },
};

function createBaseGenerateDepositAddressResponse(): GenerateDepositAddressResponse {
  return { depositAddress: undefined };
}

export const GenerateDepositAddressResponse: MessageFns<GenerateDepositAddressResponse> = {
  encode(message: GenerateDepositAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.depositAddress !== undefined) {
      Address.encode(message.depositAddress, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDepositAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDepositAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.depositAddress = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateDepositAddressResponse {
    return { depositAddress: isSet(object.depositAddress) ? Address.fromJSON(object.depositAddress) : undefined };
  },

  toJSON(message: GenerateDepositAddressResponse): unknown {
    const obj: any = {};
    if (message.depositAddress !== undefined) {
      obj.depositAddress = Address.toJSON(message.depositAddress);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateDepositAddressResponse>): GenerateDepositAddressResponse {
    return GenerateDepositAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateDepositAddressResponse>): GenerateDepositAddressResponse {
    const message = createBaseGenerateDepositAddressResponse();
    message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
      ? Address.fromPartial(object.depositAddress)
      : undefined;
    return message;
  },
};

function createBaseUTXO(): UTXO {
  return { txid: "", vout: 0, rawTx: new Uint8Array(0) };
}

export const UTXO: MessageFns<UTXO> = {
  encode(message: UTXO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid !== "") {
      writer.uint32(10).string(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(26).bytes(message.rawTx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UTXO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXO {
    return {
      txid: isSet(object.txid) ? globalThis.String(object.txid) : "",
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
    };
  },

  toJSON(message: UTXO): unknown {
    const obj: any = {};
    if (message.txid !== "") {
      obj.txid = message.txid;
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    return obj;
  },

  create(base?: DeepPartial<UTXO>): UTXO {
    return UTXO.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXO>): UTXO {
    const message = createBaseUTXO();
    message.txid = object.txid ?? "";
    message.vout = object.vout ?? 0;
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeOutput(): NodeOutput {
  return { nodeId: "", vout: 0 };
}

export const NodeOutput: MessageFns<NodeOutput> = {
  encode(message: NodeOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeOutput {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: NodeOutput): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeOutput>): NodeOutput {
    return NodeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeOutput>): NodeOutput {
    const message = createBaseNodeOutput();
    message.nodeId = object.nodeId ?? "";
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseSigningJob(): SigningJob {
  return { signingPublicKey: new Uint8Array(0), rawTx: new Uint8Array(0), signingNonceCommitment: undefined };
}

export const SigningJob: MessageFns<SigningJob> = {
  encode(message: SigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signingPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      writer.uint32(18).bytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(message.signingNonceCommitment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rawTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningJob {
    return {
      signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
      rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
    };
  },

  toJSON(message: SigningJob): unknown {
    const obj: any = {};
    if (message.signingPublicKey.length !== 0) {
      obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
    }
    if (message.rawTx.length !== 0) {
      obj.rawTx = base64FromBytes(message.rawTx);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(message.signingNonceCommitment);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningJob>): SigningJob {
    return SigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningJob>): SigningJob {
    const message = createBaseSigningJob();
    message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
    message.rawTx = object.rawTx ?? new Uint8Array(0);
    message.signingNonceCommitment =
      (object.signingNonceCommitment !== undefined && object.signingNonceCommitment !== null)
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    return message;
  },
};

function createBaseSigningKeyshare(): SigningKeyshare {
  return { ownerIdentifiers: [], threshold: 0 };
}

export const SigningKeyshare: MessageFns<SigningKeyshare> = {
  encode(message: SigningKeyshare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ownerIdentifiers) {
      writer.uint32(10).string(v!);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).uint32(message.threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningKeyshare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningKeyshare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerIdentifiers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningKeyshare {
    return {
      ownerIdentifiers: globalThis.Array.isArray(object?.ownerIdentifiers)
        ? object.ownerIdentifiers.map((e: any) => globalThis.String(e))
        : [],
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
    };
  },

  toJSON(message: SigningKeyshare): unknown {
    const obj: any = {};
    if (message.ownerIdentifiers?.length) {
      obj.ownerIdentifiers = message.ownerIdentifiers;
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningKeyshare>): SigningKeyshare {
    return SigningKeyshare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningKeyshare>): SigningKeyshare {
    const message = createBaseSigningKeyshare();
    message.ownerIdentifiers = object.ownerIdentifiers?.map((e) => e) || [];
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseSigningResult(): SigningResult {
  return { publicKeys: {}, signingNonceCommitments: {}, signatureShares: {}, signingKeyshare: undefined };
}

export const SigningResult: MessageFns<SigningResult> = {
  encode(message: SigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.publicKeys).forEach(([key, value]) => {
      SigningResult_PublicKeysEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      SigningResult_SigningNonceCommitmentsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.signatureShares).forEach(([key, value]) => {
      SigningResult_SignatureSharesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.signingKeyshare !== undefined) {
      SigningKeyshare.encode(message.signingKeyshare, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningResult_PublicKeysEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.publicKeys[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SigningResult_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.signingNonceCommitments[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SigningResult_SignatureSharesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.signatureShares[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingKeyshare = SigningKeyshare.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult {
    return {
      publicKeys: isObject(object.publicKeys)
        ? Object.entries(object.publicKeys).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      signatureShares: isObject(object.signatureShares)
        ? Object.entries(object.signatureShares).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      signingKeyshare: isSet(object.signingKeyshare) ? SigningKeyshare.fromJSON(object.signingKeyshare) : undefined,
    };
  },

  toJSON(message: SigningResult): unknown {
    const obj: any = {};
    if (message.publicKeys) {
      const entries = Object.entries(message.publicKeys);
      if (entries.length > 0) {
        obj.publicKeys = {};
        entries.forEach(([k, v]) => {
          obj.publicKeys[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    if (message.signatureShares) {
      const entries = Object.entries(message.signatureShares);
      if (entries.length > 0) {
        obj.signatureShares = {};
        entries.forEach(([k, v]) => {
          obj.signatureShares[k] = base64FromBytes(v);
        });
      }
    }
    if (message.signingKeyshare !== undefined) {
      obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult>): SigningResult {
    return SigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult>): SigningResult {
    const message = createBaseSigningResult();
    message.publicKeys = Object.entries(object.publicKeys ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    message.signatureShares = Object.entries(object.signatureShares ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.signingKeyshare = (object.signingKeyshare !== undefined && object.signingKeyshare !== null)
      ? SigningKeyshare.fromPartial(object.signingKeyshare)
      : undefined;
    return message;
  },
};

function createBaseSigningResult_PublicKeysEntry(): SigningResult_PublicKeysEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_PublicKeysEntry: MessageFns<SigningResult_PublicKeysEntry> = {
  encode(message: SigningResult_PublicKeysEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_PublicKeysEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_PublicKeysEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_PublicKeysEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningResult_PublicKeysEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_PublicKeysEntry>): SigningResult_PublicKeysEntry {
    return SigningResult_PublicKeysEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult_PublicKeysEntry>): SigningResult_PublicKeysEntry {
    const message = createBaseSigningResult_PublicKeysEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSigningResult_SigningNonceCommitmentsEntry(): SigningResult_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningResult_SigningNonceCommitmentsEntry: MessageFns<SigningResult_SigningNonceCommitmentsEntry> = {
  encode(message: SigningResult_SigningNonceCommitmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_SigningNonceCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_SigningNonceCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SigningResult_SigningNonceCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>): SigningResult_SigningNonceCommitmentsEntry {
    return SigningResult_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SigningResult_SigningNonceCommitmentsEntry>,
  ): SigningResult_SigningNonceCommitmentsEntry {
    const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSigningResult_SignatureSharesEntry(): SigningResult_SignatureSharesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SigningResult_SignatureSharesEntry: MessageFns<SigningResult_SignatureSharesEntry> = {
  encode(message: SigningResult_SignatureSharesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningResult_SignatureSharesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningResult_SignatureSharesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningResult_SignatureSharesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SigningResult_SignatureSharesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningResult_SignatureSharesEntry>): SigningResult_SignatureSharesEntry {
    return SigningResult_SignatureSharesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningResult_SignatureSharesEntry>): SigningResult_SignatureSharesEntry {
    const message = createBaseSigningResult_SignatureSharesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeSignatureShares(): NodeSignatureShares {
  return {
    nodeId: "",
    nodeTxSigningResult: undefined,
    refundTxSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
  };
}

export const NodeSignatureShares: MessageFns<NodeSignatureShares> = {
  encode(message: NodeSignatureShares, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(34).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatureShares {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatureShares();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatureShares {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatureShares): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    return NodeSignatureShares.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatureShares>): NodeSignatureShares {
    const message = createBaseNodeSignatureShares();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
      ? SigningResult.fromPartial(object.nodeTxSigningResult)
      : undefined;
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNodeSignatures(): NodeSignatures {
  return { nodeId: "", nodeTxSignature: new Uint8Array(0), refundTxSignature: new Uint8Array(0) };
}

export const NodeSignatures: MessageFns<NodeSignatures> = {
  encode(message: NodeSignatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSignature.length !== 0) {
      writer.uint32(18).bytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      writer.uint32(26).bytes(message.refundTxSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeSignatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeSignatures {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSignature: isSet(object.nodeTxSignature) ? bytesFromBase64(object.nodeTxSignature) : new Uint8Array(0),
      refundTxSignature: isSet(object.refundTxSignature)
        ? bytesFromBase64(object.refundTxSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: NodeSignatures): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSignature.length !== 0) {
      obj.nodeTxSignature = base64FromBytes(message.nodeTxSignature);
    }
    if (message.refundTxSignature.length !== 0) {
      obj.refundTxSignature = base64FromBytes(message.refundTxSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeSignatures>): NodeSignatures {
    return NodeSignatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeSignatures>): NodeSignatures {
    const message = createBaseNodeSignatures();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSignature = object.nodeTxSignature ?? new Uint8Array(0);
    message.refundTxSignature = object.refundTxSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartTreeCreationRequest(): StartTreeCreationRequest {
  return {
    identityPublicKey: new Uint8Array(0),
    onChainUtxo: undefined,
    rootTxSigningJob: undefined,
    refundTxSigningJob: undefined,
  };
}

export const StartTreeCreationRequest: MessageFns<StartTreeCreationRequest> = {
  encode(message: StartTreeCreationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.rootTxSigningJob !== undefined) {
      SigningJob.encode(message.rootTxSigningJob, writer.uint32(26).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTreeCreationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      rootTxSigningJob: isSet(object.rootTxSigningJob) ? SigningJob.fromJSON(object.rootTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
    };
  },

  toJSON(message: StartTreeCreationRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.rootTxSigningJob !== undefined) {
      obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTreeCreationRequest>): StartTreeCreationRequest {
    return StartTreeCreationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTreeCreationRequest>): StartTreeCreationRequest {
    const message = createBaseStartTreeCreationRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.rootTxSigningJob = (object.rootTxSigningJob !== undefined && object.rootTxSigningJob !== null)
      ? SigningJob.fromPartial(object.rootTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    return message;
  },
};

function createBaseStartTreeCreationResponse(): StartTreeCreationResponse {
  return { treeId: "", rootNodeSignatureShares: undefined };
}

export const StartTreeCreationResponse: MessageFns<StartTreeCreationResponse> = {
  encode(message: StartTreeCreationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treeId !== "") {
      writer.uint32(10).string(message.treeId);
    }
    if (message.rootNodeSignatureShares !== undefined) {
      NodeSignatureShares.encode(message.rootNodeSignatureShares, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTreeCreationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTreeCreationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rootNodeSignatureShares = NodeSignatureShares.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTreeCreationResponse {
    return {
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
        ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
        : undefined,
    };
  },

  toJSON(message: StartTreeCreationResponse): unknown {
    const obj: any = {};
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.rootNodeSignatureShares !== undefined) {
      obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(message.rootNodeSignatureShares);
    }
    return obj;
  },

  create(base?: DeepPartial<StartTreeCreationResponse>): StartTreeCreationResponse {
    return StartTreeCreationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTreeCreationResponse>): StartTreeCreationResponse {
    const message = createBaseStartTreeCreationResponse();
    message.treeId = object.treeId ?? "";
    message.rootNodeSignatureShares =
      (object.rootNodeSignatureShares !== undefined && object.rootNodeSignatureShares !== null)
        ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
        : undefined;
    return message;
  },
};

function createBaseTokenTransactionSigningJob(): TokenTransactionSigningJob {
  return { leafId: new Uint8Array(0), signingNonceCommitment: undefined, ownershipSignature: new Uint8Array(0) };
}

export const TokenTransactionSigningJob: MessageFns<TokenTransactionSigningJob> = {
  encode(message: TokenTransactionSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId.length !== 0) {
      writer.uint32(10).bytes(message.leafId);
    }
    if (message.signingNonceCommitment !== undefined) {
      SigningCommitment.encode(message.signingNonceCommitment, writer.uint32(18).fork()).join();
    }
    if (message.ownershipSignature.length !== 0) {
      writer.uint32(26).bytes(message.ownershipSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransactionSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransactionSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingNonceCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownershipSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransactionSigningJob {
    return {
      leafId: isSet(object.leafId) ? bytesFromBase64(object.leafId) : new Uint8Array(0),
      signingNonceCommitment: isSet(object.signingNonceCommitment)
        ? SigningCommitment.fromJSON(object.signingNonceCommitment)
        : undefined,
      ownershipSignature: isSet(object.ownershipSignature)
        ? bytesFromBase64(object.ownershipSignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TokenTransactionSigningJob): unknown {
    const obj: any = {};
    if (message.leafId.length !== 0) {
      obj.leafId = base64FromBytes(message.leafId);
    }
    if (message.signingNonceCommitment !== undefined) {
      obj.signingNonceCommitment = SigningCommitment.toJSON(message.signingNonceCommitment);
    }
    if (message.ownershipSignature.length !== 0) {
      obj.ownershipSignature = base64FromBytes(message.ownershipSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransactionSigningJob>): TokenTransactionSigningJob {
    return TokenTransactionSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransactionSigningJob>): TokenTransactionSigningJob {
    const message = createBaseTokenTransactionSigningJob();
    message.leafId = object.leafId ?? new Uint8Array(0);
    message.signingNonceCommitment =
      (object.signingNonceCommitment !== undefined && object.signingNonceCommitment !== null)
        ? SigningCommitment.fromPartial(object.signingNonceCommitment)
        : undefined;
    message.ownershipSignature = object.ownershipSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransactionSignatureShares(): TokenTransactionSignatureShares {
  return {
    tokenTransactionHash: new Uint8Array(0),
    tokenTransactionSigningResult: undefined,
    verifyingKey: new Uint8Array(0),
  };
}

export const TokenTransactionSignatureShares: MessageFns<TokenTransactionSignatureShares> = {
  encode(message: TokenTransactionSignatureShares, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.tokenTransactionHash);
    }
    if (message.tokenTransactionSigningResult !== undefined) {
      SigningResult.encode(message.tokenTransactionSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransactionSignatureShares {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransactionSignatureShares();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenTransactionSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransactionSignatureShares {
    return {
      tokenTransactionHash: isSet(object.tokenTransactionHash)
        ? bytesFromBase64(object.tokenTransactionHash)
        : new Uint8Array(0),
      tokenTransactionSigningResult: isSet(object.tokenTransactionSigningResult)
        ? SigningResult.fromJSON(object.tokenTransactionSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: TokenTransactionSignatureShares): unknown {
    const obj: any = {};
    if (message.tokenTransactionHash.length !== 0) {
      obj.tokenTransactionHash = base64FromBytes(message.tokenTransactionHash);
    }
    if (message.tokenTransactionSigningResult !== undefined) {
      obj.tokenTransactionSigningResult = SigningResult.toJSON(message.tokenTransactionSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransactionSignatureShares>): TokenTransactionSignatureShares {
    return TokenTransactionSignatureShares.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransactionSignatureShares>): TokenTransactionSignatureShares {
    const message = createBaseTokenTransactionSignatureShares();
    message.tokenTransactionHash = object.tokenTransactionHash ?? new Uint8Array(0);
    message.tokenTransactionSigningResult =
      (object.tokenTransactionSigningResult !== undefined && object.tokenTransactionSigningResult !== null)
        ? SigningResult.fromPartial(object.tokenTransactionSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenLeafToSpend(): TokenLeafToSpend {
  return { tokenTransactionHash: new Uint8Array(0), tokenLeafIndex: 0, revocationPrivateKey: new Uint8Array(0) };
}

export const TokenLeafToSpend: MessageFns<TokenLeafToSpend> = {
  encode(message: TokenLeafToSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.tokenTransactionHash);
    }
    if (message.tokenLeafIndex !== 0) {
      writer.uint32(16).uint32(message.tokenLeafIndex);
    }
    if (message.revocationPrivateKey.length !== 0) {
      writer.uint32(26).bytes(message.revocationPrivateKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenLeafToSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenLeafToSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tokenLeafIndex = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revocationPrivateKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenLeafToSpend {
    return {
      tokenTransactionHash: isSet(object.tokenTransactionHash)
        ? bytesFromBase64(object.tokenTransactionHash)
        : new Uint8Array(0),
      tokenLeafIndex: isSet(object.tokenLeafIndex) ? globalThis.Number(object.tokenLeafIndex) : 0,
      revocationPrivateKey: isSet(object.revocationPrivateKey)
        ? bytesFromBase64(object.revocationPrivateKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: TokenLeafToSpend): unknown {
    const obj: any = {};
    if (message.tokenTransactionHash.length !== 0) {
      obj.tokenTransactionHash = base64FromBytes(message.tokenTransactionHash);
    }
    if (message.tokenLeafIndex !== 0) {
      obj.tokenLeafIndex = Math.round(message.tokenLeafIndex);
    }
    if (message.revocationPrivateKey.length !== 0) {
      obj.revocationPrivateKey = base64FromBytes(message.revocationPrivateKey);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenLeafToSpend>): TokenLeafToSpend {
    return TokenLeafToSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenLeafToSpend>): TokenLeafToSpend {
    const message = createBaseTokenLeafToSpend();
    message.tokenTransactionHash = object.tokenTransactionHash ?? new Uint8Array(0);
    message.tokenLeafIndex = object.tokenLeafIndex ?? 0;
    message.revocationPrivateKey = object.revocationPrivateKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenLeafToCreate(): TokenLeafToCreate {
  return {
    id: "",
    verifyingKey: new Uint8Array(0),
    ownerIdentityPublicKey: new Uint8Array(0),
    revocationPublicKey: new Uint8Array(0),
    withdrawalBondSats: 0,
    withdrawalLocktime: 0,
    tokenPublicKey: new Uint8Array(0),
    tokenAmount: new Uint8Array(0),
  };
}

export const TokenLeafToCreate: MessageFns<TokenLeafToCreate> = {
  encode(message: TokenLeafToCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.ownerIdentityPublicKey);
    }
    if (message.revocationPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.revocationPublicKey);
    }
    if (message.withdrawalBondSats !== 0) {
      writer.uint32(40).uint64(message.withdrawalBondSats);
    }
    if (message.withdrawalLocktime !== 0) {
      writer.uint32(48).uint64(message.withdrawalLocktime);
    }
    if (message.tokenPublicKey.length !== 0) {
      writer.uint32(58).bytes(message.tokenPublicKey);
    }
    if (message.tokenAmount.length !== 0) {
      writer.uint32(66).bytes(message.tokenAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenLeafToCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenLeafToCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revocationPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawalBondSats = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.withdrawalLocktime = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenPublicKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tokenAmount = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenLeafToCreate {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      revocationPublicKey: isSet(object.revocationPublicKey)
        ? bytesFromBase64(object.revocationPublicKey)
        : new Uint8Array(0),
      withdrawalBondSats: isSet(object.withdrawalBondSats) ? globalThis.Number(object.withdrawalBondSats) : 0,
      withdrawalLocktime: isSet(object.withdrawalLocktime) ? globalThis.Number(object.withdrawalLocktime) : 0,
      tokenPublicKey: isSet(object.tokenPublicKey) ? bytesFromBase64(object.tokenPublicKey) : new Uint8Array(0),
      tokenAmount: isSet(object.tokenAmount) ? bytesFromBase64(object.tokenAmount) : new Uint8Array(0),
    };
  },

  toJSON(message: TokenLeafToCreate): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.revocationPublicKey.length !== 0) {
      obj.revocationPublicKey = base64FromBytes(message.revocationPublicKey);
    }
    if (message.withdrawalBondSats !== 0) {
      obj.withdrawalBondSats = Math.round(message.withdrawalBondSats);
    }
    if (message.withdrawalLocktime !== 0) {
      obj.withdrawalLocktime = Math.round(message.withdrawalLocktime);
    }
    if (message.tokenPublicKey.length !== 0) {
      obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
    }
    if (message.tokenAmount.length !== 0) {
      obj.tokenAmount = base64FromBytes(message.tokenAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<TokenLeafToCreate>): TokenLeafToCreate {
    return TokenLeafToCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenLeafToCreate>): TokenLeafToCreate {
    const message = createBaseTokenLeafToCreate();
    message.id = object.id ?? "";
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.revocationPublicKey = object.revocationPublicKey ?? new Uint8Array(0);
    message.withdrawalBondSats = object.withdrawalBondSats ?? 0;
    message.withdrawalLocktime = object.withdrawalLocktime ?? 0;
    message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
    message.tokenAmount = object.tokenAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTokenTransaction(): TokenTransaction {
  return { leavesToSpend: [], leavesToCreate: [] };
}

export const TokenTransaction: MessageFns<TokenTransaction> = {
  encode(message: TokenTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leavesToSpend) {
      TokenLeafToSpend.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.leavesToCreate) {
      TokenLeafToCreate.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leavesToSpend.push(TokenLeafToSpend.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.leavesToCreate.push(TokenLeafToCreate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenTransaction {
    return {
      leavesToSpend: globalThis.Array.isArray(object?.leavesToSpend)
        ? object.leavesToSpend.map((e: any) => TokenLeafToSpend.fromJSON(e))
        : [],
      leavesToCreate: globalThis.Array.isArray(object?.leavesToCreate)
        ? object.leavesToCreate.map((e: any) => TokenLeafToCreate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenTransaction): unknown {
    const obj: any = {};
    if (message.leavesToSpend?.length) {
      obj.leavesToSpend = message.leavesToSpend.map((e) => TokenLeafToSpend.toJSON(e));
    }
    if (message.leavesToCreate?.length) {
      obj.leavesToCreate = message.leavesToCreate.map((e) => TokenLeafToCreate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TokenTransaction>): TokenTransaction {
    return TokenTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenTransaction>): TokenTransaction {
    const message = createBaseTokenTransaction();
    message.leavesToSpend = object.leavesToSpend?.map((e) => TokenLeafToSpend.fromPartial(e)) || [];
    message.leavesToCreate = object.leavesToCreate?.map((e) => TokenLeafToCreate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateRevocationPublicKeyResponse(): GenerateRevocationPublicKeyResponse {
  return { revocationPublicKey: new Uint8Array(0) };
}

export const GenerateRevocationPublicKeyResponse: MessageFns<GenerateRevocationPublicKeyResponse> = {
  encode(message: GenerateRevocationPublicKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revocationPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.revocationPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRevocationPublicKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRevocationPublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.revocationPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRevocationPublicKeyResponse {
    return {
      revocationPublicKey: isSet(object.revocationPublicKey)
        ? bytesFromBase64(object.revocationPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: GenerateRevocationPublicKeyResponse): unknown {
    const obj: any = {};
    if (message.revocationPublicKey.length !== 0) {
      obj.revocationPublicKey = base64FromBytes(message.revocationPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateRevocationPublicKeyResponse>): GenerateRevocationPublicKeyResponse {
    return GenerateRevocationPublicKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateRevocationPublicKeyResponse>): GenerateRevocationPublicKeyResponse {
    const message = createBaseGenerateRevocationPublicKeyResponse();
    message.revocationPublicKey = object.revocationPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartTokenTransactionRequest(): StartTokenTransactionRequest {
  return { identityPublicKey: new Uint8Array(0), partialTokenTransaction: undefined, signingJobs: [] };
}

export const StartTokenTransactionRequest: MessageFns<StartTokenTransactionRequest> = {
  encode(message: StartTokenTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.identityPublicKey);
    }
    if (message.partialTokenTransaction !== undefined) {
      TokenTransaction.encode(message.partialTokenTransaction, writer.uint32(18).fork()).join();
    }
    for (const v of message.signingJobs) {
      TokenTransactionSigningJob.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTokenTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTokenTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partialTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingJobs.push(TokenTransactionSigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTokenTransactionRequest {
    return {
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      partialTokenTransaction: isSet(object.partialTokenTransaction)
        ? TokenTransaction.fromJSON(object.partialTokenTransaction)
        : undefined,
      signingJobs: globalThis.Array.isArray(object?.signingJobs)
        ? object.signingJobs.map((e: any) => TokenTransactionSigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartTokenTransactionRequest): unknown {
    const obj: any = {};
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.partialTokenTransaction !== undefined) {
      obj.partialTokenTransaction = TokenTransaction.toJSON(message.partialTokenTransaction);
    }
    if (message.signingJobs?.length) {
      obj.signingJobs = message.signingJobs.map((e) => TokenTransactionSigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StartTokenTransactionRequest>): StartTokenTransactionRequest {
    return StartTokenTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTokenTransactionRequest>): StartTokenTransactionRequest {
    const message = createBaseStartTokenTransactionRequest();
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.partialTokenTransaction =
      (object.partialTokenTransaction !== undefined && object.partialTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.partialTokenTransaction)
        : undefined;
    message.signingJobs = object.signingJobs?.map((e) => TokenTransactionSigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartTokenTransactionResponse(): StartTokenTransactionResponse {
  return { finalizedTokenTransaction: undefined, signatureShares: [] };
}

export const StartTokenTransactionResponse: MessageFns<StartTokenTransactionResponse> = {
  encode(message: StartTokenTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalizedTokenTransaction !== undefined) {
      TokenTransaction.encode(message.finalizedTokenTransaction, writer.uint32(10).fork()).join();
    }
    for (const v of message.signatureShares) {
      TokenTransactionSignatureShares.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTokenTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTokenTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.finalizedTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signatureShares.push(TokenTransactionSignatureShares.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartTokenTransactionResponse {
    return {
      finalizedTokenTransaction: isSet(object.finalizedTokenTransaction)
        ? TokenTransaction.fromJSON(object.finalizedTokenTransaction)
        : undefined,
      signatureShares: globalThis.Array.isArray(object?.signatureShares)
        ? object.signatureShares.map((e: any) => TokenTransactionSignatureShares.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartTokenTransactionResponse): unknown {
    const obj: any = {};
    if (message.finalizedTokenTransaction !== undefined) {
      obj.finalizedTokenTransaction = TokenTransaction.toJSON(message.finalizedTokenTransaction);
    }
    if (message.signatureShares?.length) {
      obj.signatureShares = message.signatureShares.map((e) => TokenTransactionSignatureShares.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StartTokenTransactionResponse>): StartTokenTransactionResponse {
    return StartTokenTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTokenTransactionResponse>): StartTokenTransactionResponse {
    const message = createBaseStartTokenTransactionResponse();
    message.finalizedTokenTransaction =
      (object.finalizedTokenTransaction !== undefined && object.finalizedTokenTransaction !== null)
        ? TokenTransaction.fromPartial(object.finalizedTokenTransaction)
        : undefined;
    message.signatureShares = object.signatureShares?.map((e) => TokenTransactionSignatureShares.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizeTokenTransactionRequest(): FinalizeTokenTransactionRequest {
  return { tokenTransactionHash: new Uint8Array(0), signatures: [] };
}

export const FinalizeTokenTransactionRequest: MessageFns<FinalizeTokenTransactionRequest> = {
  encode(message: FinalizeTokenTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenTransactionHash.length !== 0) {
      writer.uint32(10).bytes(message.tokenTransactionHash);
    }
    for (const v of message.signatures) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeTokenTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeTokenTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenTransactionHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signatures.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeTokenTransactionRequest {
    return {
      tokenTransactionHash: isSet(object.tokenTransactionHash)
        ? bytesFromBase64(object.tokenTransactionHash)
        : new Uint8Array(0),
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: FinalizeTokenTransactionRequest): unknown {
    const obj: any = {};
    if (message.tokenTransactionHash.length !== 0) {
      obj.tokenTransactionHash = base64FromBytes(message.tokenTransactionHash);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeTokenTransactionRequest>): FinalizeTokenTransactionRequest {
    return FinalizeTokenTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeTokenTransactionRequest>): FinalizeTokenTransactionRequest {
    const message = createBaseFinalizeTokenTransactionRequest();
    message.tokenTransactionHash = object.tokenTransactionHash ?? new Uint8Array(0);
    message.signatures = object.signatures?.map((e) => e) || [];
    return message;
  },
};

function createBaseTreeNode(): TreeNode {
  return {
    id: "",
    treeId: "",
    value: 0,
    parentNodeId: undefined,
    nodeTx: new Uint8Array(0),
    refundTx: new Uint8Array(0),
    vout: 0,
    verifyingPublicKey: new Uint8Array(0),
    ownerIdentityPublicKey: new Uint8Array(0),
    refundTimelock: 0,
  };
}

export const TreeNode: MessageFns<TreeNode> = {
  encode(message: TreeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.treeId !== "") {
      writer.uint32(18).string(message.treeId);
    }
    if (message.value !== 0) {
      writer.uint32(24).uint64(message.value);
    }
    if (message.parentNodeId !== undefined) {
      writer.uint32(34).string(message.parentNodeId);
    }
    if (message.nodeTx.length !== 0) {
      writer.uint32(42).bytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(50).bytes(message.refundTx);
    }
    if (message.vout !== 0) {
      writer.uint32(56).uint32(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(74).bytes(message.ownerIdentityPublicKey);
    }
    if (message.refundTimelock !== 0) {
      writer.uint32(80).uint32(message.refundTimelock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.treeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentNodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nodeTx = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.verifyingPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.refundTimelock = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      parentNodeId: isSet(object.parentNodeId) ? globalThis.String(object.parentNodeId) : undefined,
      nodeTx: isSet(object.nodeTx) ? bytesFromBase64(object.nodeTx) : new Uint8Array(0),
      refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      verifyingPublicKey: isSet(object.verifyingPublicKey)
        ? bytesFromBase64(object.verifyingPublicKey)
        : new Uint8Array(0),
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      refundTimelock: isSet(object.refundTimelock) ? globalThis.Number(object.refundTimelock) : 0,
    };
  },

  toJSON(message: TreeNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.treeId !== "") {
      obj.treeId = message.treeId;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.parentNodeId !== undefined) {
      obj.parentNodeId = message.parentNodeId;
    }
    if (message.nodeTx.length !== 0) {
      obj.nodeTx = base64FromBytes(message.nodeTx);
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.verifyingPublicKey.length !== 0) {
      obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.refundTimelock !== 0) {
      obj.refundTimelock = Math.round(message.refundTimelock);
    }
    return obj;
  },

  create(base?: DeepPartial<TreeNode>): TreeNode {
    return TreeNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TreeNode>): TreeNode {
    const message = createBaseTreeNode();
    message.id = object.id ?? "";
    message.treeId = object.treeId ?? "";
    message.value = object.value ?? 0;
    message.parentNodeId = object.parentNodeId ?? undefined;
    message.nodeTx = object.nodeTx ?? new Uint8Array(0);
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.refundTimelock = object.refundTimelock ?? 0;
    return message;
  },
};

function createBaseFinalizeNodeSignaturesRequest(): FinalizeNodeSignaturesRequest {
  return { intent: 0, nodeSignatures: [] };
}

export const FinalizeNodeSignaturesRequest: MessageFns<FinalizeNodeSignaturesRequest> = {
  encode(message: FinalizeNodeSignaturesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== 0) {
      writer.uint32(8).int32(message.intent);
    }
    for (const v of message.nodeSignatures) {
      NodeSignatures.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeNodeSignaturesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeNodeSignaturesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.intent = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeSignatures.push(NodeSignatures.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeNodeSignaturesRequest {
    return {
      intent: isSet(object.intent) ? signatureIntentFromJSON(object.intent) : 0,
      nodeSignatures: globalThis.Array.isArray(object?.nodeSignatures)
        ? object.nodeSignatures.map((e: any) => NodeSignatures.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinalizeNodeSignaturesRequest): unknown {
    const obj: any = {};
    if (message.intent !== 0) {
      obj.intent = signatureIntentToJSON(message.intent);
    }
    if (message.nodeSignatures?.length) {
      obj.nodeSignatures = message.nodeSignatures.map((e) => NodeSignatures.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeNodeSignaturesRequest>): FinalizeNodeSignaturesRequest {
    return FinalizeNodeSignaturesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeNodeSignaturesRequest>): FinalizeNodeSignaturesRequest {
    const message = createBaseFinalizeNodeSignaturesRequest();
    message.intent = object.intent ?? 0;
    message.nodeSignatures = object.nodeSignatures?.map((e) => NodeSignatures.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalizeNodeSignaturesResponse(): FinalizeNodeSignaturesResponse {
  return { nodes: [] };
}

export const FinalizeNodeSignaturesResponse: MessageFns<FinalizeNodeSignaturesResponse> = {
  encode(message: FinalizeNodeSignaturesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      TreeNode.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeNodeSignaturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeNodeSignaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(TreeNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeNodeSignaturesResponse {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => TreeNode.fromJSON(e)) : [] };
  },

  toJSON(message: FinalizeNodeSignaturesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => TreeNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeNodeSignaturesResponse>): FinalizeNodeSignaturesResponse {
    return FinalizeNodeSignaturesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeNodeSignaturesResponse>): FinalizeNodeSignaturesResponse {
    const message = createBaseFinalizeNodeSignaturesResponse();
    message.nodes = object.nodes?.map((e) => TreeNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSecretShare(): SecretShare {
  return { secretShare: new Uint8Array(0), proofs: [] };
}

export const SecretShare: MessageFns<SecretShare> = {
  encode(message: SecretShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretShare.length !== 0) {
      writer.uint32(10).bytes(message.secretShare);
    }
    for (const v of message.proofs) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecretShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secretShare = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proofs.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretShare {
    return {
      secretShare: isSet(object.secretShare) ? bytesFromBase64(object.secretShare) : new Uint8Array(0),
      proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: SecretShare): unknown {
    const obj: any = {};
    if (message.secretShare.length !== 0) {
      obj.secretShare = base64FromBytes(message.secretShare);
    }
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SecretShare>): SecretShare {
    return SecretShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretShare>): SecretShare {
    const message = createBaseSecretShare();
    message.secretShare = object.secretShare ?? new Uint8Array(0);
    message.proofs = object.proofs?.map((e) => e) || [];
    return message;
  },
};

function createBaseLeafRefundTxSigningJob(): LeafRefundTxSigningJob {
  return { leafId: "", refundTxSigningJob: undefined };
}

export const LeafRefundTxSigningJob: MessageFns<LeafRefundTxSigningJob> = {
  encode(message: LeafRefundTxSigningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeafRefundTxSigningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafRefundTxSigningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafRefundTxSigningJob {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
    };
  },

  toJSON(message: LeafRefundTxSigningJob): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    return obj;
  },

  create(base?: DeepPartial<LeafRefundTxSigningJob>): LeafRefundTxSigningJob {
    return LeafRefundTxSigningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeafRefundTxSigningJob>): LeafRefundTxSigningJob {
    const message = createBaseLeafRefundTxSigningJob();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    return message;
  },
};

function createBaseLeafRefundTxSigningResult(): LeafRefundTxSigningResult {
  return { leafId: "", refundTxSigningResult: undefined, verifyingKey: new Uint8Array(0) };
}

export const LeafRefundTxSigningResult: MessageFns<LeafRefundTxSigningResult> = {
  encode(message: LeafRefundTxSigningResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(26).bytes(message.verifyingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeafRefundTxSigningResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafRefundTxSigningResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafRefundTxSigningResult {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
    };
  },

  toJSON(message: LeafRefundTxSigningResult): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    return obj;
  },

  create(base?: DeepPartial<LeafRefundTxSigningResult>): LeafRefundTxSigningResult {
    return LeafRefundTxSigningResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeafRefundTxSigningResult>): LeafRefundTxSigningResult {
    const message = createBaseLeafRefundTxSigningResult();
    message.leafId = object.leafId ?? "";
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartSendTransferRequest(): StartSendTransferRequest {
  return {
    transferId: "",
    ownerIdentityPublicKey: new Uint8Array(0),
    leavesToSend: [],
    receiverIdentityPublicKey: new Uint8Array(0),
    expiryTime: undefined,
  };
}

export const StartSendTransferRequest: MessageFns<StartSendTransferRequest> = {
  encode(message: StartSendTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      LeafRefundTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSendTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartSendTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(LeafRefundTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartSendTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => LeafRefundTxSigningJob.fromJSON(e))
        : [],
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
    };
  },

  toJSON(message: StartSendTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => LeafRefundTxSigningJob.toJSON(e));
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<StartSendTransferRequest>): StartSendTransferRequest {
    return StartSendTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartSendTransferRequest>): StartSendTransferRequest {
    const message = createBaseStartSendTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend = object.leavesToSend?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) || [];
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.expiryTime = object.expiryTime ?? undefined;
    return message;
  },
};

function createBaseStartSendTransferResponse(): StartSendTransferResponse {
  return { transfer: undefined, signingResults: [] };
}

export const StartSendTransferResponse: MessageFns<StartSendTransferResponse> = {
  encode(message: StartSendTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSendTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartSendTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartSendTransferResponse {
    return {
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StartSendTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StartSendTransferResponse>): StartSendTransferResponse {
    return StartSendTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartSendTransferResponse>): StartSendTransferResponse {
    const message = createBaseStartSendTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendLeafKeyTweak(): SendLeafKeyTweak {
  return {
    leafId: "",
    secretShareTweak: undefined,
    pubkeySharesTweak: {},
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
    refundSignature: new Uint8Array(0),
  };
}

export const SendLeafKeyTweak: MessageFns<SendLeafKeyTweak> = {
  encode(message: SendLeafKeyTweak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      SendLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.secretCipher.length !== 0) {
      writer.uint32(34).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(42).bytes(message.signature);
    }
    if (message.refundSignature.length !== 0) {
      writer.uint32(50).bytes(message.refundSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = SendLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refundSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      refundSignature: isSet(object.refundSignature) ? bytesFromBase64(object.refundSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.refundSignature.length !== 0) {
      obj.refundSignature = base64FromBytes(message.refundSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    return SendLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak>): SendLeafKeyTweak {
    const message = createBaseSendLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
      ? SecretShare.fromPartial(object.secretShareTweak)
      : undefined;
    message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.refundSignature = object.refundSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendLeafKeyTweak_PubkeySharesTweakEntry(): SendLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const SendLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<SendLeafKeyTweak_PubkeySharesTweakEntry> = {
  encode(message: SendLeafKeyTweak_PubkeySharesTweakEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendLeafKeyTweak_PubkeySharesTweakEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendLeafKeyTweak_PubkeySharesTweakEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: SendLeafKeyTweak_PubkeySharesTweakEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>): SendLeafKeyTweak_PubkeySharesTweakEntry {
    return SendLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendLeafKeyTweak_PubkeySharesTweakEntry>): SendLeafKeyTweak_PubkeySharesTweakEntry {
    const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCompleteSendTransferRequest(): CompleteSendTransferRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToSend: [] };
}

export const CompleteSendTransferRequest: MessageFns<CompleteSendTransferRequest> = {
  encode(message: CompleteSendTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToSend) {
      SendLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteSendTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteSendTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToSend.push(SendLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteSendTransferRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
        ? object.leavesToSend.map((e: any) => SendLeafKeyTweak.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CompleteSendTransferRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToSend?.length) {
      obj.leavesToSend = message.leavesToSend.map((e) => SendLeafKeyTweak.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteSendTransferRequest>): CompleteSendTransferRequest {
    return CompleteSendTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteSendTransferRequest>): CompleteSendTransferRequest {
    const message = createBaseCompleteSendTransferRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToSend = object.leavesToSend?.map((e) => SendLeafKeyTweak.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransfer(): Transfer {
  return {
    id: "",
    senderIdentityPublicKey: new Uint8Array(0),
    receiverIdentityPublicKey: new Uint8Array(0),
    status: 0,
    totalValue: 0,
    expiryTime: undefined,
    leaves: [],
  };
}

export const Transfer: MessageFns<Transfer> = {
  encode(message: Transfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.totalValue !== 0) {
      writer.uint32(40).uint64(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.leaves) {
      TransferLeaf.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.senderIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalValue = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.leaves.push(TransferLeaf.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transfer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
        ? bytesFromBase64(object.senderIdentityPublicKey)
        : new Uint8Array(0),
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
      status: isSet(object.status) ? transferStatusFromJSON(object.status) : 0,
      totalValue: isSet(object.totalValue) ? globalThis.Number(object.totalValue) : 0,
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e: any) => TransferLeaf.fromJSON(e)) : [],
    };
  },

  toJSON(message: Transfer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.senderIdentityPublicKey.length !== 0) {
      obj.senderIdentityPublicKey = base64FromBytes(message.senderIdentityPublicKey);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    if (message.status !== 0) {
      obj.status = transferStatusToJSON(message.status);
    }
    if (message.totalValue !== 0) {
      obj.totalValue = Math.round(message.totalValue);
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.leaves?.length) {
      obj.leaves = message.leaves.map((e) => TransferLeaf.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Transfer>): Transfer {
    return Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transfer>): Transfer {
    const message = createBaseTransfer();
    message.id = object.id ?? "";
    message.senderIdentityPublicKey = object.senderIdentityPublicKey ?? new Uint8Array(0);
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.totalValue = object.totalValue ?? 0;
    message.expiryTime = object.expiryTime ?? undefined;
    message.leaves = object.leaves?.map((e) => TransferLeaf.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransferLeaf(): TransferLeaf {
  return {
    leaf: undefined,
    secretCipher: new Uint8Array(0),
    signature: new Uint8Array(0),
    intermediateRefundTx: new Uint8Array(0),
    signingKeyshare: undefined,
  };
}

export const TransferLeaf: MessageFns<TransferLeaf> = {
  encode(message: TransferLeaf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaf !== undefined) {
      TreeNode.encode(message.leaf, writer.uint32(10).fork()).join();
    }
    if (message.secretCipher.length !== 0) {
      writer.uint32(18).bytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.intermediateRefundTx.length !== 0) {
      writer.uint32(34).bytes(message.intermediateRefundTx);
    }
    if (message.signingKeyshare !== undefined) {
      SigningKeyshare.encode(message.signingKeyshare, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferLeaf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferLeaf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaf = TreeNode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretCipher = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.intermediateRefundTx = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signingKeyshare = SigningKeyshare.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferLeaf {
    return {
      leaf: isSet(object.leaf) ? TreeNode.fromJSON(object.leaf) : undefined,
      secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      intermediateRefundTx: isSet(object.intermediateRefundTx)
        ? bytesFromBase64(object.intermediateRefundTx)
        : new Uint8Array(0),
      signingKeyshare: isSet(object.signingKeyshare) ? SigningKeyshare.fromJSON(object.signingKeyshare) : undefined,
    };
  },

  toJSON(message: TransferLeaf): unknown {
    const obj: any = {};
    if (message.leaf !== undefined) {
      obj.leaf = TreeNode.toJSON(message.leaf);
    }
    if (message.secretCipher.length !== 0) {
      obj.secretCipher = base64FromBytes(message.secretCipher);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.intermediateRefundTx.length !== 0) {
      obj.intermediateRefundTx = base64FromBytes(message.intermediateRefundTx);
    }
    if (message.signingKeyshare !== undefined) {
      obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferLeaf>): TransferLeaf {
    return TransferLeaf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferLeaf>): TransferLeaf {
    const message = createBaseTransferLeaf();
    message.leaf = (object.leaf !== undefined && object.leaf !== null) ? TreeNode.fromPartial(object.leaf) : undefined;
    message.secretCipher = object.secretCipher ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.intermediateRefundTx = object.intermediateRefundTx ?? new Uint8Array(0);
    message.signingKeyshare = (object.signingKeyshare !== undefined && object.signingKeyshare !== null)
      ? SigningKeyshare.fromPartial(object.signingKeyshare)
      : undefined;
    return message;
  },
};

function createBaseCompleteSendTransferResponse(): CompleteSendTransferResponse {
  return { transfer: undefined };
}

export const CompleteSendTransferResponse: MessageFns<CompleteSendTransferResponse> = {
  encode(message: CompleteSendTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteSendTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteSendTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteSendTransferResponse {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: CompleteSendTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteSendTransferResponse>): CompleteSendTransferResponse {
    return CompleteSendTransferResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteSendTransferResponse>): CompleteSendTransferResponse {
    const message = createBaseCompleteSendTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseQueryPendingTransfersRequest(): QueryPendingTransfersRequest {
  return { receiverIdentityPublicKey: new Uint8Array(0) };
}

export const QueryPendingTransfersRequest: MessageFns<QueryPendingTransfersRequest> = {
  encode(message: QueryPendingTransfersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.receiverIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingTransfersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingTransfersRequest {
    return {
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: QueryPendingTransfersRequest): unknown {
    const obj: any = {};
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPendingTransfersRequest>): QueryPendingTransfersRequest {
    return QueryPendingTransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPendingTransfersRequest>): QueryPendingTransfersRequest {
    const message = createBaseQueryPendingTransfersRequest();
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryPendingTransfersResponse(): QueryPendingTransfersResponse {
  return { transfers: [] };
}

export const QueryPendingTransfersResponse: MessageFns<QueryPendingTransfersResponse> = {
  encode(message: QueryPendingTransfersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transfers) {
      Transfer.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingTransfersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingTransfersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfers.push(Transfer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingTransfersResponse {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => Transfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryPendingTransfersResponse): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => Transfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPendingTransfersResponse>): QueryPendingTransfersResponse {
    return QueryPendingTransfersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPendingTransfersResponse>): QueryPendingTransfersResponse {
    const message = createBaseQueryPendingTransfersResponse();
    message.transfers = object.transfers?.map((e) => Transfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimLeafKeyTweak(): ClaimLeafKeyTweak {
  return { leafId: "", secretShareTweak: undefined, pubkeySharesTweak: {} };
}

export const ClaimLeafKeyTweak: MessageFns<ClaimLeafKeyTweak> = {
  encode(message: ClaimLeafKeyTweak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leafId !== "") {
      writer.uint32(10).string(message.leafId);
    }
    if (message.secretShareTweak !== undefined) {
      SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
    }
    Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
      ClaimLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leafId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClaimLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pubkeySharesTweak[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak {
    return {
      leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
      secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
      pubkeySharesTweak: isObject(object.pubkeySharesTweak)
        ? Object.entries(object.pubkeySharesTweak).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ClaimLeafKeyTweak): unknown {
    const obj: any = {};
    if (message.leafId !== "") {
      obj.leafId = message.leafId;
    }
    if (message.secretShareTweak !== undefined) {
      obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
    }
    if (message.pubkeySharesTweak) {
      const entries = Object.entries(message.pubkeySharesTweak);
      if (entries.length > 0) {
        obj.pubkeySharesTweak = {};
        entries.forEach(([k, v]) => {
          obj.pubkeySharesTweak[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    return ClaimLeafKeyTweak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak>): ClaimLeafKeyTweak {
    const message = createBaseClaimLeafKeyTweak();
    message.leafId = object.leafId ?? "";
    message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
      ? SecretShare.fromPartial(object.secretShareTweak)
      : undefined;
    message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry(): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const ClaimLeafKeyTweak_PubkeySharesTweakEntry: MessageFns<ClaimLeafKeyTweak_PubkeySharesTweakEntry> = {
  encode(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimLeafKeyTweak_PubkeySharesTweakEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    return ClaimLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimLeafKeyTweak_PubkeySharesTweakEntry>): ClaimLeafKeyTweak_PubkeySharesTweakEntry {
    const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTransferTweakKeysRequest(): ClaimTransferTweakKeysRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToReceive: [] };
}

export const ClaimTransferTweakKeysRequest: MessageFns<ClaimTransferTweakKeysRequest> = {
  encode(message: ClaimTransferTweakKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.leavesToReceive) {
      ClaimLeafKeyTweak.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferTweakKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferTweakKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leavesToReceive.push(ClaimLeafKeyTweak.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferTweakKeysRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      leavesToReceive: globalThis.Array.isArray(object?.leavesToReceive)
        ? object.leavesToReceive.map((e: any) => ClaimLeafKeyTweak.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferTweakKeysRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.leavesToReceive?.length) {
      obj.leavesToReceive = message.leavesToReceive.map((e) => ClaimLeafKeyTweak.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferTweakKeysRequest>): ClaimTransferTweakKeysRequest {
    return ClaimTransferTweakKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferTweakKeysRequest>): ClaimTransferTweakKeysRequest {
    const message = createBaseClaimTransferTweakKeysRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.leavesToReceive = object.leavesToReceive?.map((e) => ClaimLeafKeyTweak.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimTransferSignRefundsRequest(): ClaimTransferSignRefundsRequest {
  return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: [] };
}

export const ClaimTransferSignRefundsRequest: MessageFns<ClaimTransferSignRefundsRequest> = {
  encode(message: ClaimTransferSignRefundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(18).bytes(message.ownerIdentityPublicKey);
    }
    for (const v of message.signingJobs) {
      LeafRefundTxSigningJob.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferSignRefundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferSignRefundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signingJobs.push(LeafRefundTxSigningJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferSignRefundsRequest {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
      signingJobs: globalThis.Array.isArray(object?.signingJobs)
        ? object.signingJobs.map((e: any) => LeafRefundTxSigningJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferSignRefundsRequest): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    if (message.signingJobs?.length) {
      obj.signingJobs = message.signingJobs.map((e) => LeafRefundTxSigningJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferSignRefundsRequest>): ClaimTransferSignRefundsRequest {
    return ClaimTransferSignRefundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferSignRefundsRequest>): ClaimTransferSignRefundsRequest {
    const message = createBaseClaimTransferSignRefundsRequest();
    message.transferId = object.transferId ?? "";
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    message.signingJobs = object.signingJobs?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimTransferSignRefundsResponse(): ClaimTransferSignRefundsResponse {
  return { signingResults: [] };
}

export const ClaimTransferSignRefundsResponse: MessageFns<ClaimTransferSignRefundsResponse> = {
  encode(message: ClaimTransferSignRefundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimTransferSignRefundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTransferSignRefundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTransferSignRefundsResponse {
    return {
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClaimTransferSignRefundsResponse): unknown {
    const obj: any = {};
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTransferSignRefundsResponse>): ClaimTransferSignRefundsResponse {
    return ClaimTransferSignRefundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTransferSignRefundsResponse>): ClaimTransferSignRefundsResponse {
    const message = createBaseClaimTransferSignRefundsResponse();
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAggregateNodesRequest(): AggregateNodesRequest {
  return { nodeIds: [], signingJob: undefined, ownerIdentityPublicKey: new Uint8Array(0) };
}

export const AggregateNodesRequest: MessageFns<AggregateNodesRequest> = {
  encode(message: AggregateNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    if (message.signingJob !== undefined) {
      SigningJob.encode(message.signingJob, writer.uint32(18).fork()).join();
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.ownerIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateNodesRequest {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
      signingJob: isSet(object.signingJob) ? SigningJob.fromJSON(object.signingJob) : undefined,
      ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
        ? bytesFromBase64(object.ownerIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AggregateNodesRequest): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    if (message.signingJob !== undefined) {
      obj.signingJob = SigningJob.toJSON(message.signingJob);
    }
    if (message.ownerIdentityPublicKey.length !== 0) {
      obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateNodesRequest>): AggregateNodesRequest {
    return AggregateNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateNodesRequest>): AggregateNodesRequest {
    const message = createBaseAggregateNodesRequest();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    message.signingJob = (object.signingJob !== undefined && object.signingJob !== null)
      ? SigningJob.fromPartial(object.signingJob)
      : undefined;
    message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAggregateNodesResponse(): AggregateNodesResponse {
  return {
    aggregateSignature: undefined,
    verifyingKey: new Uint8Array(0),
    parentNodeTx: new Uint8Array(0),
    parentNodeVout: 0,
  };
}

export const AggregateNodesResponse: MessageFns<AggregateNodesResponse> = {
  encode(message: AggregateNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregateSignature !== undefined) {
      SigningResult.encode(message.aggregateSignature, writer.uint32(10).fork()).join();
    }
    if (message.verifyingKey.length !== 0) {
      writer.uint32(18).bytes(message.verifyingKey);
    }
    if (message.parentNodeTx.length !== 0) {
      writer.uint32(26).bytes(message.parentNodeTx);
    }
    if (message.parentNodeVout !== 0) {
      writer.uint32(32).uint32(message.parentNodeVout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.aggregateSignature = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.verifyingKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parentNodeTx = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.parentNodeVout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateNodesResponse {
    return {
      aggregateSignature: isSet(object.aggregateSignature)
        ? SigningResult.fromJSON(object.aggregateSignature)
        : undefined,
      verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
      parentNodeTx: isSet(object.parentNodeTx) ? bytesFromBase64(object.parentNodeTx) : new Uint8Array(0),
      parentNodeVout: isSet(object.parentNodeVout) ? globalThis.Number(object.parentNodeVout) : 0,
    };
  },

  toJSON(message: AggregateNodesResponse): unknown {
    const obj: any = {};
    if (message.aggregateSignature !== undefined) {
      obj.aggregateSignature = SigningResult.toJSON(message.aggregateSignature);
    }
    if (message.verifyingKey.length !== 0) {
      obj.verifyingKey = base64FromBytes(message.verifyingKey);
    }
    if (message.parentNodeTx.length !== 0) {
      obj.parentNodeTx = base64FromBytes(message.parentNodeTx);
    }
    if (message.parentNodeVout !== 0) {
      obj.parentNodeVout = Math.round(message.parentNodeVout);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateNodesResponse>): AggregateNodesResponse {
    return AggregateNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateNodesResponse>): AggregateNodesResponse {
    const message = createBaseAggregateNodesResponse();
    message.aggregateSignature = (object.aggregateSignature !== undefined && object.aggregateSignature !== null)
      ? SigningResult.fromPartial(object.aggregateSignature)
      : undefined;
    message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
    message.parentNodeTx = object.parentNodeTx ?? new Uint8Array(0);
    message.parentNodeVout = object.parentNodeVout ?? 0;
    return message;
  },
};

function createBaseStorePreimageShareRequest(): StorePreimageShareRequest {
  return {
    paymentHash: new Uint8Array(0),
    preimageShare: undefined,
    threshold: 0,
    invoiceString: "",
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const StorePreimageShareRequest: MessageFns<StorePreimageShareRequest> = {
  encode(message: StorePreimageShareRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.preimageShare !== undefined) {
      SecretShare.encode(message.preimageShare, writer.uint32(18).fork()).join();
    }
    if (message.threshold !== 0) {
      writer.uint32(24).uint32(message.threshold);
    }
    if (message.invoiceString !== "") {
      writer.uint32(34).string(message.invoiceString);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(42).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorePreimageShareRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorePreimageShareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimageShare = SecretShare.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.threshold = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.invoiceString = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorePreimageShareRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      preimageShare: isSet(object.preimageShare) ? SecretShare.fromJSON(object.preimageShare) : undefined,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      invoiceString: isSet(object.invoiceString) ? globalThis.String(object.invoiceString) : "",
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: StorePreimageShareRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.preimageShare !== undefined) {
      obj.preimageShare = SecretShare.toJSON(message.preimageShare);
    }
    if (message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    if (message.invoiceString !== "") {
      obj.invoiceString = message.invoiceString;
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<StorePreimageShareRequest>): StorePreimageShareRequest {
    return StorePreimageShareRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorePreimageShareRequest>): StorePreimageShareRequest {
    const message = createBaseStorePreimageShareRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.preimageShare = (object.preimageShare !== undefined && object.preimageShare !== null)
      ? SecretShare.fromPartial(object.preimageShare)
      : undefined;
    message.threshold = object.threshold ?? 0;
    message.invoiceString = object.invoiceString ?? "";
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestedSigningCommitments(): RequestedSigningCommitments {
  return { signingNonceCommitments: {} };
}

export const RequestedSigningCommitments: MessageFns<RequestedSigningCommitments> = {
  encode(message: RequestedSigningCommitments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
      RequestedSigningCommitments_SigningNonceCommitmentsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestedSigningCommitments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestedSigningCommitments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = RequestedSigningCommitments_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingNonceCommitments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestedSigningCommitments {
    return {
      signingNonceCommitments: isObject(object.signingNonceCommitments)
        ? Object.entries(object.signingNonceCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: RequestedSigningCommitments): unknown {
    const obj: any = {};
    if (message.signingNonceCommitments) {
      const entries = Object.entries(message.signingNonceCommitments);
      if (entries.length > 0) {
        obj.signingNonceCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RequestedSigningCommitments>): RequestedSigningCommitments {
    return RequestedSigningCommitments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestedSigningCommitments>): RequestedSigningCommitments {
    const message = createBaseRequestedSigningCommitments();
    message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry(): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
  return { key: "", value: undefined };
}

export const RequestedSigningCommitments_SigningNonceCommitmentsEntry: MessageFns<
  RequestedSigningCommitments_SigningNonceCommitmentsEntry
> = {
  encode(
    message: RequestedSigningCommitments_SigningNonceCommitmentsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RequestedSigningCommitments_SigningNonceCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
  ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    return RequestedSigningCommitments_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RequestedSigningCommitments_SigningNonceCommitmentsEntry>,
  ): RequestedSigningCommitments_SigningNonceCommitmentsEntry {
    const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetSigningCommitmentsRequest(): GetSigningCommitmentsRequest {
  return { nodeIds: [] };
}

export const GetSigningCommitmentsRequest: MessageFns<GetSigningCommitmentsRequest> = {
  encode(message: GetSigningCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningCommitmentsRequest {
    return {
      nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetSigningCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.nodeIds?.length) {
      obj.nodeIds = message.nodeIds;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningCommitmentsRequest>): GetSigningCommitmentsRequest {
    return GetSigningCommitmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningCommitmentsRequest>): GetSigningCommitmentsRequest {
    const message = createBaseGetSigningCommitmentsRequest();
    message.nodeIds = object.nodeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSigningCommitmentsResponse(): GetSigningCommitmentsResponse {
  return { signingCommitments: [] };
}

export const GetSigningCommitmentsResponse: MessageFns<GetSigningCommitmentsResponse> = {
  encode(message: GetSigningCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signingCommitments) {
      RequestedSigningCommitments.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signingCommitments.push(RequestedSigningCommitments.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningCommitmentsResponse {
    return {
      signingCommitments: globalThis.Array.isArray(object?.signingCommitments)
        ? object.signingCommitments.map((e: any) => RequestedSigningCommitments.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSigningCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.signingCommitments?.length) {
      obj.signingCommitments = message.signingCommitments.map((e) => RequestedSigningCommitments.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningCommitmentsResponse>): GetSigningCommitmentsResponse {
    return GetSigningCommitmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningCommitmentsResponse>): GetSigningCommitmentsResponse {
    const message = createBaseGetSigningCommitmentsResponse();
    message.signingCommitments = object.signingCommitments?.map((e) => RequestedSigningCommitments.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseSigningCommitments(): SigningCommitments {
  return { signingCommitments: {} };
}

export const SigningCommitments: MessageFns<SigningCommitments> = {
  encode(message: SigningCommitments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingCommitments).forEach(([key, value]) => {
      SigningCommitments_SigningCommitmentsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningCommitments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningCommitments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SigningCommitments_SigningCommitmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingCommitments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningCommitments {
    return {
      signingCommitments: isObject(object.signingCommitments)
        ? Object.entries(object.signingCommitments).reduce<{ [key: string]: SigningCommitment }>(
          (acc, [key, value]) => {
            acc[key] = SigningCommitment.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SigningCommitments): unknown {
    const obj: any = {};
    if (message.signingCommitments) {
      const entries = Object.entries(message.signingCommitments);
      if (entries.length > 0) {
        obj.signingCommitments = {};
        entries.forEach(([k, v]) => {
          obj.signingCommitments[k] = SigningCommitment.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SigningCommitments>): SigningCommitments {
    return SigningCommitments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningCommitments>): SigningCommitments {
    const message = createBaseSigningCommitments();
    message.signingCommitments = Object.entries(object.signingCommitments ?? {}).reduce<
      { [key: string]: SigningCommitment }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningCommitment.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSigningCommitments_SigningCommitmentsEntry(): SigningCommitments_SigningCommitmentsEntry {
  return { key: "", value: undefined };
}

export const SigningCommitments_SigningCommitmentsEntry: MessageFns<SigningCommitments_SigningCommitmentsEntry> = {
  encode(message: SigningCommitments_SigningCommitmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningCommitments_SigningCommitmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningCommitments_SigningCommitmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningCommitments_SigningCommitmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SigningCommitments_SigningCommitmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningCommitment.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SigningCommitments_SigningCommitmentsEntry>): SigningCommitments_SigningCommitmentsEntry {
    return SigningCommitments_SigningCommitmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SigningCommitments_SigningCommitmentsEntry>,
  ): SigningCommitments_SigningCommitmentsEntry {
    const message = createBaseSigningCommitments_SigningCommitmentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningCommitment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUserSignedRefund(): UserSignedRefund {
  return {
    nodeId: "",
    refundTx: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    signingCommitments: undefined,
    userSignatureCommitment: undefined,
  };
}

export const UserSignedRefund: MessageFns<UserSignedRefund> = {
  encode(message: UserSignedRefund, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.refundTx.length !== 0) {
      writer.uint32(18).bytes(message.refundTx);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(26).bytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      SigningCommitments.encode(message.signingCommitments, writer.uint32(34).fork()).join();
    }
    if (message.userSignatureCommitment !== undefined) {
      SigningCommitment.encode(message.userSignatureCommitment, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSignedRefund {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignedRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTx = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signingCommitments = SigningCommitments.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userSignatureCommitment = SigningCommitment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignedRefund {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
      userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
      signingCommitments: isSet(object.signingCommitments)
        ? SigningCommitments.fromJSON(object.signingCommitments)
        : undefined,
      userSignatureCommitment: isSet(object.userSignatureCommitment)
        ? SigningCommitment.fromJSON(object.userSignatureCommitment)
        : undefined,
    };
  },

  toJSON(message: UserSignedRefund): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.refundTx.length !== 0) {
      obj.refundTx = base64FromBytes(message.refundTx);
    }
    if (message.userSignature.length !== 0) {
      obj.userSignature = base64FromBytes(message.userSignature);
    }
    if (message.signingCommitments !== undefined) {
      obj.signingCommitments = SigningCommitments.toJSON(message.signingCommitments);
    }
    if (message.userSignatureCommitment !== undefined) {
      obj.userSignatureCommitment = SigningCommitment.toJSON(message.userSignatureCommitment);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignedRefund>): UserSignedRefund {
    return UserSignedRefund.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSignedRefund>): UserSignedRefund {
    const message = createBaseUserSignedRefund();
    message.nodeId = object.nodeId ?? "";
    message.refundTx = object.refundTx ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.signingCommitments = (object.signingCommitments !== undefined && object.signingCommitments !== null)
      ? SigningCommitments.fromPartial(object.signingCommitments)
      : undefined;
    message.userSignatureCommitment =
      (object.userSignatureCommitment !== undefined && object.userSignatureCommitment !== null)
        ? SigningCommitment.fromPartial(object.userSignatureCommitment)
        : undefined;
    return message;
  },
};

function createBaseInvoiceAmountProof(): InvoiceAmountProof {
  return { bolt11Invoice: "" };
}

export const InvoiceAmountProof: MessageFns<InvoiceAmountProof> = {
  encode(message: InvoiceAmountProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bolt11Invoice !== "") {
      writer.uint32(10).string(message.bolt11Invoice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceAmountProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceAmountProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bolt11Invoice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceAmountProof {
    return { bolt11Invoice: isSet(object.bolt11Invoice) ? globalThis.String(object.bolt11Invoice) : "" };
  },

  toJSON(message: InvoiceAmountProof): unknown {
    const obj: any = {};
    if (message.bolt11Invoice !== "") {
      obj.bolt11Invoice = message.bolt11Invoice;
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceAmountProof>): InvoiceAmountProof {
    return InvoiceAmountProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceAmountProof>): InvoiceAmountProof {
    const message = createBaseInvoiceAmountProof();
    message.bolt11Invoice = object.bolt11Invoice ?? "";
    return message;
  },
};

function createBaseInvoiceAmount(): InvoiceAmount {
  return { valueSats: 0, invoiceAmountProof: undefined };
}

export const InvoiceAmount: MessageFns<InvoiceAmount> = {
  encode(message: InvoiceAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valueSats !== 0) {
      writer.uint32(8).uint64(message.valueSats);
    }
    if (message.invoiceAmountProof !== undefined) {
      InvoiceAmountProof.encode(message.invoiceAmountProof, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valueSats = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoiceAmountProof = InvoiceAmountProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceAmount {
    return {
      valueSats: isSet(object.valueSats) ? globalThis.Number(object.valueSats) : 0,
      invoiceAmountProof: isSet(object.invoiceAmountProof)
        ? InvoiceAmountProof.fromJSON(object.invoiceAmountProof)
        : undefined,
    };
  },

  toJSON(message: InvoiceAmount): unknown {
    const obj: any = {};
    if (message.valueSats !== 0) {
      obj.valueSats = Math.round(message.valueSats);
    }
    if (message.invoiceAmountProof !== undefined) {
      obj.invoiceAmountProof = InvoiceAmountProof.toJSON(message.invoiceAmountProof);
    }
    return obj;
  },

  create(base?: DeepPartial<InvoiceAmount>): InvoiceAmount {
    return InvoiceAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvoiceAmount>): InvoiceAmount {
    const message = createBaseInvoiceAmount();
    message.valueSats = object.valueSats ?? 0;
    message.invoiceAmountProof = (object.invoiceAmountProof !== undefined && object.invoiceAmountProof !== null)
      ? InvoiceAmountProof.fromPartial(object.invoiceAmountProof)
      : undefined;
    return message;
  },
};

function createBaseInitiatePreimageSwapRequest(): InitiatePreimageSwapRequest {
  return {
    paymentHash: new Uint8Array(0),
    userSignedRefunds: [],
    invoiceAmount: undefined,
    reason: 0,
    transfer: undefined,
    receiverIdentityPublicKey: new Uint8Array(0),
  };
}

export const InitiatePreimageSwapRequest: MessageFns<InitiatePreimageSwapRequest> = {
  encode(message: InitiatePreimageSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    for (const v of message.userSignedRefunds) {
      UserSignedRefund.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.invoiceAmount !== undefined) {
      InvoiceAmount.encode(message.invoiceAmount, writer.uint32(26).fork()).join();
    }
    if (message.reason !== 0) {
      writer.uint32(32).int32(message.reason);
    }
    if (message.transfer !== undefined) {
      StartSendTransferRequest.encode(message.transfer, writer.uint32(42).fork()).join();
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      writer.uint32(50).bytes(message.receiverIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePreimageSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePreimageSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userSignedRefunds.push(UserSignedRefund.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invoiceAmount = InvoiceAmount.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transfer = StartSendTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.receiverIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePreimageSwapRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      userSignedRefunds: globalThis.Array.isArray(object?.userSignedRefunds)
        ? object.userSignedRefunds.map((e: any) => UserSignedRefund.fromJSON(e))
        : [],
      invoiceAmount: isSet(object.invoiceAmount) ? InvoiceAmount.fromJSON(object.invoiceAmount) : undefined,
      reason: isSet(object.reason) ? initiatePreimageSwapRequest_ReasonFromJSON(object.reason) : 0,
      transfer: isSet(object.transfer) ? StartSendTransferRequest.fromJSON(object.transfer) : undefined,
      receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
        ? bytesFromBase64(object.receiverIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: InitiatePreimageSwapRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.userSignedRefunds?.length) {
      obj.userSignedRefunds = message.userSignedRefunds.map((e) => UserSignedRefund.toJSON(e));
    }
    if (message.invoiceAmount !== undefined) {
      obj.invoiceAmount = InvoiceAmount.toJSON(message.invoiceAmount);
    }
    if (message.reason !== 0) {
      obj.reason = initiatePreimageSwapRequest_ReasonToJSON(message.reason);
    }
    if (message.transfer !== undefined) {
      obj.transfer = StartSendTransferRequest.toJSON(message.transfer);
    }
    if (message.receiverIdentityPublicKey.length !== 0) {
      obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiatePreimageSwapRequest>): InitiatePreimageSwapRequest {
    return InitiatePreimageSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiatePreimageSwapRequest>): InitiatePreimageSwapRequest {
    const message = createBaseInitiatePreimageSwapRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.userSignedRefunds = object.userSignedRefunds?.map((e) => UserSignedRefund.fromPartial(e)) || [];
    message.invoiceAmount = (object.invoiceAmount !== undefined && object.invoiceAmount !== null)
      ? InvoiceAmount.fromPartial(object.invoiceAmount)
      : undefined;
    message.reason = object.reason ?? 0;
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartSendTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInitiatePreimageSwapResponse(): InitiatePreimageSwapResponse {
  return { preimage: new Uint8Array(0), transfer: undefined };
}

export const InitiatePreimageSwapResponse: MessageFns<InitiatePreimageSwapResponse> = {
  encode(message: InitiatePreimageSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preimage.length !== 0) {
      writer.uint32(10).bytes(message.preimage);
    }
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePreimageSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePreimageSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preimage = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePreimageSwapResponse {
    return {
      preimage: isSet(object.preimage) ? bytesFromBase64(object.preimage) : new Uint8Array(0),
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
    };
  },

  toJSON(message: InitiatePreimageSwapResponse): unknown {
    const obj: any = {};
    if (message.preimage.length !== 0) {
      obj.preimage = base64FromBytes(message.preimage);
    }
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiatePreimageSwapResponse>): InitiatePreimageSwapResponse {
    return InitiatePreimageSwapResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiatePreimageSwapResponse>): InitiatePreimageSwapResponse {
    const message = createBaseInitiatePreimageSwapResponse();
    message.preimage = object.preimage ?? new Uint8Array(0);
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseOutPoint(): OutPoint {
  return { txid: new Uint8Array(0), vout: 0 };
}

export const OutPoint: MessageFns<OutPoint> = {
  encode(message: OutPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutPoint {
    return {
      txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
    };
  },

  toJSON(message: OutPoint): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    return obj;
  },

  create(base?: DeepPartial<OutPoint>): OutPoint {
    return OutPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutPoint>): OutPoint {
    const message = createBaseOutPoint();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    return message;
  },
};

function createBaseCooperativeExitRequest(): CooperativeExitRequest {
  return { transfer: undefined, exitId: "", exitTxid: new Uint8Array(0) };
}

export const CooperativeExitRequest: MessageFns<CooperativeExitRequest> = {
  encode(message: CooperativeExitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      StartSendTransferRequest.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    if (message.exitId !== "") {
      writer.uint32(18).string(message.exitId);
    }
    if (message.exitTxid.length !== 0) {
      writer.uint32(26).bytes(message.exitTxid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CooperativeExitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooperativeExitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = StartSendTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exitTxid = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooperativeExitRequest {
    return {
      transfer: isSet(object.transfer) ? StartSendTransferRequest.fromJSON(object.transfer) : undefined,
      exitId: isSet(object.exitId) ? globalThis.String(object.exitId) : "",
      exitTxid: isSet(object.exitTxid) ? bytesFromBase64(object.exitTxid) : new Uint8Array(0),
    };
  },

  toJSON(message: CooperativeExitRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = StartSendTransferRequest.toJSON(message.transfer);
    }
    if (message.exitId !== "") {
      obj.exitId = message.exitId;
    }
    if (message.exitTxid.length !== 0) {
      obj.exitTxid = base64FromBytes(message.exitTxid);
    }
    return obj;
  },

  create(base?: DeepPartial<CooperativeExitRequest>): CooperativeExitRequest {
    return CooperativeExitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CooperativeExitRequest>): CooperativeExitRequest {
    const message = createBaseCooperativeExitRequest();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartSendTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.exitId = object.exitId ?? "";
    message.exitTxid = object.exitTxid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCooperativeExitResponse(): CooperativeExitResponse {
  return { transfer: undefined, signingResults: [] };
}

export const CooperativeExitResponse: MessageFns<CooperativeExitResponse> = {
  encode(message: CooperativeExitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CooperativeExitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCooperativeExitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CooperativeExitResponse {
    return {
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CooperativeExitResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CooperativeExitResponse>): CooperativeExitResponse {
    return CooperativeExitResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CooperativeExitResponse>): CooperativeExitResponse {
    const message = createBaseCooperativeExitResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLeafSwapRequest(): LeafSwapRequest {
  return { transfer: undefined, swapId: "", adaptorPublicKey: new Uint8Array(0) };
}

export const LeafSwapRequest: MessageFns<LeafSwapRequest> = {
  encode(message: LeafSwapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      StartSendTransferRequest.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    if (message.swapId !== "") {
      writer.uint32(18).string(message.swapId);
    }
    if (message.adaptorPublicKey.length !== 0) {
      writer.uint32(26).bytes(message.adaptorPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeafSwapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafSwapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = StartSendTransferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.swapId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.adaptorPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafSwapRequest {
    return {
      transfer: isSet(object.transfer) ? StartSendTransferRequest.fromJSON(object.transfer) : undefined,
      swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
      adaptorPublicKey: isSet(object.adaptorPublicKey) ? bytesFromBase64(object.adaptorPublicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: LeafSwapRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = StartSendTransferRequest.toJSON(message.transfer);
    }
    if (message.swapId !== "") {
      obj.swapId = message.swapId;
    }
    if (message.adaptorPublicKey.length !== 0) {
      obj.adaptorPublicKey = base64FromBytes(message.adaptorPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<LeafSwapRequest>): LeafSwapRequest {
    return LeafSwapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeafSwapRequest>): LeafSwapRequest {
    const message = createBaseLeafSwapRequest();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? StartSendTransferRequest.fromPartial(object.transfer)
      : undefined;
    message.swapId = object.swapId ?? "";
    message.adaptorPublicKey = object.adaptorPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLeafSwapResponse(): LeafSwapResponse {
  return { transfer: undefined, signingResults: [] };
}

export const LeafSwapResponse: MessageFns<LeafSwapResponse> = {
  encode(message: LeafSwapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    for (const v of message.signingResults) {
      LeafRefundTxSigningResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeafSwapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafSwapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeafSwapResponse {
    return {
      transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
      signingResults: globalThis.Array.isArray(object?.signingResults)
        ? object.signingResults.map((e: any) => LeafRefundTxSigningResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LeafSwapResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    if (message.signingResults?.length) {
      obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LeafSwapResponse>): LeafSwapResponse {
    return LeafSwapResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeafSwapResponse>): LeafSwapResponse {
    const message = createBaseLeafSwapResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddressRequestNode(): AddressRequestNode {
  return { userPublicKey: new Uint8Array(0), children: [] };
}

export const AddressRequestNode: MessageFns<AddressRequestNode> = {
  encode(message: AddressRequestNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userPublicKey.length !== 0) {
      writer.uint32(10).bytes(message.userPublicKey);
    }
    for (const v of message.children) {
      AddressRequestNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressRequestNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressRequestNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userPublicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(AddressRequestNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressRequestNode {
    return {
      userPublicKey: isSet(object.userPublicKey) ? bytesFromBase64(object.userPublicKey) : new Uint8Array(0),
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => AddressRequestNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressRequestNode): unknown {
    const obj: any = {};
    if (message.userPublicKey.length !== 0) {
      obj.userPublicKey = base64FromBytes(message.userPublicKey);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AddressRequestNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressRequestNode>): AddressRequestNode {
    return AddressRequestNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressRequestNode>): AddressRequestNode {
    const message = createBaseAddressRequestNode();
    message.userPublicKey = object.userPublicKey ?? new Uint8Array(0);
    message.children = object.children?.map((e) => AddressRequestNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareTreeAddressRequest(): PrepareTreeAddressRequest {
  return {
    parentNodeOutput: undefined,
    onChainUtxo: undefined,
    node: undefined,
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const PrepareTreeAddressRequest: MessageFns<PrepareTreeAddressRequest> = {
  encode(message: PrepareTreeAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentNodeOutput !== undefined) {
      NodeOutput.encode(message.parentNodeOutput, writer.uint32(10).fork()).join();
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.node !== undefined) {
      AddressRequestNode.encode(message.node, writer.uint32(26).fork()).join();
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareTreeAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTreeAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentNodeOutput = NodeOutput.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = AddressRequestNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareTreeAddressRequest {
    return {
      parentNodeOutput: isSet(object.parentNodeOutput) ? NodeOutput.fromJSON(object.parentNodeOutput) : undefined,
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      node: isSet(object.node) ? AddressRequestNode.fromJSON(object.node) : undefined,
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PrepareTreeAddressRequest): unknown {
    const obj: any = {};
    if (message.parentNodeOutput !== undefined) {
      obj.parentNodeOutput = NodeOutput.toJSON(message.parentNodeOutput);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.node !== undefined) {
      obj.node = AddressRequestNode.toJSON(message.node);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareTreeAddressRequest>): PrepareTreeAddressRequest {
    return PrepareTreeAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrepareTreeAddressRequest>): PrepareTreeAddressRequest {
    const message = createBasePrepareTreeAddressRequest();
    message.parentNodeOutput = (object.parentNodeOutput !== undefined && object.parentNodeOutput !== null)
      ? NodeOutput.fromPartial(object.parentNodeOutput)
      : undefined;
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.node = (object.node !== undefined && object.node !== null)
      ? AddressRequestNode.fromPartial(object.node)
      : undefined;
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAddressNode(): AddressNode {
  return { address: undefined, children: [] };
}

export const AddressNode: MessageFns<AddressNode> = {
  encode(message: AddressNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    for (const v of message.children) {
      AddressNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(AddressNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressNode {
    return {
      address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => AddressNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressNode): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => AddressNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressNode>): AddressNode {
    return AddressNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressNode>): AddressNode {
    const message = createBaseAddressNode();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    message.children = object.children?.map((e) => AddressNode.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrepareTreeAddressResponse(): PrepareTreeAddressResponse {
  return { node: undefined };
}

export const PrepareTreeAddressResponse: MessageFns<PrepareTreeAddressResponse> = {
  encode(message: PrepareTreeAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      AddressNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareTreeAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareTreeAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = AddressNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareTreeAddressResponse {
    return { node: isSet(object.node) ? AddressNode.fromJSON(object.node) : undefined };
  },

  toJSON(message: PrepareTreeAddressResponse): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = AddressNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<PrepareTreeAddressResponse>): PrepareTreeAddressResponse {
    return PrepareTreeAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrepareTreeAddressResponse>): PrepareTreeAddressResponse {
    const message = createBasePrepareTreeAddressResponse();
    message.node = (object.node !== undefined && object.node !== null)
      ? AddressNode.fromPartial(object.node)
      : undefined;
    return message;
  },
};

function createBaseCreationNode(): CreationNode {
  return { nodeTxSigningJob: undefined, refundTxSigningJob: undefined, children: [] };
}

export const CreationNode: MessageFns<CreationNode> = {
  encode(message: CreationNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeTxSigningJob !== undefined) {
      SigningJob.encode(message.nodeTxSigningJob, writer.uint32(10).fork()).join();
    }
    if (message.refundTxSigningJob !== undefined) {
      SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
    }
    for (const v of message.children) {
      CreationNode.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreationNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(CreationNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationNode {
    return {
      nodeTxSigningJob: isSet(object.nodeTxSigningJob) ? SigningJob.fromJSON(object.nodeTxSigningJob) : undefined,
      refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => CreationNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreationNode): unknown {
    const obj: any = {};
    if (message.nodeTxSigningJob !== undefined) {
      obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
    }
    if (message.refundTxSigningJob !== undefined) {
      obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => CreationNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreationNode>): CreationNode {
    return CreationNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationNode>): CreationNode {
    const message = createBaseCreationNode();
    message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
      ? SigningJob.fromPartial(object.nodeTxSigningJob)
      : undefined;
    message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
      ? SigningJob.fromPartial(object.refundTxSigningJob)
      : undefined;
    message.children = object.children?.map((e) => CreationNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTreeRequest(): CreateTreeRequest {
  return {
    parentNodeOutput: undefined,
    onChainUtxo: undefined,
    node: undefined,
    userIdentityPublicKey: new Uint8Array(0),
  };
}

export const CreateTreeRequest: MessageFns<CreateTreeRequest> = {
  encode(message: CreateTreeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentNodeOutput !== undefined) {
      NodeOutput.encode(message.parentNodeOutput, writer.uint32(10).fork()).join();
    }
    if (message.onChainUtxo !== undefined) {
      UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
    }
    if (message.node !== undefined) {
      CreationNode.encode(message.node, writer.uint32(26).fork()).join();
    }
    if (message.userIdentityPublicKey.length !== 0) {
      writer.uint32(34).bytes(message.userIdentityPublicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTreeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTreeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parentNodeOutput = NodeOutput.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.onChainUtxo = UTXO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = CreationNode.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdentityPublicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTreeRequest {
    return {
      parentNodeOutput: isSet(object.parentNodeOutput) ? NodeOutput.fromJSON(object.parentNodeOutput) : undefined,
      onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
      node: isSet(object.node) ? CreationNode.fromJSON(object.node) : undefined,
      userIdentityPublicKey: isSet(object.userIdentityPublicKey)
        ? bytesFromBase64(object.userIdentityPublicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTreeRequest): unknown {
    const obj: any = {};
    if (message.parentNodeOutput !== undefined) {
      obj.parentNodeOutput = NodeOutput.toJSON(message.parentNodeOutput);
    }
    if (message.onChainUtxo !== undefined) {
      obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
    }
    if (message.node !== undefined) {
      obj.node = CreationNode.toJSON(message.node);
    }
    if (message.userIdentityPublicKey.length !== 0) {
      obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTreeRequest>): CreateTreeRequest {
    return CreateTreeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTreeRequest>): CreateTreeRequest {
    const message = createBaseCreateTreeRequest();
    message.parentNodeOutput = (object.parentNodeOutput !== undefined && object.parentNodeOutput !== null)
      ? NodeOutput.fromPartial(object.parentNodeOutput)
      : undefined;
    message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
      ? UTXO.fromPartial(object.onChainUtxo)
      : undefined;
    message.node = (object.node !== undefined && object.node !== null)
      ? CreationNode.fromPartial(object.node)
      : undefined;
    message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCreationResponseNode(): CreationResponseNode {
  return { nodeId: "", nodeTxSigningResult: undefined, refundTxSigningResult: undefined, children: [] };
}

export const CreationResponseNode: MessageFns<CreationResponseNode> = {
  encode(message: CreationResponseNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.nodeTxSigningResult !== undefined) {
      SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
    }
    if (message.refundTxSigningResult !== undefined) {
      SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
    }
    for (const v of message.children) {
      CreationResponseNode.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreationResponseNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreationResponseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.children.push(CreationResponseNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreationResponseNode {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      nodeTxSigningResult: isSet(object.nodeTxSigningResult)
        ? SigningResult.fromJSON(object.nodeTxSigningResult)
        : undefined,
      refundTxSigningResult: isSet(object.refundTxSigningResult)
        ? SigningResult.fromJSON(object.refundTxSigningResult)
        : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => CreationResponseNode.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreationResponseNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.nodeTxSigningResult !== undefined) {
      obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
    }
    if (message.refundTxSigningResult !== undefined) {
      obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => CreationResponseNode.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreationResponseNode>): CreationResponseNode {
    return CreationResponseNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreationResponseNode>): CreationResponseNode {
    const message = createBaseCreationResponseNode();
    message.nodeId = object.nodeId ?? "";
    message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
      ? SigningResult.fromPartial(object.nodeTxSigningResult)
      : undefined;
    message.refundTxSigningResult =
      (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
        ? SigningResult.fromPartial(object.refundTxSigningResult)
        : undefined;
    message.children = object.children?.map((e) => CreationResponseNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTreeResponse(): CreateTreeResponse {
  return { node: undefined };
}

export const CreateTreeResponse: MessageFns<CreateTreeResponse> = {
  encode(message: CreateTreeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      CreationResponseNode.encode(message.node, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTreeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = CreationResponseNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTreeResponse {
    return { node: isSet(object.node) ? CreationResponseNode.fromJSON(object.node) : undefined };
  },

  toJSON(message: CreateTreeResponse): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = CreationResponseNode.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTreeResponse>): CreateTreeResponse {
    return CreateTreeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTreeResponse>): CreateTreeResponse {
    const message = createBaseCreateTreeResponse();
    message.node = (object.node !== undefined && object.node !== null)
      ? CreationResponseNode.fromPartial(object.node)
      : undefined;
    return message;
  },
};

function createBaseSigningOperatorInfo(): SigningOperatorInfo {
  return { index: 0, identifier: "", publicKey: new Uint8Array(0), address: "" };
}

export const SigningOperatorInfo: MessageFns<SigningOperatorInfo> = {
  encode(message: SigningOperatorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).uint64(message.index);
    }
    if (message.identifier !== "") {
      writer.uint32(18).string(message.identifier);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SigningOperatorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigningOperatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigningOperatorInfo {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: SigningOperatorInfo): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<SigningOperatorInfo>): SigningOperatorInfo {
    return SigningOperatorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SigningOperatorInfo>): SigningOperatorInfo {
    const message = createBaseSigningOperatorInfo();
    message.index = object.index ?? 0;
    message.identifier = object.identifier ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetSigningOperatorListResponse(): GetSigningOperatorListResponse {
  return { signingOperators: {} };
}

export const GetSigningOperatorListResponse: MessageFns<GetSigningOperatorListResponse> = {
  encode(message: GetSigningOperatorListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.signingOperators).forEach(([key, value]) => {
      GetSigningOperatorListResponse_SigningOperatorsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningOperatorListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningOperatorListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetSigningOperatorListResponse_SigningOperatorsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.signingOperators[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningOperatorListResponse {
    return {
      signingOperators: isObject(object.signingOperators)
        ? Object.entries(object.signingOperators).reduce<{ [key: string]: SigningOperatorInfo }>(
          (acc, [key, value]) => {
            acc[key] = SigningOperatorInfo.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetSigningOperatorListResponse): unknown {
    const obj: any = {};
    if (message.signingOperators) {
      const entries = Object.entries(message.signingOperators);
      if (entries.length > 0) {
        obj.signingOperators = {};
        entries.forEach(([k, v]) => {
          obj.signingOperators[k] = SigningOperatorInfo.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetSigningOperatorListResponse>): GetSigningOperatorListResponse {
    return GetSigningOperatorListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSigningOperatorListResponse>): GetSigningOperatorListResponse {
    const message = createBaseGetSigningOperatorListResponse();
    message.signingOperators = Object.entries(object.signingOperators ?? {}).reduce<
      { [key: string]: SigningOperatorInfo }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SigningOperatorInfo.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetSigningOperatorListResponse_SigningOperatorsEntry(): GetSigningOperatorListResponse_SigningOperatorsEntry {
  return { key: "", value: undefined };
}

export const GetSigningOperatorListResponse_SigningOperatorsEntry: MessageFns<
  GetSigningOperatorListResponse_SigningOperatorsEntry
> = {
  encode(
    message: GetSigningOperatorListResponse_SigningOperatorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SigningOperatorInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSigningOperatorListResponse_SigningOperatorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SigningOperatorInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSigningOperatorListResponse_SigningOperatorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SigningOperatorInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetSigningOperatorListResponse_SigningOperatorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SigningOperatorInfo.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetSigningOperatorListResponse_SigningOperatorsEntry>,
  ): GetSigningOperatorListResponse_SigningOperatorsEntry {
    return GetSigningOperatorListResponse_SigningOperatorsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSigningOperatorListResponse_SigningOperatorsEntry>,
  ): GetSigningOperatorListResponse_SigningOperatorsEntry {
    const message = createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SigningOperatorInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQueryUserSignedRefundsRequest(): QueryUserSignedRefundsRequest {
  return { paymentHash: new Uint8Array(0) };
}

export const QueryUserSignedRefundsRequest: MessageFns<QueryUserSignedRefundsRequest> = {
  encode(message: QueryUserSignedRefundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserSignedRefundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserSignedRefundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserSignedRefundsRequest {
    return { paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0) };
  },

  toJSON(message: QueryUserSignedRefundsRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUserSignedRefundsRequest>): QueryUserSignedRefundsRequest {
    return QueryUserSignedRefundsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUserSignedRefundsRequest>): QueryUserSignedRefundsRequest {
    const message = createBaseQueryUserSignedRefundsRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryUserSignedRefundsResponse(): QueryUserSignedRefundsResponse {
  return { userSignedRefunds: [] };
}

export const QueryUserSignedRefundsResponse: MessageFns<QueryUserSignedRefundsResponse> = {
  encode(message: QueryUserSignedRefundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userSignedRefunds) {
      UserSignedRefund.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserSignedRefundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserSignedRefundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userSignedRefunds.push(UserSignedRefund.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserSignedRefundsResponse {
    return {
      userSignedRefunds: globalThis.Array.isArray(object?.userSignedRefunds)
        ? object.userSignedRefunds.map((e: any) => UserSignedRefund.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryUserSignedRefundsResponse): unknown {
    const obj: any = {};
    if (message.userSignedRefunds?.length) {
      obj.userSignedRefunds = message.userSignedRefunds.map((e) => UserSignedRefund.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryUserSignedRefundsResponse>): QueryUserSignedRefundsResponse {
    return QueryUserSignedRefundsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryUserSignedRefundsResponse>): QueryUserSignedRefundsResponse {
    const message = createBaseQueryUserSignedRefundsResponse();
    message.userSignedRefunds = object.userSignedRefunds?.map((e) => UserSignedRefund.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProvidePreimageRequest(): ProvidePreimageRequest {
  return { paymentHash: new Uint8Array(0), preimage: new Uint8Array(0) };
}

export const ProvidePreimageRequest: MessageFns<ProvidePreimageRequest> = {
  encode(message: ProvidePreimageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentHash.length !== 0) {
      writer.uint32(10).bytes(message.paymentHash);
    }
    if (message.preimage.length !== 0) {
      writer.uint32(18).bytes(message.preimage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvidePreimageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidePreimageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidePreimageRequest {
    return {
      paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
      preimage: isSet(object.preimage) ? bytesFromBase64(object.preimage) : new Uint8Array(0),
    };
  },

  toJSON(message: ProvidePreimageRequest): unknown {
    const obj: any = {};
    if (message.paymentHash.length !== 0) {
      obj.paymentHash = base64FromBytes(message.paymentHash);
    }
    if (message.preimage.length !== 0) {
      obj.preimage = base64FromBytes(message.preimage);
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidePreimageRequest>): ProvidePreimageRequest {
    return ProvidePreimageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvidePreimageRequest>): ProvidePreimageRequest {
    const message = createBaseProvidePreimageRequest();
    message.paymentHash = object.paymentHash ?? new Uint8Array(0);
    message.preimage = object.preimage ?? new Uint8Array(0);
    return message;
  },
};

function createBaseProvidePreimageResponse(): ProvidePreimageResponse {
  return { transfer: undefined };
}

export const ProvidePreimageResponse: MessageFns<ProvidePreimageResponse> = {
  encode(message: ProvidePreimageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvidePreimageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvidePreimageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = Transfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvidePreimageResponse {
    return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: ProvidePreimageResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = Transfer.toJSON(message.transfer);
    }
    return obj;
  },

  create(base?: DeepPartial<ProvidePreimageResponse>): ProvidePreimageResponse {
    return ProvidePreimageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvidePreimageResponse>): ProvidePreimageResponse {
    const message = createBaseProvidePreimageResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? Transfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

export type SparkServiceDefinition = typeof SparkServiceDefinition;
export const SparkServiceDefinition = {
  name: "SparkService",
  fullName: "spark.SparkService",
  methods: {
    generate_deposit_address: {
      name: "generate_deposit_address",
      requestType: GenerateDepositAddressRequest,
      requestStream: false,
      responseType: GenerateDepositAddressResponse,
      responseStream: false,
      options: {},
    },
    start_tree_creation: {
      name: "start_tree_creation",
      requestType: StartTreeCreationRequest,
      requestStream: false,
      responseType: StartTreeCreationResponse,
      responseStream: false,
      options: {},
    },
    finalize_node_signatures: {
      name: "finalize_node_signatures",
      requestType: FinalizeNodeSignaturesRequest,
      requestStream: false,
      responseType: FinalizeNodeSignaturesResponse,
      responseStream: false,
      options: {},
    },
    start_send_transfer: {
      name: "start_send_transfer",
      requestType: StartSendTransferRequest,
      requestStream: false,
      responseType: StartSendTransferResponse,
      responseStream: false,
      options: {},
    },
    complete_send_transfer: {
      name: "complete_send_transfer",
      requestType: CompleteSendTransferRequest,
      requestStream: false,
      responseType: CompleteSendTransferResponse,
      responseStream: false,
      options: {},
    },
    query_pending_transfers: {
      name: "query_pending_transfers",
      requestType: QueryPendingTransfersRequest,
      requestStream: false,
      responseType: QueryPendingTransfersResponse,
      responseStream: false,
      options: {},
    },
    claim_transfer_tweak_keys: {
      name: "claim_transfer_tweak_keys",
      requestType: ClaimTransferTweakKeysRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    claim_transfer_sign_refunds: {
      name: "claim_transfer_sign_refunds",
      requestType: ClaimTransferSignRefundsRequest,
      requestStream: false,
      responseType: ClaimTransferSignRefundsResponse,
      responseStream: false,
      options: {},
    },
    aggregate_nodes: {
      name: "aggregate_nodes",
      requestType: AggregateNodesRequest,
      requestStream: false,
      responseType: AggregateNodesResponse,
      responseStream: false,
      options: {},
    },
    store_preimage_share: {
      name: "store_preimage_share",
      requestType: StorePreimageShareRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    get_signing_commitments: {
      name: "get_signing_commitments",
      requestType: GetSigningCommitmentsRequest,
      requestStream: false,
      responseType: GetSigningCommitmentsResponse,
      responseStream: false,
      options: {},
    },
    cooperative_exit: {
      name: "cooperative_exit",
      requestType: CooperativeExitRequest,
      requestStream: false,
      responseType: CooperativeExitResponse,
      responseStream: false,
      options: {},
    },
    initiate_preimage_swap: {
      name: "initiate_preimage_swap",
      requestType: InitiatePreimageSwapRequest,
      requestStream: false,
      responseType: InitiatePreimageSwapResponse,
      responseStream: false,
      options: {},
    },
    provide_preimage: {
      name: "provide_preimage",
      requestType: ProvidePreimageRequest,
      requestStream: false,
      responseType: ProvidePreimageResponse,
      responseStream: false,
      options: {},
    },
    leaf_swap: {
      name: "leaf_swap",
      requestType: LeafSwapRequest,
      requestStream: false,
      responseType: LeafSwapResponse,
      responseStream: false,
      options: {},
    },
    prepare_tree_address: {
      name: "prepare_tree_address",
      requestType: PrepareTreeAddressRequest,
      requestStream: false,
      responseType: PrepareTreeAddressResponse,
      responseStream: false,
      options: {},
    },
    create_tree: {
      name: "create_tree",
      requestType: CreateTreeRequest,
      requestStream: false,
      responseType: CreateTreeResponse,
      responseStream: false,
      options: {},
    },
    get_signing_operator_list: {
      name: "get_signing_operator_list",
      requestType: Empty,
      requestStream: false,
      responseType: GetSigningOperatorListResponse,
      responseStream: false,
      options: {},
    },
    generate_revocation_public_key: {
      name: "generate_revocation_public_key",
      requestType: Empty,
      requestStream: false,
      responseType: GenerateRevocationPublicKeyResponse,
      responseStream: false,
      options: {},
    },
    start_token_transaction: {
      name: "start_token_transaction",
      requestType: StartTokenTransactionRequest,
      requestStream: false,
      responseType: StartTokenTransactionResponse,
      responseStream: false,
      options: {},
    },
    finalize_token_transaction: {
      name: "finalize_token_transaction",
      requestType: FinalizeTokenTransactionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    query_user_signed_refunds: {
      name: "query_user_signed_refunds",
      requestType: QueryUserSignedRefundsRequest,
      requestStream: false,
      responseType: QueryUserSignedRefundsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SparkServiceImplementation<CallContextExt = {}> {
  generate_deposit_address(
    request: GenerateDepositAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateDepositAddressResponse>>;
  start_tree_creation(
    request: StartTreeCreationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTreeCreationResponse>>;
  finalize_node_signatures(
    request: FinalizeNodeSignaturesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FinalizeNodeSignaturesResponse>>;
  start_send_transfer(
    request: StartSendTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartSendTransferResponse>>;
  complete_send_transfer(
    request: CompleteSendTransferRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CompleteSendTransferResponse>>;
  query_pending_transfers(
    request: QueryPendingTransfersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryPendingTransfersResponse>>;
  claim_transfer_tweak_keys(
    request: ClaimTransferTweakKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  claim_transfer_sign_refunds(
    request: ClaimTransferSignRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ClaimTransferSignRefundsResponse>>;
  aggregate_nodes(
    request: AggregateNodesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AggregateNodesResponse>>;
  store_preimage_share(
    request: StorePreimageShareRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  get_signing_commitments(
    request: GetSigningCommitmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningCommitmentsResponse>>;
  cooperative_exit(
    request: CooperativeExitRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CooperativeExitResponse>>;
  initiate_preimage_swap(
    request: InitiatePreimageSwapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitiatePreimageSwapResponse>>;
  provide_preimage(
    request: ProvidePreimageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ProvidePreimageResponse>>;
  leaf_swap(request: LeafSwapRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LeafSwapResponse>>;
  prepare_tree_address(
    request: PrepareTreeAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PrepareTreeAddressResponse>>;
  create_tree(
    request: CreateTreeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CreateTreeResponse>>;
  get_signing_operator_list(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetSigningOperatorListResponse>>;
  generate_revocation_public_key(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateRevocationPublicKeyResponse>>;
  start_token_transaction(
    request: StartTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartTokenTransactionResponse>>;
  finalize_token_transaction(
    request: FinalizeTokenTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  query_user_signed_refunds(
    request: QueryUserSignedRefundsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryUserSignedRefundsResponse>>;
}

export interface SparkServiceClient<CallOptionsExt = {}> {
  generate_deposit_address(
    request: DeepPartial<GenerateDepositAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateDepositAddressResponse>;
  start_tree_creation(
    request: DeepPartial<StartTreeCreationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTreeCreationResponse>;
  finalize_node_signatures(
    request: DeepPartial<FinalizeNodeSignaturesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FinalizeNodeSignaturesResponse>;
  start_send_transfer(
    request: DeepPartial<StartSendTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartSendTransferResponse>;
  complete_send_transfer(
    request: DeepPartial<CompleteSendTransferRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CompleteSendTransferResponse>;
  query_pending_transfers(
    request: DeepPartial<QueryPendingTransfersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryPendingTransfersResponse>;
  claim_transfer_tweak_keys(
    request: DeepPartial<ClaimTransferTweakKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  claim_transfer_sign_refunds(
    request: DeepPartial<ClaimTransferSignRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ClaimTransferSignRefundsResponse>;
  aggregate_nodes(
    request: DeepPartial<AggregateNodesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AggregateNodesResponse>;
  store_preimage_share(
    request: DeepPartial<StorePreimageShareRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  get_signing_commitments(
    request: DeepPartial<GetSigningCommitmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningCommitmentsResponse>;
  cooperative_exit(
    request: DeepPartial<CooperativeExitRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CooperativeExitResponse>;
  initiate_preimage_swap(
    request: DeepPartial<InitiatePreimageSwapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitiatePreimageSwapResponse>;
  provide_preimage(
    request: DeepPartial<ProvidePreimageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProvidePreimageResponse>;
  leaf_swap(request: DeepPartial<LeafSwapRequest>, options?: CallOptions & CallOptionsExt): Promise<LeafSwapResponse>;
  prepare_tree_address(
    request: DeepPartial<PrepareTreeAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PrepareTreeAddressResponse>;
  create_tree(
    request: DeepPartial<CreateTreeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CreateTreeResponse>;
  get_signing_operator_list(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetSigningOperatorListResponse>;
  generate_revocation_public_key(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateRevocationPublicKeyResponse>;
  start_token_transaction(
    request: DeepPartial<StartTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartTokenTransactionResponse>;
  finalize_token_transaction(
    request: DeepPartial<FinalizeTokenTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  query_user_signed_refunds(
    request: DeepPartial<QueryUserSignedRefundsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryUserSignedRefundsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
