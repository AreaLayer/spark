import { Transaction } from "@scure/btc-signer";
import { LeavesSwapRequest } from "./graphql/objects/index.js";
import { GenerateDepositAddressResponse, LeafWithPreviousTransactionData, Transfer, TreeNode } from "./proto/spark.js";
import { WalletConfigService } from "./services/config.js";
import { ConnectionManager } from "./services/connection.js";
import { TransferService } from "./services/transfer.js";
import { DepositAddressTree } from "./services/tree-creation.js";
import { SparkSigner } from "./signer/signer.js";
import { Network } from "./utils/network.js";
export type CreateLightningInvoiceParams = {
    amountSats: number;
    expirySeconds: number;
    memo: string;
    invoiceCreator?: () => Promise<string>;
};
export type PayLightningInvoiceParams = {
    invoice: string;
    amountSats?: number;
};
export type SendTransferParams = {
    amount?: number;
    leaves?: TreeNode[];
    receiverPubKey: Uint8Array;
    expiryTime?: Date;
};
export type DepositParams = {
    signingPubKey: Uint8Array;
    verifyingKey: Uint8Array;
    depositTx: Transaction;
    vout: number;
};
export declare class SparkWallet {
    protected config: WalletConfigService;
    protected connectionManager: ConnectionManager;
    private depositService;
    protected transferService: TransferService;
    private treeCreationService;
    private lightningService;
    private coopExitService;
    private tokenTransactionService;
    private sspClient;
    private wasmModule;
    protected leaves: TreeNode[];
    protected tokenLeaves: Map<string, LeafWithPreviousTransactionData[]>;
    constructor(network: Network, signer?: SparkSigner);
    private initWasm;
    private initializeWallet;
    private selectLeaves;
    private selectLeavesForSwap;
    private getLeaves;
    private optimizeLeaves;
    private syncWallet;
    isInitialized(): boolean;
    getIdentityPublicKey(): Promise<string>;
    initWalletFromMnemonic(mnemonic?: string): Promise<string>;
    initWallet(seed: Uint8Array | string): Promise<string>;
    requestLeavesSwap({ targetAmount, leaves, }: {
        targetAmount?: number;
        leaves?: TreeNode[];
    }): Promise<LeavesSwapRequest>;
    getBalance(): Promise<BigInt>;
    generatePublicKey(): Promise<string>;
    generateDepositAddress(signingPubkey: Uint8Array): Promise<GenerateDepositAddressResponse>;
    finalizeDeposit({ signingPubKey, verifyingKey, depositTx, vout, }: DepositParams): Promise<TreeNode[] | undefined>;
    claimDeposits(): Promise<TreeNode[]>;
    private queryMempoolTxs;
    private transferDepositToSelf;
    sendTransfer({ amount, receiverPubKey, leaves, expiryTime, }: SendTransferParams): Promise<Transfer>;
    private claimTransfer;
    private claimTransfers;
    cancelAllSenderInitiatedTransfers(): Promise<void>;
    createLightningInvoice({ amountSats, memo, expirySeconds, invoiceCreator, }: CreateLightningInvoiceParams): Promise<string>;
    payLightningInvoice({ invoice, amountSats, }: PayLightningInvoiceParams): Promise<import("./graphql/objects/LightningSendRequest.js").default>;
    private getLightningReceiveFeeEstimate;
    private getLightningSendFeeEstimate;
    generateDepositAddressForTree(vout: number, parentSigningPubKey: Uint8Array, parentTx?: Transaction, parentNode?: TreeNode): Promise<DepositAddressTree>;
    createTree(vout: number, root: DepositAddressTree, createLeaves: boolean, parentTx?: Transaction, parentNode?: TreeNode): Promise<import("./proto/spark.js").FinalizeNodeSignaturesResponse>;
    coopExit(onchainAddress: string, targetAmountSats?: number): Promise<import("./graphql/objects/CoopExitRequest.js").default | null | undefined>;
    private getCoopExitFeeEstimate;
    protected syncTokenLeaves(): Promise<void>;
    getAllTokenLeaves(): Promise<Map<string, LeafWithPreviousTransactionData[]>>;
    getAllTokenBalances(): Promise<Map<string, bigint>>;
    getTokenBalance(tokenPublicKey: string): Promise<bigint>;
    transferTokens(tokenPublicKey: string, tokenAmount: bigint, recipientPublicKey: string, selectedLeaves?: LeafWithPreviousTransactionData[]): Promise<void>;
    selectTokenLeaves(tokenPublicKey: string, tokenAmount: bigint): LeafWithPreviousTransactionData[];
    consolidateTokenLeaves(tokenPublicKey: string, selectedLeaves?: LeafWithPreviousTransactionData[]): Promise<void>;
}
