import { Transaction } from "@scure/btc-signer";
import { CoopExitFeeEstimateInput, CoopExitFeeEstimateOutput, LeavesSwapRequest, LightningReceiveFeeEstimateInput, LightningReceiveFeeEstimateOutput, LightningSendFeeEstimateInput, LightningSendFeeEstimateOutput } from "./graphql/objects/index.js";
import { GenerateDepositAddressResponse, LeafWithPreviousTransactionData, QueryPendingTransfersResponse, Transfer, TreeNode } from "./proto/spark.js";
import { WalletConfig, WalletConfigService } from "./services/config.js";
import { ConnectionManager } from "./services/connection.js";
import { LeafKeyTweak } from "./services/transfer.js";
import { DepositAddressTree } from "./services/tree-creation.js";
import { SparkSigner } from "./signer/signer.js";
import { Network } from "./utils/network.js";
import { AggregateFrostParams, SignFrostParams } from "./utils/wasm.js";
type CreateLightningInvoiceParams = {
    amountSats: number;
    expirySeconds: number;
    memo: string;
    invoiceCreator?: () => Promise<string>;
};
type PayLightningInvoiceParams = {
    invoice: string;
    amountSats?: number;
};
type SendTransferParams = {
    amount?: number;
    leaves?: TreeNode[];
    receiverPubKey: Uint8Array;
    expiryTime?: Date;
};
export declare class SparkWallet {
    protected config: WalletConfigService;
    protected connectionManager: ConnectionManager;
    private depositService;
    private transferService;
    private treeCreationService;
    private lightningService;
    private coopExitService;
    private tokenTransactionService;
    private sspClient;
    private wasmModule;
    protected leaves: TreeNode[];
    protected tokenLeaves: Map<string, LeafWithPreviousTransactionData[]>;
    constructor(network: Network, signer?: SparkSigner);
    getSigner(): SparkSigner;
    private initWasm;
    private ensureInitialized;
    getConfigService(): WalletConfigService;
    getConfig(): WalletConfig;
    getMasterPubKey(): Promise<Uint8Array>;
    getP2trAddress(): Promise<string>;
    signFrost(params: SignFrostParams): Promise<Uint8Array>;
    aggregateFrost(params: AggregateFrostParams): Promise<Uint8Array>;
    generateMnemonic(): Promise<string>;
    isInitialized(): boolean;
    createSparkWallet(mnemonic: string): Promise<string>;
    createSparkWalletFromSeed(seed: Uint8Array | string): Promise<string>;
    private initializeWallet;
    private selectLeaves;
    private selectLeavesForSwap;
    syncWallet(): Promise<void>;
    optimizeLeaves(): Promise<void>;
    requestLeavesSwap({ targetAmount, leaves, }: {
        targetAmount?: number;
        leaves?: TreeNode[];
    }): Promise<LeavesSwapRequest>;
    createLightningInvoice({ amountSats, memo, expirySeconds, invoiceCreator, }: CreateLightningInvoiceParams): Promise<string>;
    payLightningInvoice({ invoice, amountSats, }: PayLightningInvoiceParams): Promise<import("./graphql/objects/LightningSendRequest.js").default>;
    getLightningReceiveFeeEstimate({ amountSats, network, }: LightningReceiveFeeEstimateInput): Promise<LightningReceiveFeeEstimateOutput | null>;
    getLightningSendFeeEstimate({ encodedInvoice, }: LightningSendFeeEstimateInput): Promise<LightningSendFeeEstimateOutput | null>;
    getCoopExitFeeEstimate({ leafExternalIds, withdrawalAddress, }: CoopExitFeeEstimateInput): Promise<CoopExitFeeEstimateOutput | null>;
    transferDepositToSelf(leaves: TreeNode[], signingPubKey: Uint8Array): Promise<void>;
    sendTransfer({ amount, receiverPubKey, leaves, expiryTime, }: SendTransferParams): Promise<Transfer>;
    queryPendingTransfers(): Promise<QueryPendingTransfersResponse>;
    claimTransfer(transfer: Transfer): Promise<import("./proto/spark.js").FinalizeNodeSignaturesResponse>;
    claimTransfers(): Promise<boolean>;
    coopExit(onchainAddress: string, targetAmountSats?: number): Promise<import("./graphql/objects/CoopExitRequest.js").default | null | undefined>;
    _sendTransfer(leaves: LeafKeyTweak[], receiverIdentityPubkey: Uint8Array, expiryTime: Date): Promise<Transfer>;
    _claimTransfer(transfer: Transfer, leaves: LeafKeyTweak[]): Promise<import("./proto/spark.js").FinalizeNodeSignaturesResponse>;
    getLeaves(): Promise<TreeNode[]>;
    getBalance(): Promise<BigInt>;
    verifyPendingTransfer(transfer: Transfer): Promise<Map<string, Uint8Array>>;
    generateDepositAddress(signingPubkey: Uint8Array): Promise<GenerateDepositAddressResponse>;
    syncTokenLeaves(): Promise<void>;
    getTokenBalance(tokenPublicKey: Uint8Array): bigint;
    transferTokens(tokenPublicKey: Uint8Array, tokenAmount: bigint, recipientPublicKey: Uint8Array, selectedLeaves?: LeafWithPreviousTransactionData[]): Promise<void>;
    selectTokenLeaves(tokenPublicKey: Uint8Array, tokenAmount: bigint): LeafWithPreviousTransactionData[];
    consolidateTokenLeaves(tokenPublicKey: Uint8Array, selectedLeaves?: LeafWithPreviousTransactionData[], transferBackToIdentityPublicKey?: boolean): Promise<void>;
    queryPendingDepositTx(depositAddress: string): Promise<{
        depositTx: Transaction;
        vout: any;
    } | null>;
    createTreeRoot(signingPubKey: Uint8Array, verifyingKey: Uint8Array, depositTx: Transaction, vout: number): Promise<import("./proto/spark.js").FinalizeNodeSignaturesResponse>;
    generateDepositAddressForTree(vout: number, parentSigningPubKey: Uint8Array, parentTx?: Transaction, parentNode?: TreeNode): Promise<DepositAddressTree>;
    createTree(vout: number, root: DepositAddressTree, createLeaves: boolean, parentTx?: Transaction, parentNode?: TreeNode): Promise<import("./proto/spark.js").FinalizeNodeSignaturesResponse>;
}
export {};
