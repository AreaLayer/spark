// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: spark.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { signatureIntentFromJSON, signatureIntentToJSON, SigningCommitment } from "./common.js";
import { Empty } from "./google/protobuf/empty.js";
import { Timestamp } from "./google/protobuf/timestamp.js";
export const protobufPackage = "spark";
export var Network;
(function (Network) {
    Network[Network["MAINNET"] = 0] = "MAINNET";
    Network[Network["REGTEST"] = 1] = "REGTEST";
    Network[Network["TESTNET"] = 2] = "TESTNET";
    Network[Network["SIGNET"] = 3] = "SIGNET";
    Network[Network["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Network || (Network = {}));
export function networkFromJSON(object) {
    switch (object) {
        case 0:
        case "MAINNET":
            return Network.MAINNET;
        case 1:
        case "REGTEST":
            return Network.REGTEST;
        case 2:
        case "TESTNET":
            return Network.TESTNET;
        case 3:
        case "SIGNET":
            return Network.SIGNET;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Network.UNRECOGNIZED;
    }
}
export function networkToJSON(object) {
    switch (object) {
        case Network.MAINNET:
            return "MAINNET";
        case Network.REGTEST:
            return "REGTEST";
        case Network.TESTNET:
            return "TESTNET";
        case Network.SIGNET:
            return "SIGNET";
        case Network.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var TransferStatus;
(function (TransferStatus) {
    TransferStatus[TransferStatus["TRANSFER_STATUS_SENDER_INITIATED"] = 0] = "TRANSFER_STATUS_SENDER_INITIATED";
    TransferStatus[TransferStatus["TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING"] = 1] = "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING";
    TransferStatus[TransferStatus["TRANSFER_STATUS_SENDER_KEY_TWEAKED"] = 2] = "TRANSFER_STATUS_SENDER_KEY_TWEAKED";
    TransferStatus[TransferStatus["TRANSFER_STATUS_RECEIVER_KEY_TWEAKED"] = 3] = "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED";
    TransferStatus[TransferStatus["TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED"] = 4] = "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED";
    TransferStatus[TransferStatus["TRANSFER_STATUS_COMPLETED"] = 5] = "TRANSFER_STATUS_COMPLETED";
    TransferStatus[TransferStatus["TRANSFER_STATUS_EXPIRED"] = 6] = "TRANSFER_STATUS_EXPIRED";
    TransferStatus[TransferStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TransferStatus || (TransferStatus = {}));
export function transferStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "TRANSFER_STATUS_SENDER_INITIATED":
            return TransferStatus.TRANSFER_STATUS_SENDER_INITIATED;
        case 1:
        case "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING":
            return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING;
        case 2:
        case "TRANSFER_STATUS_SENDER_KEY_TWEAKED":
            return TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED;
        case 3:
        case "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED":
            return TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED;
        case 4:
        case "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED":
            return TransferStatus.TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED;
        case 5:
        case "TRANSFER_STATUS_COMPLETED":
            return TransferStatus.TRANSFER_STATUS_COMPLETED;
        case 6:
        case "TRANSFER_STATUS_EXPIRED":
            return TransferStatus.TRANSFER_STATUS_EXPIRED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TransferStatus.UNRECOGNIZED;
    }
}
export function transferStatusToJSON(object) {
    switch (object) {
        case TransferStatus.TRANSFER_STATUS_SENDER_INITIATED:
            return "TRANSFER_STATUS_SENDER_INITIATED";
        case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING:
            return "TRANSFER_STATUS_SENDER_KEY_TWEAK_PENDING";
        case TransferStatus.TRANSFER_STATUS_SENDER_KEY_TWEAKED:
            return "TRANSFER_STATUS_SENDER_KEY_TWEAKED";
        case TransferStatus.TRANSFER_STATUS_RECEIVER_KEY_TWEAKED:
            return "TRANSFER_STATUS_RECEIVER_KEY_TWEAKED";
        case TransferStatus.TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED:
            return "TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED";
        case TransferStatus.TRANSFER_STATUS_COMPLETED:
            return "TRANSFER_STATUS_COMPLETED";
        case TransferStatus.TRANSFER_STATUS_EXPIRED:
            return "TRANSFER_STATUS_EXPIRED";
        case TransferStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var InitiatePreimageSwapRequest_Reason;
(function (InitiatePreimageSwapRequest_Reason) {
    /** REASON_SEND - The associated lightning service is sending the payment. */
    InitiatePreimageSwapRequest_Reason[InitiatePreimageSwapRequest_Reason["REASON_SEND"] = 0] = "REASON_SEND";
    /** REASON_RECEIVE - The associated lightning service is receiving the payment. */
    InitiatePreimageSwapRequest_Reason[InitiatePreimageSwapRequest_Reason["REASON_RECEIVE"] = 1] = "REASON_RECEIVE";
    InitiatePreimageSwapRequest_Reason[InitiatePreimageSwapRequest_Reason["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InitiatePreimageSwapRequest_Reason || (InitiatePreimageSwapRequest_Reason = {}));
export function initiatePreimageSwapRequest_ReasonFromJSON(object) {
    switch (object) {
        case 0:
        case "REASON_SEND":
            return InitiatePreimageSwapRequest_Reason.REASON_SEND;
        case 1:
        case "REASON_RECEIVE":
            return InitiatePreimageSwapRequest_Reason.REASON_RECEIVE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return InitiatePreimageSwapRequest_Reason.UNRECOGNIZED;
    }
}
export function initiatePreimageSwapRequest_ReasonToJSON(object) {
    switch (object) {
        case InitiatePreimageSwapRequest_Reason.REASON_SEND:
            return "REASON_SEND";
        case InitiatePreimageSwapRequest_Reason.REASON_RECEIVE:
            return "REASON_RECEIVE";
        case InitiatePreimageSwapRequest_Reason.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseDepositAddressProof() {
    return { addressSignatures: {}, proofOfPossessionSignature: new Uint8Array(0) };
}
export const DepositAddressProof = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.addressSignatures).forEach(([key, value]) => {
            DepositAddressProof_AddressSignaturesEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        if (message.proofOfPossessionSignature.length !== 0) {
            writer.uint32(18).bytes(message.proofOfPossessionSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositAddressProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = DepositAddressProof_AddressSignaturesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.addressSignatures[entry1.key] = entry1.value;
                    }
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.proofOfPossessionSignature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            addressSignatures: isObject(object.addressSignatures)
                ? Object.entries(object.addressSignatures).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
            proofOfPossessionSignature: isSet(object.proofOfPossessionSignature)
                ? bytesFromBase64(object.proofOfPossessionSignature)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.addressSignatures) {
            const entries = Object.entries(message.addressSignatures);
            if (entries.length > 0) {
                obj.addressSignatures = {};
                entries.forEach(([k, v]) => {
                    obj.addressSignatures[k] = base64FromBytes(v);
                });
            }
        }
        if (message.proofOfPossessionSignature.length !== 0) {
            obj.proofOfPossessionSignature = base64FromBytes(message.proofOfPossessionSignature);
        }
        return obj;
    },
    create(base) {
        return DepositAddressProof.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDepositAddressProof();
        message.addressSignatures = Object.entries(object.addressSignatures ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.proofOfPossessionSignature = object.proofOfPossessionSignature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseDepositAddressProof_AddressSignaturesEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const DepositAddressProof_AddressSignaturesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositAddressProof_AddressSignaturesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return DepositAddressProof_AddressSignaturesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDepositAddressProof_AddressSignaturesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseGenerateDepositAddressRequest() {
    return { signingPublicKey: new Uint8Array(0), identityPublicKey: new Uint8Array(0), network: 0 };
}
export const GenerateDepositAddressRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.signingPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.signingPublicKey);
        }
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.identityPublicKey);
        }
        if (message.network !== 0) {
            writer.uint32(24).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenerateDepositAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.network = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
            network: isSet(object.network) ? networkFromJSON(object.network) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingPublicKey.length !== 0) {
            obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
        }
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        if (message.network !== 0) {
            obj.network = networkToJSON(message.network);
        }
        return obj;
    },
    create(base) {
        return GenerateDepositAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGenerateDepositAddressRequest();
        message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        message.network = object.network ?? 0;
        return message;
    },
};
function createBaseAddress() {
    return { address: "", verifyingKey: new Uint8Array(0), depositAddressProof: undefined };
}
export const Address = {
    encode(message, writer = new BinaryWriter()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.verifyingKey.length !== 0) {
            writer.uint32(18).bytes(message.verifyingKey);
        }
        if (message.depositAddressProof !== undefined) {
            DepositAddressProof.encode(message.depositAddressProof, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.verifyingKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.depositAddressProof = DepositAddressProof.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? globalThis.String(object.address) : "",
            verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
            depositAddressProof: isSet(object.depositAddressProof)
                ? DepositAddressProof.fromJSON(object.depositAddressProof)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.verifyingKey.length !== 0) {
            obj.verifyingKey = base64FromBytes(message.verifyingKey);
        }
        if (message.depositAddressProof !== undefined) {
            obj.depositAddressProof = DepositAddressProof.toJSON(message.depositAddressProof);
        }
        return obj;
    },
    create(base) {
        return Address.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddress();
        message.address = object.address ?? "";
        message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
        message.depositAddressProof = (object.depositAddressProof !== undefined && object.depositAddressProof !== null)
            ? DepositAddressProof.fromPartial(object.depositAddressProof)
            : undefined;
        return message;
    },
};
function createBaseGenerateDepositAddressResponse() {
    return { depositAddress: undefined };
}
export const GenerateDepositAddressResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.depositAddress !== undefined) {
            Address.encode(message.depositAddress, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenerateDepositAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.depositAddress = Address.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { depositAddress: isSet(object.depositAddress) ? Address.fromJSON(object.depositAddress) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.depositAddress !== undefined) {
            obj.depositAddress = Address.toJSON(message.depositAddress);
        }
        return obj;
    },
    create(base) {
        return GenerateDepositAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGenerateDepositAddressResponse();
        message.depositAddress = (object.depositAddress !== undefined && object.depositAddress !== null)
            ? Address.fromPartial(object.depositAddress)
            : undefined;
        return message;
    },
};
function createBaseUTXO() {
    return { rawTx: new Uint8Array(0), vout: 0, network: 0 };
}
export const UTXO = {
    encode(message, writer = new BinaryWriter()) {
        if (message.rawTx.length !== 0) {
            writer.uint32(10).bytes(message.rawTx);
        }
        if (message.vout !== 0) {
            writer.uint32(16).uint32(message.vout);
        }
        if (message.network !== 0) {
            writer.uint32(24).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUTXO();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.rawTx = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.vout = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.network = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
            vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
            network: isSet(object.network) ? networkFromJSON(object.network) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rawTx.length !== 0) {
            obj.rawTx = base64FromBytes(message.rawTx);
        }
        if (message.vout !== 0) {
            obj.vout = Math.round(message.vout);
        }
        if (message.network !== 0) {
            obj.network = networkToJSON(message.network);
        }
        return obj;
    },
    create(base) {
        return UTXO.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUTXO();
        message.rawTx = object.rawTx ?? new Uint8Array(0);
        message.vout = object.vout ?? 0;
        message.network = object.network ?? 0;
        return message;
    },
};
function createBaseNodeOutput() {
    return { nodeId: "", vout: 0 };
}
export const NodeOutput = {
    encode(message, writer = new BinaryWriter()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.vout !== 0) {
            writer.uint32(16).uint32(message.vout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.vout = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.vout !== 0) {
            obj.vout = Math.round(message.vout);
        }
        return obj;
    },
    create(base) {
        return NodeOutput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNodeOutput();
        message.nodeId = object.nodeId ?? "";
        message.vout = object.vout ?? 0;
        return message;
    },
};
function createBaseSigningJob() {
    return { signingPublicKey: new Uint8Array(0), rawTx: new Uint8Array(0), signingNonceCommitment: undefined };
}
export const SigningJob = {
    encode(message, writer = new BinaryWriter()) {
        if (message.signingPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.signingPublicKey);
        }
        if (message.rawTx.length !== 0) {
            writer.uint32(18).bytes(message.rawTx);
        }
        if (message.signingNonceCommitment !== undefined) {
            SigningCommitment.encode(message.signingNonceCommitment, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningJob();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.rawTx = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signingNonceCommitment = SigningCommitment.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingPublicKey: isSet(object.signingPublicKey) ? bytesFromBase64(object.signingPublicKey) : new Uint8Array(0),
            rawTx: isSet(object.rawTx) ? bytesFromBase64(object.rawTx) : new Uint8Array(0),
            signingNonceCommitment: isSet(object.signingNonceCommitment)
                ? SigningCommitment.fromJSON(object.signingNonceCommitment)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingPublicKey.length !== 0) {
            obj.signingPublicKey = base64FromBytes(message.signingPublicKey);
        }
        if (message.rawTx.length !== 0) {
            obj.rawTx = base64FromBytes(message.rawTx);
        }
        if (message.signingNonceCommitment !== undefined) {
            obj.signingNonceCommitment = SigningCommitment.toJSON(message.signingNonceCommitment);
        }
        return obj;
    },
    create(base) {
        return SigningJob.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningJob();
        message.signingPublicKey = object.signingPublicKey ?? new Uint8Array(0);
        message.rawTx = object.rawTx ?? new Uint8Array(0);
        message.signingNonceCommitment =
            (object.signingNonceCommitment !== undefined && object.signingNonceCommitment !== null)
                ? SigningCommitment.fromPartial(object.signingNonceCommitment)
                : undefined;
        return message;
    },
};
function createBaseSigningKeyshare() {
    return { ownerIdentifiers: [], threshold: 0 };
}
export const SigningKeyshare = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.ownerIdentifiers) {
            writer.uint32(10).string(v);
        }
        if (message.threshold !== 0) {
            writer.uint32(16).uint32(message.threshold);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningKeyshare();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ownerIdentifiers.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.threshold = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ownerIdentifiers: globalThis.Array.isArray(object?.ownerIdentifiers)
                ? object.ownerIdentifiers.map((e) => globalThis.String(e))
                : [],
            threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ownerIdentifiers?.length) {
            obj.ownerIdentifiers = message.ownerIdentifiers;
        }
        if (message.threshold !== 0) {
            obj.threshold = Math.round(message.threshold);
        }
        return obj;
    },
    create(base) {
        return SigningKeyshare.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningKeyshare();
        message.ownerIdentifiers = object.ownerIdentifiers?.map((e) => e) || [];
        message.threshold = object.threshold ?? 0;
        return message;
    },
};
function createBaseSigningResult() {
    return { publicKeys: {}, signingNonceCommitments: {}, signatureShares: {}, signingKeyshare: undefined };
}
export const SigningResult = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.publicKeys).forEach(([key, value]) => {
            SigningResult_PublicKeysEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
            SigningResult_SigningNonceCommitmentsEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        Object.entries(message.signatureShares).forEach(([key, value]) => {
            SigningResult_SignatureSharesEntry.encode({ key: key, value }, writer.uint32(26).fork()).join();
        });
        if (message.signingKeyshare !== undefined) {
            SigningKeyshare.encode(message.signingKeyshare, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SigningResult_PublicKeysEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.publicKeys[entry1.key] = entry1.value;
                    }
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = SigningResult_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.signingNonceCommitments[entry2.key] = entry2.value;
                    }
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = SigningResult_SignatureSharesEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.signatureShares[entry3.key] = entry3.value;
                    }
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.signingKeyshare = SigningKeyshare.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            publicKeys: isObject(object.publicKeys)
                ? Object.entries(object.publicKeys).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
            signingNonceCommitments: isObject(object.signingNonceCommitments)
                ? Object.entries(object.signingNonceCommitments).reduce((acc, [key, value]) => {
                    acc[key] = SigningCommitment.fromJSON(value);
                    return acc;
                }, {})
                : {},
            signatureShares: isObject(object.signatureShares)
                ? Object.entries(object.signatureShares).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
            signingKeyshare: isSet(object.signingKeyshare) ? SigningKeyshare.fromJSON(object.signingKeyshare) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.publicKeys) {
            const entries = Object.entries(message.publicKeys);
            if (entries.length > 0) {
                obj.publicKeys = {};
                entries.forEach(([k, v]) => {
                    obj.publicKeys[k] = base64FromBytes(v);
                });
            }
        }
        if (message.signingNonceCommitments) {
            const entries = Object.entries(message.signingNonceCommitments);
            if (entries.length > 0) {
                obj.signingNonceCommitments = {};
                entries.forEach(([k, v]) => {
                    obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
                });
            }
        }
        if (message.signatureShares) {
            const entries = Object.entries(message.signatureShares);
            if (entries.length > 0) {
                obj.signatureShares = {};
                entries.forEach(([k, v]) => {
                    obj.signatureShares[k] = base64FromBytes(v);
                });
            }
        }
        if (message.signingKeyshare !== undefined) {
            obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
        }
        return obj;
    },
    create(base) {
        return SigningResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningResult();
        message.publicKeys = Object.entries(object.publicKeys ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SigningCommitment.fromPartial(value);
            }
            return acc;
        }, {});
        message.signatureShares = Object.entries(object.signatureShares ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.signingKeyshare = (object.signingKeyshare !== undefined && object.signingKeyshare !== null)
            ? SigningKeyshare.fromPartial(object.signingKeyshare)
            : undefined;
        return message;
    },
};
function createBaseSigningResult_PublicKeysEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const SigningResult_PublicKeysEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningResult_PublicKeysEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return SigningResult_PublicKeysEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningResult_PublicKeysEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSigningResult_SigningNonceCommitmentsEntry() {
    return { key: "", value: undefined };
}
export const SigningResult_SigningNonceCommitmentsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SigningCommitment.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SigningCommitment.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return SigningResult_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningResult_SigningNonceCommitmentsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SigningCommitment.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseSigningResult_SignatureSharesEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const SigningResult_SignatureSharesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningResult_SignatureSharesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return SigningResult_SignatureSharesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningResult_SignatureSharesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseNodeSignatureShares() {
    return {
        nodeId: "",
        nodeTxSigningResult: undefined,
        refundTxSigningResult: undefined,
        verifyingKey: new Uint8Array(0),
    };
}
export const NodeSignatureShares = {
    encode(message, writer = new BinaryWriter()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.nodeTxSigningResult !== undefined) {
            SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
        }
        if (message.refundTxSigningResult !== undefined) {
            SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
        }
        if (message.verifyingKey.length !== 0) {
            writer.uint32(34).bytes(message.verifyingKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeSignatureShares();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.verifyingKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            nodeTxSigningResult: isSet(object.nodeTxSigningResult)
                ? SigningResult.fromJSON(object.nodeTxSigningResult)
                : undefined,
            refundTxSigningResult: isSet(object.refundTxSigningResult)
                ? SigningResult.fromJSON(object.refundTxSigningResult)
                : undefined,
            verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.nodeTxSigningResult !== undefined) {
            obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
        }
        if (message.refundTxSigningResult !== undefined) {
            obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
        }
        if (message.verifyingKey.length !== 0) {
            obj.verifyingKey = base64FromBytes(message.verifyingKey);
        }
        return obj;
    },
    create(base) {
        return NodeSignatureShares.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNodeSignatureShares();
        message.nodeId = object.nodeId ?? "";
        message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
            ? SigningResult.fromPartial(object.nodeTxSigningResult)
            : undefined;
        message.refundTxSigningResult =
            (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
                ? SigningResult.fromPartial(object.refundTxSigningResult)
                : undefined;
        message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseNodeSignatures() {
    return { nodeId: "", nodeTxSignature: new Uint8Array(0), refundTxSignature: new Uint8Array(0) };
}
export const NodeSignatures = {
    encode(message, writer = new BinaryWriter()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.nodeTxSignature.length !== 0) {
            writer.uint32(18).bytes(message.nodeTxSignature);
        }
        if (message.refundTxSignature.length !== 0) {
            writer.uint32(26).bytes(message.refundTxSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeSignatures();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nodeTxSignature = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.refundTxSignature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            nodeTxSignature: isSet(object.nodeTxSignature) ? bytesFromBase64(object.nodeTxSignature) : new Uint8Array(0),
            refundTxSignature: isSet(object.refundTxSignature)
                ? bytesFromBase64(object.refundTxSignature)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.nodeTxSignature.length !== 0) {
            obj.nodeTxSignature = base64FromBytes(message.nodeTxSignature);
        }
        if (message.refundTxSignature.length !== 0) {
            obj.refundTxSignature = base64FromBytes(message.refundTxSignature);
        }
        return obj;
    },
    create(base) {
        return NodeSignatures.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNodeSignatures();
        message.nodeId = object.nodeId ?? "";
        message.nodeTxSignature = object.nodeTxSignature ?? new Uint8Array(0);
        message.refundTxSignature = object.refundTxSignature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseStartTreeCreationRequest() {
    return {
        identityPublicKey: new Uint8Array(0),
        onChainUtxo: undefined,
        rootTxSigningJob: undefined,
        refundTxSigningJob: undefined,
    };
}
export const StartTreeCreationRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.identityPublicKey);
        }
        if (message.onChainUtxo !== undefined) {
            UTXO.encode(message.onChainUtxo, writer.uint32(18).fork()).join();
        }
        if (message.rootTxSigningJob !== undefined) {
            SigningJob.encode(message.rootTxSigningJob, writer.uint32(26).fork()).join();
        }
        if (message.refundTxSigningJob !== undefined) {
            SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartTreeCreationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.onChainUtxo = UTXO.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.rootTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
            onChainUtxo: isSet(object.onChainUtxo) ? UTXO.fromJSON(object.onChainUtxo) : undefined,
            rootTxSigningJob: isSet(object.rootTxSigningJob) ? SigningJob.fromJSON(object.rootTxSigningJob) : undefined,
            refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        if (message.onChainUtxo !== undefined) {
            obj.onChainUtxo = UTXO.toJSON(message.onChainUtxo);
        }
        if (message.rootTxSigningJob !== undefined) {
            obj.rootTxSigningJob = SigningJob.toJSON(message.rootTxSigningJob);
        }
        if (message.refundTxSigningJob !== undefined) {
            obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
        }
        return obj;
    },
    create(base) {
        return StartTreeCreationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStartTreeCreationRequest();
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        message.onChainUtxo = (object.onChainUtxo !== undefined && object.onChainUtxo !== null)
            ? UTXO.fromPartial(object.onChainUtxo)
            : undefined;
        message.rootTxSigningJob = (object.rootTxSigningJob !== undefined && object.rootTxSigningJob !== null)
            ? SigningJob.fromPartial(object.rootTxSigningJob)
            : undefined;
        message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
            ? SigningJob.fromPartial(object.refundTxSigningJob)
            : undefined;
        return message;
    },
};
function createBaseStartTreeCreationResponse() {
    return { treeId: "", rootNodeSignatureShares: undefined };
}
export const StartTreeCreationResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.treeId !== "") {
            writer.uint32(10).string(message.treeId);
        }
        if (message.rootNodeSignatureShares !== undefined) {
            NodeSignatureShares.encode(message.rootNodeSignatureShares, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartTreeCreationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.treeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.rootNodeSignatureShares = NodeSignatureShares.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
            rootNodeSignatureShares: isSet(object.rootNodeSignatureShares)
                ? NodeSignatureShares.fromJSON(object.rootNodeSignatureShares)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.treeId !== "") {
            obj.treeId = message.treeId;
        }
        if (message.rootNodeSignatureShares !== undefined) {
            obj.rootNodeSignatureShares = NodeSignatureShares.toJSON(message.rootNodeSignatureShares);
        }
        return obj;
    },
    create(base) {
        return StartTreeCreationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStartTreeCreationResponse();
        message.treeId = object.treeId ?? "";
        message.rootNodeSignatureShares =
            (object.rootNodeSignatureShares !== undefined && object.rootNodeSignatureShares !== null)
                ? NodeSignatureShares.fromPartial(object.rootNodeSignatureShares)
                : undefined;
        return message;
    },
};
function createBaseTokenLeafToSpend() {
    return { prevTokenTransactionHash: new Uint8Array(0), prevTokenTransactionLeafVout: 0 };
}
export const TokenLeafToSpend = {
    encode(message, writer = new BinaryWriter()) {
        if (message.prevTokenTransactionHash.length !== 0) {
            writer.uint32(10).bytes(message.prevTokenTransactionHash);
        }
        if (message.prevTokenTransactionLeafVout !== 0) {
            writer.uint32(16).uint32(message.prevTokenTransactionLeafVout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenLeafToSpend();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.prevTokenTransactionHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.prevTokenTransactionLeafVout = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            prevTokenTransactionHash: isSet(object.prevTokenTransactionHash)
                ? bytesFromBase64(object.prevTokenTransactionHash)
                : new Uint8Array(0),
            prevTokenTransactionLeafVout: isSet(object.prevTokenTransactionLeafVout)
                ? globalThis.Number(object.prevTokenTransactionLeafVout)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.prevTokenTransactionHash.length !== 0) {
            obj.prevTokenTransactionHash = base64FromBytes(message.prevTokenTransactionHash);
        }
        if (message.prevTokenTransactionLeafVout !== 0) {
            obj.prevTokenTransactionLeafVout = Math.round(message.prevTokenTransactionLeafVout);
        }
        return obj;
    },
    create(base) {
        return TokenLeafToSpend.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTokenLeafToSpend();
        message.prevTokenTransactionHash = object.prevTokenTransactionHash ?? new Uint8Array(0);
        message.prevTokenTransactionLeafVout = object.prevTokenTransactionLeafVout ?? 0;
        return message;
    },
};
function createBaseTransferInput() {
    return { leavesToSpend: [] };
}
export const TransferInput = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.leavesToSpend) {
            TokenLeafToSpend.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leavesToSpend.push(TokenLeafToSpend.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leavesToSpend: globalThis.Array.isArray(object?.leavesToSpend)
                ? object.leavesToSpend.map((e) => TokenLeafToSpend.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leavesToSpend?.length) {
            obj.leavesToSpend = message.leavesToSpend.map((e) => TokenLeafToSpend.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return TransferInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferInput();
        message.leavesToSpend = object.leavesToSpend?.map((e) => TokenLeafToSpend.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMintInput() {
    return { issuerPublicKey: new Uint8Array(0), issuerProvidedTimestamp: 0 };
}
export const MintInput = {
    encode(message, writer = new BinaryWriter()) {
        if (message.issuerPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.issuerPublicKey);
        }
        if (message.issuerProvidedTimestamp !== 0) {
            writer.uint32(16).uint64(message.issuerProvidedTimestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMintInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.issuerPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.issuerProvidedTimestamp = longToNumber(reader.uint64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            issuerPublicKey: isSet(object.issuerPublicKey) ? bytesFromBase64(object.issuerPublicKey) : new Uint8Array(0),
            issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
                ? globalThis.Number(object.issuerProvidedTimestamp)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.issuerPublicKey.length !== 0) {
            obj.issuerPublicKey = base64FromBytes(message.issuerPublicKey);
        }
        if (message.issuerProvidedTimestamp !== 0) {
            obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
        }
        return obj;
    },
    create(base) {
        return MintInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMintInput();
        message.issuerPublicKey = object.issuerPublicKey ?? new Uint8Array(0);
        message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
        return message;
    },
};
function createBaseTokenLeafOutput() {
    return {
        id: undefined,
        ownerPublicKey: new Uint8Array(0),
        revocationPublicKey: undefined,
        withdrawBondSats: undefined,
        withdrawRelativeBlockLocktime: undefined,
        tokenPublicKey: new Uint8Array(0),
        tokenAmount: new Uint8Array(0),
    };
}
export const TokenLeafOutput = {
    encode(message, writer = new BinaryWriter()) {
        if (message.id !== undefined) {
            writer.uint32(10).string(message.id);
        }
        if (message.ownerPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerPublicKey);
        }
        if (message.revocationPublicKey !== undefined) {
            writer.uint32(26).bytes(message.revocationPublicKey);
        }
        if (message.withdrawBondSats !== undefined) {
            writer.uint32(32).uint64(message.withdrawBondSats);
        }
        if (message.withdrawRelativeBlockLocktime !== undefined) {
            writer.uint32(40).uint64(message.withdrawRelativeBlockLocktime);
        }
        if (message.tokenPublicKey.length !== 0) {
            writer.uint32(50).bytes(message.tokenPublicKey);
        }
        if (message.tokenAmount.length !== 0) {
            writer.uint32(58).bytes(message.tokenAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenLeafOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.revocationPublicKey = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.withdrawBondSats = longToNumber(reader.uint64());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.withdrawRelativeBlockLocktime = longToNumber(reader.uint64());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.tokenPublicKey = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.tokenAmount = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : undefined,
            ownerPublicKey: isSet(object.ownerPublicKey) ? bytesFromBase64(object.ownerPublicKey) : new Uint8Array(0),
            revocationPublicKey: isSet(object.revocationPublicKey) ? bytesFromBase64(object.revocationPublicKey) : undefined,
            withdrawBondSats: isSet(object.withdrawBondSats) ? globalThis.Number(object.withdrawBondSats) : undefined,
            withdrawRelativeBlockLocktime: isSet(object.withdrawRelativeBlockLocktime)
                ? globalThis.Number(object.withdrawRelativeBlockLocktime)
                : undefined,
            tokenPublicKey: isSet(object.tokenPublicKey) ? bytesFromBase64(object.tokenPublicKey) : new Uint8Array(0),
            tokenAmount: isSet(object.tokenAmount) ? bytesFromBase64(object.tokenAmount) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== undefined) {
            obj.id = message.id;
        }
        if (message.ownerPublicKey.length !== 0) {
            obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
        }
        if (message.revocationPublicKey !== undefined) {
            obj.revocationPublicKey = base64FromBytes(message.revocationPublicKey);
        }
        if (message.withdrawBondSats !== undefined) {
            obj.withdrawBondSats = Math.round(message.withdrawBondSats);
        }
        if (message.withdrawRelativeBlockLocktime !== undefined) {
            obj.withdrawRelativeBlockLocktime = Math.round(message.withdrawRelativeBlockLocktime);
        }
        if (message.tokenPublicKey.length !== 0) {
            obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
        }
        if (message.tokenAmount.length !== 0) {
            obj.tokenAmount = base64FromBytes(message.tokenAmount);
        }
        return obj;
    },
    create(base) {
        return TokenLeafOutput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTokenLeafOutput();
        message.id = object.id ?? undefined;
        message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
        message.revocationPublicKey = object.revocationPublicKey ?? undefined;
        message.withdrawBondSats = object.withdrawBondSats ?? undefined;
        message.withdrawRelativeBlockLocktime = object.withdrawRelativeBlockLocktime ?? undefined;
        message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
        message.tokenAmount = object.tokenAmount ?? new Uint8Array(0);
        return message;
    },
};
function createBaseTokenTransaction() {
    return { tokenInput: undefined, outputLeaves: [], sparkOperatorIdentityPublicKeys: [] };
}
export const TokenTransaction = {
    encode(message, writer = new BinaryWriter()) {
        switch (message.tokenInput?.$case) {
            case "mintInput":
                MintInput.encode(message.tokenInput.mintInput, writer.uint32(10).fork()).join();
                break;
            case "transferInput":
                TransferInput.encode(message.tokenInput.transferInput, writer.uint32(18).fork()).join();
                break;
        }
        for (const v of message.outputLeaves) {
            TokenLeafOutput.encode(v, writer.uint32(26).fork()).join();
        }
        for (const v of message.sparkOperatorIdentityPublicKeys) {
            writer.uint32(34).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenTransaction();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tokenInput = { $case: "mintInput", mintInput: MintInput.decode(reader, reader.uint32()) };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenInput = { $case: "transferInput", transferInput: TransferInput.decode(reader, reader.uint32()) };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.outputLeaves.push(TokenLeafOutput.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.sparkOperatorIdentityPublicKeys.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenInput: isSet(object.mintInput)
                ? { $case: "mintInput", mintInput: MintInput.fromJSON(object.mintInput) }
                : isSet(object.transferInput)
                    ? { $case: "transferInput", transferInput: TransferInput.fromJSON(object.transferInput) }
                    : undefined,
            outputLeaves: globalThis.Array.isArray(object?.outputLeaves)
                ? object.outputLeaves.map((e) => TokenLeafOutput.fromJSON(e))
                : [],
            sparkOperatorIdentityPublicKeys: globalThis.Array.isArray(object?.sparkOperatorIdentityPublicKeys)
                ? object.sparkOperatorIdentityPublicKeys.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenInput?.$case === "mintInput") {
            obj.mintInput = MintInput.toJSON(message.tokenInput.mintInput);
        }
        else if (message.tokenInput?.$case === "transferInput") {
            obj.transferInput = TransferInput.toJSON(message.tokenInput.transferInput);
        }
        if (message.outputLeaves?.length) {
            obj.outputLeaves = message.outputLeaves.map((e) => TokenLeafOutput.toJSON(e));
        }
        if (message.sparkOperatorIdentityPublicKeys?.length) {
            obj.sparkOperatorIdentityPublicKeys = message.sparkOperatorIdentityPublicKeys.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return TokenTransaction.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTokenTransaction();
        switch (object.tokenInput?.$case) {
            case "mintInput": {
                if (object.tokenInput?.mintInput !== undefined && object.tokenInput?.mintInput !== null) {
                    message.tokenInput = { $case: "mintInput", mintInput: MintInput.fromPartial(object.tokenInput.mintInput) };
                }
                break;
            }
            case "transferInput": {
                if (object.tokenInput?.transferInput !== undefined && object.tokenInput?.transferInput !== null) {
                    message.tokenInput = {
                        $case: "transferInput",
                        transferInput: TransferInput.fromPartial(object.tokenInput.transferInput),
                    };
                }
                break;
            }
        }
        message.outputLeaves = object.outputLeaves?.map((e) => TokenLeafOutput.fromPartial(e)) || [];
        message.sparkOperatorIdentityPublicKeys = object.sparkOperatorIdentityPublicKeys?.map((e) => e) || [];
        return message;
    },
};
function createBaseTokenTransactionSignatures() {
    return { ownerSignatures: [] };
}
export const TokenTransactionSignatures = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.ownerSignatures) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenTransactionSignatures();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ownerSignatures.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ownerSignatures: globalThis.Array.isArray(object?.ownerSignatures)
                ? object.ownerSignatures.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ownerSignatures?.length) {
            obj.ownerSignatures = message.ownerSignatures.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return TokenTransactionSignatures.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTokenTransactionSignatures();
        message.ownerSignatures = object.ownerSignatures?.map((e) => e) || [];
        return message;
    },
};
function createBaseStartTokenTransactionRequest() {
    return {
        identityPublicKey: new Uint8Array(0),
        partialTokenTransaction: undefined,
        tokenTransactionSignatures: undefined,
    };
}
export const StartTokenTransactionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.identityPublicKey);
        }
        if (message.partialTokenTransaction !== undefined) {
            TokenTransaction.encode(message.partialTokenTransaction, writer.uint32(18).fork()).join();
        }
        if (message.tokenTransactionSignatures !== undefined) {
            TokenTransactionSignatures.encode(message.tokenTransactionSignatures, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartTokenTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.partialTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.tokenTransactionSignatures = TokenTransactionSignatures.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
            partialTokenTransaction: isSet(object.partialTokenTransaction)
                ? TokenTransaction.fromJSON(object.partialTokenTransaction)
                : undefined,
            tokenTransactionSignatures: isSet(object.tokenTransactionSignatures)
                ? TokenTransactionSignatures.fromJSON(object.tokenTransactionSignatures)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        if (message.partialTokenTransaction !== undefined) {
            obj.partialTokenTransaction = TokenTransaction.toJSON(message.partialTokenTransaction);
        }
        if (message.tokenTransactionSignatures !== undefined) {
            obj.tokenTransactionSignatures = TokenTransactionSignatures.toJSON(message.tokenTransactionSignatures);
        }
        return obj;
    },
    create(base) {
        return StartTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStartTokenTransactionRequest();
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        message.partialTokenTransaction =
            (object.partialTokenTransaction !== undefined && object.partialTokenTransaction !== null)
                ? TokenTransaction.fromPartial(object.partialTokenTransaction)
                : undefined;
        message.tokenTransactionSignatures =
            (object.tokenTransactionSignatures !== undefined && object.tokenTransactionSignatures !== null)
                ? TokenTransactionSignatures.fromPartial(object.tokenTransactionSignatures)
                : undefined;
        return message;
    },
};
function createBaseStartTokenTransactionResponse() {
    return { finalTokenTransaction: undefined, keyshareInfo: undefined };
}
export const StartTokenTransactionResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.finalTokenTransaction !== undefined) {
            TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
        }
        if (message.keyshareInfo !== undefined) {
            SigningKeyshare.encode(message.keyshareInfo, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartTokenTransactionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.keyshareInfo = SigningKeyshare.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            finalTokenTransaction: isSet(object.finalTokenTransaction)
                ? TokenTransaction.fromJSON(object.finalTokenTransaction)
                : undefined,
            keyshareInfo: isSet(object.keyshareInfo) ? SigningKeyshare.fromJSON(object.keyshareInfo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.finalTokenTransaction !== undefined) {
            obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
        }
        if (message.keyshareInfo !== undefined) {
            obj.keyshareInfo = SigningKeyshare.toJSON(message.keyshareInfo);
        }
        return obj;
    },
    create(base) {
        return StartTokenTransactionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStartTokenTransactionResponse();
        message.finalTokenTransaction =
            (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
                ? TokenTransaction.fromPartial(object.finalTokenTransaction)
                : undefined;
        message.keyshareInfo = (object.keyshareInfo !== undefined && object.keyshareInfo !== null)
            ? SigningKeyshare.fromPartial(object.keyshareInfo)
            : undefined;
        return message;
    },
};
function createBaseOperatorSpecificTokenTransactionSignablePayload() {
    return { finalTokenTransactionHash: new Uint8Array(0), operatorIdentityPublicKey: new Uint8Array(0) };
}
export const OperatorSpecificTokenTransactionSignablePayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.finalTokenTransactionHash.length !== 0) {
            writer.uint32(10).bytes(message.finalTokenTransactionHash);
        }
        if (message.operatorIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.operatorIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperatorSpecificTokenTransactionSignablePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.finalTokenTransactionHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.operatorIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            finalTokenTransactionHash: isSet(object.finalTokenTransactionHash)
                ? bytesFromBase64(object.finalTokenTransactionHash)
                : new Uint8Array(0),
            operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
                ? bytesFromBase64(object.operatorIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.finalTokenTransactionHash.length !== 0) {
            obj.finalTokenTransactionHash = base64FromBytes(message.finalTokenTransactionHash);
        }
        if (message.operatorIdentityPublicKey.length !== 0) {
            obj.operatorIdentityPublicKey = base64FromBytes(message.operatorIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return OperatorSpecificTokenTransactionSignablePayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOperatorSpecificTokenTransactionSignablePayload();
        message.finalTokenTransactionHash = object.finalTokenTransactionHash ?? new Uint8Array(0);
        message.operatorIdentityPublicKey = object.operatorIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseOperatorSpecificTokenTransactionSignature() {
    return { ownerPublicKey: new Uint8Array(0), ownerSignature: new Uint8Array(0), payload: undefined };
}
export const OperatorSpecificTokenTransactionSignature = {
    encode(message, writer = new BinaryWriter()) {
        if (message.ownerPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.ownerPublicKey);
        }
        if (message.ownerSignature.length !== 0) {
            writer.uint32(18).bytes(message.ownerSignature);
        }
        if (message.payload !== undefined) {
            OperatorSpecificTokenTransactionSignablePayload.encode(message.payload, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperatorSpecificTokenTransactionSignature();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ownerPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerSignature = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.payload = OperatorSpecificTokenTransactionSignablePayload.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ownerPublicKey: isSet(object.ownerPublicKey) ? bytesFromBase64(object.ownerPublicKey) : new Uint8Array(0),
            ownerSignature: isSet(object.ownerSignature) ? bytesFromBase64(object.ownerSignature) : new Uint8Array(0),
            payload: isSet(object.payload)
                ? OperatorSpecificTokenTransactionSignablePayload.fromJSON(object.payload)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ownerPublicKey.length !== 0) {
            obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
        }
        if (message.ownerSignature.length !== 0) {
            obj.ownerSignature = base64FromBytes(message.ownerSignature);
        }
        if (message.payload !== undefined) {
            obj.payload = OperatorSpecificTokenTransactionSignablePayload.toJSON(message.payload);
        }
        return obj;
    },
    create(base) {
        return OperatorSpecificTokenTransactionSignature.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOperatorSpecificTokenTransactionSignature();
        message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
        message.ownerSignature = object.ownerSignature ?? new Uint8Array(0);
        message.payload = (object.payload !== undefined && object.payload !== null)
            ? OperatorSpecificTokenTransactionSignablePayload.fromPartial(object.payload)
            : undefined;
        return message;
    },
};
function createBaseSignTokenTransactionRequest() {
    return { finalTokenTransaction: undefined, operatorSpecificSignatures: [], identityPublicKey: new Uint8Array(0) };
}
export const SignTokenTransactionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.finalTokenTransaction !== undefined) {
            TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
        }
        for (const v of message.operatorSpecificSignatures) {
            OperatorSpecificTokenTransactionSignature.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.identityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignTokenTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.operatorSpecificSignatures.push(OperatorSpecificTokenTransactionSignature.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            finalTokenTransaction: isSet(object.finalTokenTransaction)
                ? TokenTransaction.fromJSON(object.finalTokenTransaction)
                : undefined,
            operatorSpecificSignatures: globalThis.Array.isArray(object?.operatorSpecificSignatures)
                ? object.operatorSpecificSignatures.map((e) => OperatorSpecificTokenTransactionSignature.fromJSON(e))
                : [],
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.finalTokenTransaction !== undefined) {
            obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
        }
        if (message.operatorSpecificSignatures?.length) {
            obj.operatorSpecificSignatures = message.operatorSpecificSignatures.map((e) => OperatorSpecificTokenTransactionSignature.toJSON(e));
        }
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        return obj;
    },
    create(base) {
        return SignTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSignTokenTransactionRequest();
        message.finalTokenTransaction =
            (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
                ? TokenTransaction.fromPartial(object.finalTokenTransaction)
                : undefined;
        message.operatorSpecificSignatures =
            object.operatorSpecificSignatures?.map((e) => OperatorSpecificTokenTransactionSignature.fromPartial(e)) || [];
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSignTokenTransactionResponse() {
    return { sparkOperatorSignature: new Uint8Array(0), tokenTransactionRevocationKeyshares: [] };
}
export const SignTokenTransactionResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.sparkOperatorSignature.length !== 0) {
            writer.uint32(10).bytes(message.sparkOperatorSignature);
        }
        for (const v of message.tokenTransactionRevocationKeyshares) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignTokenTransactionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.sparkOperatorSignature = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenTransactionRevocationKeyshares.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sparkOperatorSignature: isSet(object.sparkOperatorSignature)
                ? bytesFromBase64(object.sparkOperatorSignature)
                : new Uint8Array(0),
            tokenTransactionRevocationKeyshares: globalThis.Array.isArray(object?.tokenTransactionRevocationKeyshares)
                ? object.tokenTransactionRevocationKeyshares.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sparkOperatorSignature.length !== 0) {
            obj.sparkOperatorSignature = base64FromBytes(message.sparkOperatorSignature);
        }
        if (message.tokenTransactionRevocationKeyshares?.length) {
            obj.tokenTransactionRevocationKeyshares = message.tokenTransactionRevocationKeyshares.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return SignTokenTransactionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSignTokenTransactionResponse();
        message.sparkOperatorSignature = object.sparkOperatorSignature ?? new Uint8Array(0);
        message.tokenTransactionRevocationKeyshares = object.tokenTransactionRevocationKeyshares?.map((e) => e) || [];
        return message;
    },
};
function createBaseFinalizeTokenTransactionRequest() {
    return { finalTokenTransaction: undefined, leafToSpendRevocationKeys: [], identityPublicKey: new Uint8Array(0) };
}
export const FinalizeTokenTransactionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.finalTokenTransaction !== undefined) {
            TokenTransaction.encode(message.finalTokenTransaction, writer.uint32(10).fork()).join();
        }
        for (const v of message.leafToSpendRevocationKeys) {
            writer.uint32(18).bytes(v);
        }
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.identityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFinalizeTokenTransactionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.finalTokenTransaction = TokenTransaction.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.leafToSpendRevocationKeys.push(reader.bytes());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            finalTokenTransaction: isSet(object.finalTokenTransaction)
                ? TokenTransaction.fromJSON(object.finalTokenTransaction)
                : undefined,
            leafToSpendRevocationKeys: globalThis.Array.isArray(object?.leafToSpendRevocationKeys)
                ? object.leafToSpendRevocationKeys.map((e) => bytesFromBase64(e))
                : [],
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.finalTokenTransaction !== undefined) {
            obj.finalTokenTransaction = TokenTransaction.toJSON(message.finalTokenTransaction);
        }
        if (message.leafToSpendRevocationKeys?.length) {
            obj.leafToSpendRevocationKeys = message.leafToSpendRevocationKeys.map((e) => base64FromBytes(e));
        }
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        return obj;
    },
    create(base) {
        return FinalizeTokenTransactionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFinalizeTokenTransactionRequest();
        message.finalTokenTransaction =
            (object.finalTokenTransaction !== undefined && object.finalTokenTransaction !== null)
                ? TokenTransaction.fromPartial(object.finalTokenTransaction)
                : undefined;
        message.leafToSpendRevocationKeys = object.leafToSpendRevocationKeys?.map((e) => e) || [];
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseFreezeTokensPayload() {
    return {
        ownerPublicKey: new Uint8Array(0),
        tokenPublicKey: new Uint8Array(0),
        issuerProvidedTimestamp: 0,
        operatorIdentityPublicKey: new Uint8Array(0),
        shouldUnfreeze: false,
    };
}
export const FreezeTokensPayload = {
    encode(message, writer = new BinaryWriter()) {
        if (message.ownerPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.ownerPublicKey);
        }
        if (message.tokenPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.tokenPublicKey);
        }
        if (message.issuerProvidedTimestamp !== 0) {
            writer.uint32(24).uint64(message.issuerProvidedTimestamp);
        }
        if (message.operatorIdentityPublicKey.length !== 0) {
            writer.uint32(34).bytes(message.operatorIdentityPublicKey);
        }
        if (message.shouldUnfreeze !== false) {
            writer.uint32(40).bool(message.shouldUnfreeze);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFreezeTokensPayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ownerPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.issuerProvidedTimestamp = longToNumber(reader.uint64());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.operatorIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.shouldUnfreeze = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ownerPublicKey: isSet(object.ownerPublicKey) ? bytesFromBase64(object.ownerPublicKey) : new Uint8Array(0),
            tokenPublicKey: isSet(object.tokenPublicKey) ? bytesFromBase64(object.tokenPublicKey) : new Uint8Array(0),
            issuerProvidedTimestamp: isSet(object.issuerProvidedTimestamp)
                ? globalThis.Number(object.issuerProvidedTimestamp)
                : 0,
            operatorIdentityPublicKey: isSet(object.operatorIdentityPublicKey)
                ? bytesFromBase64(object.operatorIdentityPublicKey)
                : new Uint8Array(0),
            shouldUnfreeze: isSet(object.shouldUnfreeze) ? globalThis.Boolean(object.shouldUnfreeze) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ownerPublicKey.length !== 0) {
            obj.ownerPublicKey = base64FromBytes(message.ownerPublicKey);
        }
        if (message.tokenPublicKey.length !== 0) {
            obj.tokenPublicKey = base64FromBytes(message.tokenPublicKey);
        }
        if (message.issuerProvidedTimestamp !== 0) {
            obj.issuerProvidedTimestamp = Math.round(message.issuerProvidedTimestamp);
        }
        if (message.operatorIdentityPublicKey.length !== 0) {
            obj.operatorIdentityPublicKey = base64FromBytes(message.operatorIdentityPublicKey);
        }
        if (message.shouldUnfreeze !== false) {
            obj.shouldUnfreeze = message.shouldUnfreeze;
        }
        return obj;
    },
    create(base) {
        return FreezeTokensPayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFreezeTokensPayload();
        message.ownerPublicKey = object.ownerPublicKey ?? new Uint8Array(0);
        message.tokenPublicKey = object.tokenPublicKey ?? new Uint8Array(0);
        message.issuerProvidedTimestamp = object.issuerProvidedTimestamp ?? 0;
        message.operatorIdentityPublicKey = object.operatorIdentityPublicKey ?? new Uint8Array(0);
        message.shouldUnfreeze = object.shouldUnfreeze ?? false;
        return message;
    },
};
function createBaseFreezeTokensRequest() {
    return { freezeTokensPayload: undefined, issuerSignature: new Uint8Array(0) };
}
export const FreezeTokensRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.freezeTokensPayload !== undefined) {
            FreezeTokensPayload.encode(message.freezeTokensPayload, writer.uint32(10).fork()).join();
        }
        if (message.issuerSignature.length !== 0) {
            writer.uint32(18).bytes(message.issuerSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFreezeTokensRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.freezeTokensPayload = FreezeTokensPayload.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.issuerSignature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            freezeTokensPayload: isSet(object.freezeTokensPayload)
                ? FreezeTokensPayload.fromJSON(object.freezeTokensPayload)
                : undefined,
            issuerSignature: isSet(object.issuerSignature) ? bytesFromBase64(object.issuerSignature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.freezeTokensPayload !== undefined) {
            obj.freezeTokensPayload = FreezeTokensPayload.toJSON(message.freezeTokensPayload);
        }
        if (message.issuerSignature.length !== 0) {
            obj.issuerSignature = base64FromBytes(message.issuerSignature);
        }
        return obj;
    },
    create(base) {
        return FreezeTokensRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFreezeTokensRequest();
        message.freezeTokensPayload = (object.freezeTokensPayload !== undefined && object.freezeTokensPayload !== null)
            ? FreezeTokensPayload.fromPartial(object.freezeTokensPayload)
            : undefined;
        message.issuerSignature = object.issuerSignature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseFreezeTokensResponse() {
    return { impactedLeafIds: [], impactedTokenAmount: new Uint8Array(0) };
}
export const FreezeTokensResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.impactedLeafIds) {
            writer.uint32(10).string(v);
        }
        if (message.impactedTokenAmount.length !== 0) {
            writer.uint32(18).bytes(message.impactedTokenAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFreezeTokensResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.impactedLeafIds.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.impactedTokenAmount = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            impactedLeafIds: globalThis.Array.isArray(object?.impactedLeafIds)
                ? object.impactedLeafIds.map((e) => globalThis.String(e))
                : [],
            impactedTokenAmount: isSet(object.impactedTokenAmount)
                ? bytesFromBase64(object.impactedTokenAmount)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.impactedLeafIds?.length) {
            obj.impactedLeafIds = message.impactedLeafIds;
        }
        if (message.impactedTokenAmount.length !== 0) {
            obj.impactedTokenAmount = base64FromBytes(message.impactedTokenAmount);
        }
        return obj;
    },
    create(base) {
        return FreezeTokensResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFreezeTokensResponse();
        message.impactedLeafIds = object.impactedLeafIds?.map((e) => e) || [];
        message.impactedTokenAmount = object.impactedTokenAmount ?? new Uint8Array(0);
        return message;
    },
};
function createBaseGetOwnedTokenLeavesRequest() {
    return { ownerPublicKeys: [], tokenPublicKeys: [] };
}
export const GetOwnedTokenLeavesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.ownerPublicKeys) {
            writer.uint32(10).bytes(v);
        }
        for (const v of message.tokenPublicKeys) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOwnedTokenLeavesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.ownerPublicKeys.push(reader.bytes());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.tokenPublicKeys.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ownerPublicKeys: globalThis.Array.isArray(object?.ownerPublicKeys)
                ? object.ownerPublicKeys.map((e) => bytesFromBase64(e))
                : [],
            tokenPublicKeys: globalThis.Array.isArray(object?.tokenPublicKeys)
                ? object.tokenPublicKeys.map((e) => bytesFromBase64(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ownerPublicKeys?.length) {
            obj.ownerPublicKeys = message.ownerPublicKeys.map((e) => base64FromBytes(e));
        }
        if (message.tokenPublicKeys?.length) {
            obj.tokenPublicKeys = message.tokenPublicKeys.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return GetOwnedTokenLeavesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetOwnedTokenLeavesRequest();
        message.ownerPublicKeys = object.ownerPublicKeys?.map((e) => e) || [];
        message.tokenPublicKeys = object.tokenPublicKeys?.map((e) => e) || [];
        return message;
    },
};
function createBaseLeafWithPreviousTransactionData() {
    return { leaf: undefined, previousTransactionHash: new Uint8Array(0), previousTransactionVout: 0 };
}
export const LeafWithPreviousTransactionData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leaf !== undefined) {
            TokenLeafOutput.encode(message.leaf, writer.uint32(10).fork()).join();
        }
        if (message.previousTransactionHash.length !== 0) {
            writer.uint32(18).bytes(message.previousTransactionHash);
        }
        if (message.previousTransactionVout !== 0) {
            writer.uint32(24).uint32(message.previousTransactionVout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeafWithPreviousTransactionData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leaf = TokenLeafOutput.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.previousTransactionHash = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.previousTransactionVout = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leaf: isSet(object.leaf) ? TokenLeafOutput.fromJSON(object.leaf) : undefined,
            previousTransactionHash: isSet(object.previousTransactionHash)
                ? bytesFromBase64(object.previousTransactionHash)
                : new Uint8Array(0),
            previousTransactionVout: isSet(object.previousTransactionVout)
                ? globalThis.Number(object.previousTransactionVout)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leaf !== undefined) {
            obj.leaf = TokenLeafOutput.toJSON(message.leaf);
        }
        if (message.previousTransactionHash.length !== 0) {
            obj.previousTransactionHash = base64FromBytes(message.previousTransactionHash);
        }
        if (message.previousTransactionVout !== 0) {
            obj.previousTransactionVout = Math.round(message.previousTransactionVout);
        }
        return obj;
    },
    create(base) {
        return LeafWithPreviousTransactionData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLeafWithPreviousTransactionData();
        message.leaf = (object.leaf !== undefined && object.leaf !== null)
            ? TokenLeafOutput.fromPartial(object.leaf)
            : undefined;
        message.previousTransactionHash = object.previousTransactionHash ?? new Uint8Array(0);
        message.previousTransactionVout = object.previousTransactionVout ?? 0;
        return message;
    },
};
function createBaseGetOwnedTokenLeavesResponse() {
    return { leavesWithPreviousTransactionData: [] };
}
export const GetOwnedTokenLeavesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.leavesWithPreviousTransactionData) {
            LeafWithPreviousTransactionData.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetOwnedTokenLeavesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leavesWithPreviousTransactionData.push(LeafWithPreviousTransactionData.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leavesWithPreviousTransactionData: globalThis.Array.isArray(object?.leavesWithPreviousTransactionData)
                ? object.leavesWithPreviousTransactionData.map((e) => LeafWithPreviousTransactionData.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leavesWithPreviousTransactionData?.length) {
            obj.leavesWithPreviousTransactionData = message.leavesWithPreviousTransactionData.map((e) => LeafWithPreviousTransactionData.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetOwnedTokenLeavesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetOwnedTokenLeavesResponse();
        message.leavesWithPreviousTransactionData =
            object.leavesWithPreviousTransactionData?.map((e) => LeafWithPreviousTransactionData.fromPartial(e)) || [];
        return message;
    },
};
function createBaseTreeNode() {
    return {
        id: "",
        treeId: "",
        value: 0,
        parentNodeId: undefined,
        nodeTx: new Uint8Array(0),
        refundTx: new Uint8Array(0),
        vout: 0,
        verifyingPublicKey: new Uint8Array(0),
        ownerIdentityPublicKey: new Uint8Array(0),
        signingKeyshare: undefined,
        status: "",
        network: 0,
    };
}
export const TreeNode = {
    encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.treeId !== "") {
            writer.uint32(18).string(message.treeId);
        }
        if (message.value !== 0) {
            writer.uint32(24).uint64(message.value);
        }
        if (message.parentNodeId !== undefined) {
            writer.uint32(34).string(message.parentNodeId);
        }
        if (message.nodeTx.length !== 0) {
            writer.uint32(42).bytes(message.nodeTx);
        }
        if (message.refundTx.length !== 0) {
            writer.uint32(50).bytes(message.refundTx);
        }
        if (message.vout !== 0) {
            writer.uint32(56).uint32(message.vout);
        }
        if (message.verifyingPublicKey.length !== 0) {
            writer.uint32(66).bytes(message.verifyingPublicKey);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(74).bytes(message.ownerIdentityPublicKey);
        }
        if (message.signingKeyshare !== undefined) {
            SigningKeyshare.encode(message.signingKeyshare, writer.uint32(82).fork()).join();
        }
        if (message.status !== "") {
            writer.uint32(90).string(message.status);
        }
        if (message.network !== 0) {
            writer.uint32(96).int32(message.network);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTreeNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.treeId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.value = longToNumber(reader.uint64());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.parentNodeId = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.nodeTx = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.refundTx = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.vout = reader.uint32();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.verifyingPublicKey = reader.bytes();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.signingKeyshare = SigningKeyshare.decode(reader, reader.uint32());
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.status = reader.string();
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.network = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            treeId: isSet(object.treeId) ? globalThis.String(object.treeId) : "",
            value: isSet(object.value) ? globalThis.Number(object.value) : 0,
            parentNodeId: isSet(object.parentNodeId) ? globalThis.String(object.parentNodeId) : undefined,
            nodeTx: isSet(object.nodeTx) ? bytesFromBase64(object.nodeTx) : new Uint8Array(0),
            refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
            vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
            verifyingPublicKey: isSet(object.verifyingPublicKey)
                ? bytesFromBase64(object.verifyingPublicKey)
                : new Uint8Array(0),
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            signingKeyshare: isSet(object.signingKeyshare) ? SigningKeyshare.fromJSON(object.signingKeyshare) : undefined,
            status: isSet(object.status) ? globalThis.String(object.status) : "",
            network: isSet(object.network) ? networkFromJSON(object.network) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.treeId !== "") {
            obj.treeId = message.treeId;
        }
        if (message.value !== 0) {
            obj.value = Math.round(message.value);
        }
        if (message.parentNodeId !== undefined) {
            obj.parentNodeId = message.parentNodeId;
        }
        if (message.nodeTx.length !== 0) {
            obj.nodeTx = base64FromBytes(message.nodeTx);
        }
        if (message.refundTx.length !== 0) {
            obj.refundTx = base64FromBytes(message.refundTx);
        }
        if (message.vout !== 0) {
            obj.vout = Math.round(message.vout);
        }
        if (message.verifyingPublicKey.length !== 0) {
            obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.signingKeyshare !== undefined) {
            obj.signingKeyshare = SigningKeyshare.toJSON(message.signingKeyshare);
        }
        if (message.status !== "") {
            obj.status = message.status;
        }
        if (message.network !== 0) {
            obj.network = networkToJSON(message.network);
        }
        return obj;
    },
    create(base) {
        return TreeNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTreeNode();
        message.id = object.id ?? "";
        message.treeId = object.treeId ?? "";
        message.value = object.value ?? 0;
        message.parentNodeId = object.parentNodeId ?? undefined;
        message.nodeTx = object.nodeTx ?? new Uint8Array(0);
        message.refundTx = object.refundTx ?? new Uint8Array(0);
        message.vout = object.vout ?? 0;
        message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.signingKeyshare = (object.signingKeyshare !== undefined && object.signingKeyshare !== null)
            ? SigningKeyshare.fromPartial(object.signingKeyshare)
            : undefined;
        message.status = object.status ?? "";
        message.network = object.network ?? 0;
        return message;
    },
};
function createBaseFinalizeNodeSignaturesRequest() {
    return { intent: 0, nodeSignatures: [] };
}
export const FinalizeNodeSignaturesRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.intent !== 0) {
            writer.uint32(8).int32(message.intent);
        }
        for (const v of message.nodeSignatures) {
            NodeSignatures.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFinalizeNodeSignaturesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.intent = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nodeSignatures.push(NodeSignatures.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            intent: isSet(object.intent) ? signatureIntentFromJSON(object.intent) : 0,
            nodeSignatures: globalThis.Array.isArray(object?.nodeSignatures)
                ? object.nodeSignatures.map((e) => NodeSignatures.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.intent !== 0) {
            obj.intent = signatureIntentToJSON(message.intent);
        }
        if (message.nodeSignatures?.length) {
            obj.nodeSignatures = message.nodeSignatures.map((e) => NodeSignatures.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FinalizeNodeSignaturesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFinalizeNodeSignaturesRequest();
        message.intent = object.intent ?? 0;
        message.nodeSignatures = object.nodeSignatures?.map((e) => NodeSignatures.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFinalizeNodeSignaturesResponse() {
    return { nodes: [] };
}
export const FinalizeNodeSignaturesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.nodes) {
            TreeNode.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFinalizeNodeSignaturesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodes.push(TreeNode.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e) => TreeNode.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodes?.length) {
            obj.nodes = message.nodes.map((e) => TreeNode.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FinalizeNodeSignaturesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFinalizeNodeSignaturesResponse();
        message.nodes = object.nodes?.map((e) => TreeNode.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSecretShare() {
    return { secretShare: new Uint8Array(0), proofs: [] };
}
export const SecretShare = {
    encode(message, writer = new BinaryWriter()) {
        if (message.secretShare.length !== 0) {
            writer.uint32(10).bytes(message.secretShare);
        }
        for (const v of message.proofs) {
            writer.uint32(18).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecretShare();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.secretShare = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.proofs.push(reader.bytes());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            secretShare: isSet(object.secretShare) ? bytesFromBase64(object.secretShare) : new Uint8Array(0),
            proofs: globalThis.Array.isArray(object?.proofs) ? object.proofs.map((e) => bytesFromBase64(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.secretShare.length !== 0) {
            obj.secretShare = base64FromBytes(message.secretShare);
        }
        if (message.proofs?.length) {
            obj.proofs = message.proofs.map((e) => base64FromBytes(e));
        }
        return obj;
    },
    create(base) {
        return SecretShare.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecretShare();
        message.secretShare = object.secretShare ?? new Uint8Array(0);
        message.proofs = object.proofs?.map((e) => e) || [];
        return message;
    },
};
function createBaseLeafRefundTxSigningJob() {
    return { leafId: "", refundTxSigningJob: undefined };
}
export const LeafRefundTxSigningJob = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.refundTxSigningJob !== undefined) {
            SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeafRefundTxSigningJob();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.refundTxSigningJob !== undefined) {
            obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
        }
        return obj;
    },
    create(base) {
        return LeafRefundTxSigningJob.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLeafRefundTxSigningJob();
        message.leafId = object.leafId ?? "";
        message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
            ? SigningJob.fromPartial(object.refundTxSigningJob)
            : undefined;
        return message;
    },
};
function createBaseLeafRefundTxSigningResult() {
    return { leafId: "", refundTxSigningResult: undefined, verifyingKey: new Uint8Array(0) };
}
export const LeafRefundTxSigningResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.refundTxSigningResult !== undefined) {
            SigningResult.encode(message.refundTxSigningResult, writer.uint32(18).fork()).join();
        }
        if (message.verifyingKey.length !== 0) {
            writer.uint32(26).bytes(message.verifyingKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeafRefundTxSigningResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.verifyingKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            refundTxSigningResult: isSet(object.refundTxSigningResult)
                ? SigningResult.fromJSON(object.refundTxSigningResult)
                : undefined,
            verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.refundTxSigningResult !== undefined) {
            obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
        }
        if (message.verifyingKey.length !== 0) {
            obj.verifyingKey = base64FromBytes(message.verifyingKey);
        }
        return obj;
    },
    create(base) {
        return LeafRefundTxSigningResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLeafRefundTxSigningResult();
        message.leafId = object.leafId ?? "";
        message.refundTxSigningResult =
            (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
                ? SigningResult.fromPartial(object.refundTxSigningResult)
                : undefined;
        message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseStartSendTransferRequest() {
    return {
        transferId: "",
        ownerIdentityPublicKey: new Uint8Array(0),
        leavesToSend: [],
        receiverIdentityPublicKey: new Uint8Array(0),
        expiryTime: undefined,
    };
}
export const StartSendTransferRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transferId !== "") {
            writer.uint32(10).string(message.transferId);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerIdentityPublicKey);
        }
        for (const v of message.leavesToSend) {
            LeafRefundTxSigningJob.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.receiverIdentityPublicKey.length !== 0) {
            writer.uint32(34).bytes(message.receiverIdentityPublicKey);
        }
        if (message.expiryTime !== undefined) {
            Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartSendTransferRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transferId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.leavesToSend.push(LeafRefundTxSigningJob.decode(reader, reader.uint32()));
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.receiverIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
                ? object.leavesToSend.map((e) => LeafRefundTxSigningJob.fromJSON(e))
                : [],
            receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
                ? bytesFromBase64(object.receiverIdentityPublicKey)
                : new Uint8Array(0),
            expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transferId !== "") {
            obj.transferId = message.transferId;
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.leavesToSend?.length) {
            obj.leavesToSend = message.leavesToSend.map((e) => LeafRefundTxSigningJob.toJSON(e));
        }
        if (message.receiverIdentityPublicKey.length !== 0) {
            obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
        }
        if (message.expiryTime !== undefined) {
            obj.expiryTime = message.expiryTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return StartSendTransferRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStartSendTransferRequest();
        message.transferId = object.transferId ?? "";
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.leavesToSend = object.leavesToSend?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) || [];
        message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
        message.expiryTime = object.expiryTime ?? undefined;
        return message;
    },
};
function createBaseStartSendTransferResponse() {
    return { transfer: undefined, signingResults: [] };
}
export const StartSendTransferResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        for (const v of message.signingResults) {
            LeafRefundTxSigningResult.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartSendTransferResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
            signingResults: globalThis.Array.isArray(object?.signingResults)
                ? object.signingResults.map((e) => LeafRefundTxSigningResult.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        if (message.signingResults?.length) {
            obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return StartSendTransferResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStartSendTransferResponse();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSendLeafKeyTweak() {
    return {
        leafId: "",
        secretShareTweak: undefined,
        pubkeySharesTweak: {},
        secretCipher: new Uint8Array(0),
        signature: new Uint8Array(0),
        refundSignature: new Uint8Array(0),
    };
}
export const SendLeafKeyTweak = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.secretShareTweak !== undefined) {
            SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
        }
        Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
            SendLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key, value }, writer.uint32(26).fork()).join();
        });
        if (message.secretCipher.length !== 0) {
            writer.uint32(34).bytes(message.secretCipher);
        }
        if (message.signature.length !== 0) {
            writer.uint32(42).bytes(message.signature);
        }
        if (message.refundSignature.length !== 0) {
            writer.uint32(50).bytes(message.refundSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendLeafKeyTweak();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = SendLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.pubkeySharesTweak[entry3.key] = entry3.value;
                    }
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.secretCipher = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.refundSignature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
            pubkeySharesTweak: isObject(object.pubkeySharesTweak)
                ? Object.entries(object.pubkeySharesTweak).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
            secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
            signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
            refundSignature: isSet(object.refundSignature) ? bytesFromBase64(object.refundSignature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.secretShareTweak !== undefined) {
            obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
        }
        if (message.pubkeySharesTweak) {
            const entries = Object.entries(message.pubkeySharesTweak);
            if (entries.length > 0) {
                obj.pubkeySharesTweak = {};
                entries.forEach(([k, v]) => {
                    obj.pubkeySharesTweak[k] = base64FromBytes(v);
                });
            }
        }
        if (message.secretCipher.length !== 0) {
            obj.secretCipher = base64FromBytes(message.secretCipher);
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes(message.signature);
        }
        if (message.refundSignature.length !== 0) {
            obj.refundSignature = base64FromBytes(message.refundSignature);
        }
        return obj;
    },
    create(base) {
        return SendLeafKeyTweak.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSendLeafKeyTweak();
        message.leafId = object.leafId ?? "";
        message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
            ? SecretShare.fromPartial(object.secretShareTweak)
            : undefined;
        message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.secretCipher = object.secretCipher ?? new Uint8Array(0);
        message.signature = object.signature ?? new Uint8Array(0);
        message.refundSignature = object.refundSignature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSendLeafKeyTweak_PubkeySharesTweakEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const SendLeafKeyTweak_PubkeySharesTweakEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return SendLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSendLeafKeyTweak_PubkeySharesTweakEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCompleteSendTransferRequest() {
    return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToSend: [] };
}
export const CompleteSendTransferRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transferId !== "") {
            writer.uint32(10).string(message.transferId);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerIdentityPublicKey);
        }
        for (const v of message.leavesToSend) {
            SendLeafKeyTweak.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompleteSendTransferRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transferId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.leavesToSend.push(SendLeafKeyTweak.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            leavesToSend: globalThis.Array.isArray(object?.leavesToSend)
                ? object.leavesToSend.map((e) => SendLeafKeyTweak.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transferId !== "") {
            obj.transferId = message.transferId;
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.leavesToSend?.length) {
            obj.leavesToSend = message.leavesToSend.map((e) => SendLeafKeyTweak.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CompleteSendTransferRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCompleteSendTransferRequest();
        message.transferId = object.transferId ?? "";
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.leavesToSend = object.leavesToSend?.map((e) => SendLeafKeyTweak.fromPartial(e)) || [];
        return message;
    },
};
function createBaseTransfer() {
    return {
        id: "",
        senderIdentityPublicKey: new Uint8Array(0),
        receiverIdentityPublicKey: new Uint8Array(0),
        status: 0,
        totalValue: 0,
        expiryTime: undefined,
        leaves: [],
    };
}
export const Transfer = {
    encode(message, writer = new BinaryWriter()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.senderIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.senderIdentityPublicKey);
        }
        if (message.receiverIdentityPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.receiverIdentityPublicKey);
        }
        if (message.status !== 0) {
            writer.uint32(32).int32(message.status);
        }
        if (message.totalValue !== 0) {
            writer.uint32(40).uint64(message.totalValue);
        }
        if (message.expiryTime !== undefined) {
            Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(50).fork()).join();
        }
        for (const v of message.leaves) {
            TransferLeaf.encode(v, writer.uint32(58).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransfer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.senderIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.receiverIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.totalValue = longToNumber(reader.uint64());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.leaves.push(TransferLeaf.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
                ? bytesFromBase64(object.senderIdentityPublicKey)
                : new Uint8Array(0),
            receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
                ? bytesFromBase64(object.receiverIdentityPublicKey)
                : new Uint8Array(0),
            status: isSet(object.status) ? transferStatusFromJSON(object.status) : 0,
            totalValue: isSet(object.totalValue) ? globalThis.Number(object.totalValue) : 0,
            expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
            leaves: globalThis.Array.isArray(object?.leaves) ? object.leaves.map((e) => TransferLeaf.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.senderIdentityPublicKey.length !== 0) {
            obj.senderIdentityPublicKey = base64FromBytes(message.senderIdentityPublicKey);
        }
        if (message.receiverIdentityPublicKey.length !== 0) {
            obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
        }
        if (message.status !== 0) {
            obj.status = transferStatusToJSON(message.status);
        }
        if (message.totalValue !== 0) {
            obj.totalValue = Math.round(message.totalValue);
        }
        if (message.expiryTime !== undefined) {
            obj.expiryTime = message.expiryTime.toISOString();
        }
        if (message.leaves?.length) {
            obj.leaves = message.leaves.map((e) => TransferLeaf.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Transfer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransfer();
        message.id = object.id ?? "";
        message.senderIdentityPublicKey = object.senderIdentityPublicKey ?? new Uint8Array(0);
        message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
        message.status = object.status ?? 0;
        message.totalValue = object.totalValue ?? 0;
        message.expiryTime = object.expiryTime ?? undefined;
        message.leaves = object.leaves?.map((e) => TransferLeaf.fromPartial(e)) || [];
        return message;
    },
};
function createBaseTransferLeaf() {
    return {
        leaf: undefined,
        secretCipher: new Uint8Array(0),
        signature: new Uint8Array(0),
        intermediateRefundTx: new Uint8Array(0),
    };
}
export const TransferLeaf = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leaf !== undefined) {
            TreeNode.encode(message.leaf, writer.uint32(10).fork()).join();
        }
        if (message.secretCipher.length !== 0) {
            writer.uint32(18).bytes(message.secretCipher);
        }
        if (message.signature.length !== 0) {
            writer.uint32(26).bytes(message.signature);
        }
        if (message.intermediateRefundTx.length !== 0) {
            writer.uint32(34).bytes(message.intermediateRefundTx);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferLeaf();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leaf = TreeNode.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.secretCipher = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.intermediateRefundTx = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leaf: isSet(object.leaf) ? TreeNode.fromJSON(object.leaf) : undefined,
            secretCipher: isSet(object.secretCipher) ? bytesFromBase64(object.secretCipher) : new Uint8Array(0),
            signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
            intermediateRefundTx: isSet(object.intermediateRefundTx)
                ? bytesFromBase64(object.intermediateRefundTx)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leaf !== undefined) {
            obj.leaf = TreeNode.toJSON(message.leaf);
        }
        if (message.secretCipher.length !== 0) {
            obj.secretCipher = base64FromBytes(message.secretCipher);
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes(message.signature);
        }
        if (message.intermediateRefundTx.length !== 0) {
            obj.intermediateRefundTx = base64FromBytes(message.intermediateRefundTx);
        }
        return obj;
    },
    create(base) {
        return TransferLeaf.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferLeaf();
        message.leaf = (object.leaf !== undefined && object.leaf !== null) ? TreeNode.fromPartial(object.leaf) : undefined;
        message.secretCipher = object.secretCipher ?? new Uint8Array(0);
        message.signature = object.signature ?? new Uint8Array(0);
        message.intermediateRefundTx = object.intermediateRefundTx ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCompleteSendTransferResponse() {
    return { transfer: undefined };
}
export const CompleteSendTransferResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCompleteSendTransferResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        return obj;
    },
    create(base) {
        return CompleteSendTransferResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCompleteSendTransferResponse();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        return message;
    },
};
function createBaseQueryPendingTransfersRequest() {
    return { participant: undefined, transferIds: [] };
}
export const QueryPendingTransfersRequest = {
    encode(message, writer = new BinaryWriter()) {
        switch (message.participant?.$case) {
            case "receiverIdentityPublicKey":
                writer.uint32(10).bytes(message.participant.receiverIdentityPublicKey);
                break;
            case "senderIdentityPublicKey":
                writer.uint32(18).bytes(message.participant.senderIdentityPublicKey);
                break;
        }
        for (const v of message.transferIds) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPendingTransfersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.participant = { $case: "receiverIdentityPublicKey", receiverIdentityPublicKey: reader.bytes() };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.participant = { $case: "senderIdentityPublicKey", senderIdentityPublicKey: reader.bytes() };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.transferIds.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            participant: isSet(object.receiverIdentityPublicKey)
                ? {
                    $case: "receiverIdentityPublicKey",
                    receiverIdentityPublicKey: bytesFromBase64(object.receiverIdentityPublicKey),
                }
                : isSet(object.senderIdentityPublicKey)
                    ? { $case: "senderIdentityPublicKey", senderIdentityPublicKey: bytesFromBase64(object.senderIdentityPublicKey) }
                    : undefined,
            transferIds: globalThis.Array.isArray(object?.transferIds)
                ? object.transferIds.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.participant?.$case === "receiverIdentityPublicKey") {
            obj.receiverIdentityPublicKey = base64FromBytes(message.participant.receiverIdentityPublicKey);
        }
        else if (message.participant?.$case === "senderIdentityPublicKey") {
            obj.senderIdentityPublicKey = base64FromBytes(message.participant.senderIdentityPublicKey);
        }
        if (message.transferIds?.length) {
            obj.transferIds = message.transferIds;
        }
        return obj;
    },
    create(base) {
        return QueryPendingTransfersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPendingTransfersRequest();
        switch (object.participant?.$case) {
            case "receiverIdentityPublicKey": {
                if (object.participant?.receiverIdentityPublicKey !== undefined &&
                    object.participant?.receiverIdentityPublicKey !== null) {
                    message.participant = {
                        $case: "receiverIdentityPublicKey",
                        receiverIdentityPublicKey: object.participant.receiverIdentityPublicKey,
                    };
                }
                break;
            }
            case "senderIdentityPublicKey": {
                if (object.participant?.senderIdentityPublicKey !== undefined &&
                    object.participant?.senderIdentityPublicKey !== null) {
                    message.participant = {
                        $case: "senderIdentityPublicKey",
                        senderIdentityPublicKey: object.participant.senderIdentityPublicKey,
                    };
                }
                break;
            }
        }
        message.transferIds = object.transferIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseQueryPendingTransfersResponse() {
    return { transfers: [] };
}
export const QueryPendingTransfersResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.transfers) {
            Transfer.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPendingTransfersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfers.push(Transfer.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfers: globalThis.Array.isArray(object?.transfers)
                ? object.transfers.map((e) => Transfer.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfers?.length) {
            obj.transfers = message.transfers.map((e) => Transfer.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return QueryPendingTransfersResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPendingTransfersResponse();
        message.transfers = object.transfers?.map((e) => Transfer.fromPartial(e)) || [];
        return message;
    },
};
function createBaseClaimLeafKeyTweak() {
    return { leafId: "", secretShareTweak: undefined, pubkeySharesTweak: {} };
}
export const ClaimLeafKeyTweak = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.secretShareTweak !== undefined) {
            SecretShare.encode(message.secretShareTweak, writer.uint32(18).fork()).join();
        }
        Object.entries(message.pubkeySharesTweak).forEach(([key, value]) => {
            ClaimLeafKeyTweak_PubkeySharesTweakEntry.encode({ key: key, value }, writer.uint32(26).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimLeafKeyTweak();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.secretShareTweak = SecretShare.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = ClaimLeafKeyTweak_PubkeySharesTweakEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.pubkeySharesTweak[entry3.key] = entry3.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            secretShareTweak: isSet(object.secretShareTweak) ? SecretShare.fromJSON(object.secretShareTweak) : undefined,
            pubkeySharesTweak: isObject(object.pubkeySharesTweak)
                ? Object.entries(object.pubkeySharesTweak).reduce((acc, [key, value]) => {
                    acc[key] = bytesFromBase64(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.secretShareTweak !== undefined) {
            obj.secretShareTweak = SecretShare.toJSON(message.secretShareTweak);
        }
        if (message.pubkeySharesTweak) {
            const entries = Object.entries(message.pubkeySharesTweak);
            if (entries.length > 0) {
                obj.pubkeySharesTweak = {};
                entries.forEach(([k, v]) => {
                    obj.pubkeySharesTweak[k] = base64FromBytes(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return ClaimLeafKeyTweak.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClaimLeafKeyTweak();
        message.leafId = object.leafId ?? "";
        message.secretShareTweak = (object.secretShareTweak !== undefined && object.secretShareTweak !== null)
            ? SecretShare.fromPartial(object.secretShareTweak)
            : undefined;
        message.pubkeySharesTweak = Object.entries(object.pubkeySharesTweak ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry() {
    return { key: "", value: new Uint8Array(0) };
}
export const ClaimLeafKeyTweak_PubkeySharesTweakEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes(message.value);
        }
        return obj;
    },
    create(base) {
        return ClaimLeafKeyTweak_PubkeySharesTweakEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClaimLeafKeyTweak_PubkeySharesTweakEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
function createBaseClaimTransferTweakKeysRequest() {
    return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), leavesToReceive: [] };
}
export const ClaimTransferTweakKeysRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transferId !== "") {
            writer.uint32(10).string(message.transferId);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerIdentityPublicKey);
        }
        for (const v of message.leavesToReceive) {
            ClaimLeafKeyTweak.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTransferTweakKeysRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transferId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.leavesToReceive.push(ClaimLeafKeyTweak.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            leavesToReceive: globalThis.Array.isArray(object?.leavesToReceive)
                ? object.leavesToReceive.map((e) => ClaimLeafKeyTweak.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transferId !== "") {
            obj.transferId = message.transferId;
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.leavesToReceive?.length) {
            obj.leavesToReceive = message.leavesToReceive.map((e) => ClaimLeafKeyTweak.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ClaimTransferTweakKeysRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClaimTransferTweakKeysRequest();
        message.transferId = object.transferId ?? "";
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.leavesToReceive = object.leavesToReceive?.map((e) => ClaimLeafKeyTweak.fromPartial(e)) || [];
        return message;
    },
};
function createBaseClaimTransferSignRefundsRequest() {
    return { transferId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: [] };
}
export const ClaimTransferSignRefundsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transferId !== "") {
            writer.uint32(10).string(message.transferId);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerIdentityPublicKey);
        }
        for (const v of message.signingJobs) {
            LeafRefundTxSigningJob.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTransferSignRefundsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transferId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signingJobs.push(LeafRefundTxSigningJob.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            signingJobs: globalThis.Array.isArray(object?.signingJobs)
                ? object.signingJobs.map((e) => LeafRefundTxSigningJob.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transferId !== "") {
            obj.transferId = message.transferId;
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.signingJobs?.length) {
            obj.signingJobs = message.signingJobs.map((e) => LeafRefundTxSigningJob.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ClaimTransferSignRefundsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClaimTransferSignRefundsRequest();
        message.transferId = object.transferId ?? "";
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.signingJobs = object.signingJobs?.map((e) => LeafRefundTxSigningJob.fromPartial(e)) || [];
        return message;
    },
};
function createBaseClaimTransferSignRefundsResponse() {
    return { signingResults: [] };
}
export const ClaimTransferSignRefundsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.signingResults) {
            LeafRefundTxSigningResult.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTransferSignRefundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingResults: globalThis.Array.isArray(object?.signingResults)
                ? object.signingResults.map((e) => LeafRefundTxSigningResult.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingResults?.length) {
            obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ClaimTransferSignRefundsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClaimTransferSignRefundsResponse();
        message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
        return message;
    },
};
function createBaseAggregateNodesRequest() {
    return { nodeIds: [], signingJob: undefined, ownerIdentityPublicKey: new Uint8Array(0) };
}
export const AggregateNodesRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.nodeIds) {
            writer.uint32(10).string(v);
        }
        if (message.signingJob !== undefined) {
            SigningJob.encode(message.signingJob, writer.uint32(18).fork()).join();
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.ownerIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAggregateNodesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeIds.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.signingJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e) => globalThis.String(e)) : [],
            signingJob: isSet(object.signingJob) ? SigningJob.fromJSON(object.signingJob) : undefined,
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeIds?.length) {
            obj.nodeIds = message.nodeIds;
        }
        if (message.signingJob !== undefined) {
            obj.signingJob = SigningJob.toJSON(message.signingJob);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return AggregateNodesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAggregateNodesRequest();
        message.nodeIds = object.nodeIds?.map((e) => e) || [];
        message.signingJob = (object.signingJob !== undefined && object.signingJob !== null)
            ? SigningJob.fromPartial(object.signingJob)
            : undefined;
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseAggregateNodesResponse() {
    return {
        aggregateSignature: undefined,
        verifyingKey: new Uint8Array(0),
        parentNodeTx: new Uint8Array(0),
        parentNodeVout: 0,
    };
}
export const AggregateNodesResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.aggregateSignature !== undefined) {
            SigningResult.encode(message.aggregateSignature, writer.uint32(10).fork()).join();
        }
        if (message.verifyingKey.length !== 0) {
            writer.uint32(18).bytes(message.verifyingKey);
        }
        if (message.parentNodeTx.length !== 0) {
            writer.uint32(26).bytes(message.parentNodeTx);
        }
        if (message.parentNodeVout !== 0) {
            writer.uint32(32).uint32(message.parentNodeVout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAggregateNodesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.aggregateSignature = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.verifyingKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.parentNodeTx = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.parentNodeVout = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            aggregateSignature: isSet(object.aggregateSignature)
                ? SigningResult.fromJSON(object.aggregateSignature)
                : undefined,
            verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
            parentNodeTx: isSet(object.parentNodeTx) ? bytesFromBase64(object.parentNodeTx) : new Uint8Array(0),
            parentNodeVout: isSet(object.parentNodeVout) ? globalThis.Number(object.parentNodeVout) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.aggregateSignature !== undefined) {
            obj.aggregateSignature = SigningResult.toJSON(message.aggregateSignature);
        }
        if (message.verifyingKey.length !== 0) {
            obj.verifyingKey = base64FromBytes(message.verifyingKey);
        }
        if (message.parentNodeTx.length !== 0) {
            obj.parentNodeTx = base64FromBytes(message.parentNodeTx);
        }
        if (message.parentNodeVout !== 0) {
            obj.parentNodeVout = Math.round(message.parentNodeVout);
        }
        return obj;
    },
    create(base) {
        return AggregateNodesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAggregateNodesResponse();
        message.aggregateSignature = (object.aggregateSignature !== undefined && object.aggregateSignature !== null)
            ? SigningResult.fromPartial(object.aggregateSignature)
            : undefined;
        message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
        message.parentNodeTx = object.parentNodeTx ?? new Uint8Array(0);
        message.parentNodeVout = object.parentNodeVout ?? 0;
        return message;
    },
};
function createBaseStorePreimageShareRequest() {
    return {
        paymentHash: new Uint8Array(0),
        preimageShare: undefined,
        threshold: 0,
        invoiceString: "",
        userIdentityPublicKey: new Uint8Array(0),
    };
}
export const StorePreimageShareRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.paymentHash.length !== 0) {
            writer.uint32(10).bytes(message.paymentHash);
        }
        if (message.preimageShare !== undefined) {
            SecretShare.encode(message.preimageShare, writer.uint32(18).fork()).join();
        }
        if (message.threshold !== 0) {
            writer.uint32(24).uint32(message.threshold);
        }
        if (message.invoiceString !== "") {
            writer.uint32(34).string(message.invoiceString);
        }
        if (message.userIdentityPublicKey.length !== 0) {
            writer.uint32(42).bytes(message.userIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStorePreimageShareRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paymentHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.preimageShare = SecretShare.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.threshold = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.invoiceString = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.userIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
            preimageShare: isSet(object.preimageShare) ? SecretShare.fromJSON(object.preimageShare) : undefined,
            threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
            invoiceString: isSet(object.invoiceString) ? globalThis.String(object.invoiceString) : "",
            userIdentityPublicKey: isSet(object.userIdentityPublicKey)
                ? bytesFromBase64(object.userIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paymentHash.length !== 0) {
            obj.paymentHash = base64FromBytes(message.paymentHash);
        }
        if (message.preimageShare !== undefined) {
            obj.preimageShare = SecretShare.toJSON(message.preimageShare);
        }
        if (message.threshold !== 0) {
            obj.threshold = Math.round(message.threshold);
        }
        if (message.invoiceString !== "") {
            obj.invoiceString = message.invoiceString;
        }
        if (message.userIdentityPublicKey.length !== 0) {
            obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return StorePreimageShareRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStorePreimageShareRequest();
        message.paymentHash = object.paymentHash ?? new Uint8Array(0);
        message.preimageShare = (object.preimageShare !== undefined && object.preimageShare !== null)
            ? SecretShare.fromPartial(object.preimageShare)
            : undefined;
        message.threshold = object.threshold ?? 0;
        message.invoiceString = object.invoiceString ?? "";
        message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRequestedSigningCommitments() {
    return { signingNonceCommitments: {} };
}
export const RequestedSigningCommitments = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.signingNonceCommitments).forEach(([key, value]) => {
            RequestedSigningCommitments_SigningNonceCommitmentsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestedSigningCommitments();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = RequestedSigningCommitments_SigningNonceCommitmentsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.signingNonceCommitments[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingNonceCommitments: isObject(object.signingNonceCommitments)
                ? Object.entries(object.signingNonceCommitments).reduce((acc, [key, value]) => {
                    acc[key] = SigningCommitment.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingNonceCommitments) {
            const entries = Object.entries(message.signingNonceCommitments);
            if (entries.length > 0) {
                obj.signingNonceCommitments = {};
                entries.forEach(([k, v]) => {
                    obj.signingNonceCommitments[k] = SigningCommitment.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return RequestedSigningCommitments.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestedSigningCommitments();
        message.signingNonceCommitments = Object.entries(object.signingNonceCommitments ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SigningCommitment.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry() {
    return { key: "", value: undefined };
}
export const RequestedSigningCommitments_SigningNonceCommitmentsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SigningCommitment.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SigningCommitment.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return RequestedSigningCommitments_SigningNonceCommitmentsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestedSigningCommitments_SigningNonceCommitmentsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SigningCommitment.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseGetSigningCommitmentsRequest() {
    return { nodeIds: [] };
}
export const GetSigningCommitmentsRequest = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.nodeIds) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSigningCommitmentsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeIds.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeIds?.length) {
            obj.nodeIds = message.nodeIds;
        }
        return obj;
    },
    create(base) {
        return GetSigningCommitmentsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSigningCommitmentsRequest();
        message.nodeIds = object.nodeIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseGetSigningCommitmentsResponse() {
    return { signingCommitments: [] };
}
export const GetSigningCommitmentsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.signingCommitments) {
            RequestedSigningCommitments.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSigningCommitmentsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingCommitments.push(RequestedSigningCommitments.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingCommitments: globalThis.Array.isArray(object?.signingCommitments)
                ? object.signingCommitments.map((e) => RequestedSigningCommitments.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingCommitments?.length) {
            obj.signingCommitments = message.signingCommitments.map((e) => RequestedSigningCommitments.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return GetSigningCommitmentsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSigningCommitmentsResponse();
        message.signingCommitments = object.signingCommitments?.map((e) => RequestedSigningCommitments.fromPartial(e)) ||
            [];
        return message;
    },
};
function createBaseSigningCommitments() {
    return { signingCommitments: {} };
}
export const SigningCommitments = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.signingCommitments).forEach(([key, value]) => {
            SigningCommitments_SigningCommitmentsEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningCommitments();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SigningCommitments_SigningCommitmentsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.signingCommitments[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingCommitments: isObject(object.signingCommitments)
                ? Object.entries(object.signingCommitments).reduce((acc, [key, value]) => {
                    acc[key] = SigningCommitment.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingCommitments) {
            const entries = Object.entries(message.signingCommitments);
            if (entries.length > 0) {
                obj.signingCommitments = {};
                entries.forEach(([k, v]) => {
                    obj.signingCommitments[k] = SigningCommitment.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return SigningCommitments.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningCommitments();
        message.signingCommitments = Object.entries(object.signingCommitments ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SigningCommitment.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSigningCommitments_SigningCommitmentsEntry() {
    return { key: "", value: undefined };
}
export const SigningCommitments_SigningCommitmentsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SigningCommitment.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningCommitments_SigningCommitmentsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SigningCommitment.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SigningCommitment.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SigningCommitment.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return SigningCommitments_SigningCommitmentsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningCommitments_SigningCommitmentsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SigningCommitment.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseUserSignedRefund() {
    return {
        nodeId: "",
        refundTx: new Uint8Array(0),
        userSignature: new Uint8Array(0),
        signingCommitments: undefined,
        userSignatureCommitment: undefined,
    };
}
export const UserSignedRefund = {
    encode(message, writer = new BinaryWriter()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.refundTx.length !== 0) {
            writer.uint32(18).bytes(message.refundTx);
        }
        if (message.userSignature.length !== 0) {
            writer.uint32(26).bytes(message.userSignature);
        }
        if (message.signingCommitments !== undefined) {
            SigningCommitments.encode(message.signingCommitments, writer.uint32(34).fork()).join();
        }
        if (message.userSignatureCommitment !== undefined) {
            SigningCommitment.encode(message.userSignatureCommitment, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserSignedRefund();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.refundTx = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.userSignature = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.signingCommitments = SigningCommitments.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.userSignatureCommitment = SigningCommitment.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            refundTx: isSet(object.refundTx) ? bytesFromBase64(object.refundTx) : new Uint8Array(0),
            userSignature: isSet(object.userSignature) ? bytesFromBase64(object.userSignature) : new Uint8Array(0),
            signingCommitments: isSet(object.signingCommitments)
                ? SigningCommitments.fromJSON(object.signingCommitments)
                : undefined,
            userSignatureCommitment: isSet(object.userSignatureCommitment)
                ? SigningCommitment.fromJSON(object.userSignatureCommitment)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.refundTx.length !== 0) {
            obj.refundTx = base64FromBytes(message.refundTx);
        }
        if (message.userSignature.length !== 0) {
            obj.userSignature = base64FromBytes(message.userSignature);
        }
        if (message.signingCommitments !== undefined) {
            obj.signingCommitments = SigningCommitments.toJSON(message.signingCommitments);
        }
        if (message.userSignatureCommitment !== undefined) {
            obj.userSignatureCommitment = SigningCommitment.toJSON(message.userSignatureCommitment);
        }
        return obj;
    },
    create(base) {
        return UserSignedRefund.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserSignedRefund();
        message.nodeId = object.nodeId ?? "";
        message.refundTx = object.refundTx ?? new Uint8Array(0);
        message.userSignature = object.userSignature ?? new Uint8Array(0);
        message.signingCommitments = (object.signingCommitments !== undefined && object.signingCommitments !== null)
            ? SigningCommitments.fromPartial(object.signingCommitments)
            : undefined;
        message.userSignatureCommitment =
            (object.userSignatureCommitment !== undefined && object.userSignatureCommitment !== null)
                ? SigningCommitment.fromPartial(object.userSignatureCommitment)
                : undefined;
        return message;
    },
};
function createBaseInvoiceAmountProof() {
    return { bolt11Invoice: "" };
}
export const InvoiceAmountProof = {
    encode(message, writer = new BinaryWriter()) {
        if (message.bolt11Invoice !== "") {
            writer.uint32(10).string(message.bolt11Invoice);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvoiceAmountProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.bolt11Invoice = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { bolt11Invoice: isSet(object.bolt11Invoice) ? globalThis.String(object.bolt11Invoice) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.bolt11Invoice !== "") {
            obj.bolt11Invoice = message.bolt11Invoice;
        }
        return obj;
    },
    create(base) {
        return InvoiceAmountProof.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInvoiceAmountProof();
        message.bolt11Invoice = object.bolt11Invoice ?? "";
        return message;
    },
};
function createBaseInvoiceAmount() {
    return { valueSats: 0, invoiceAmountProof: undefined };
}
export const InvoiceAmount = {
    encode(message, writer = new BinaryWriter()) {
        if (message.valueSats !== 0) {
            writer.uint32(8).uint64(message.valueSats);
        }
        if (message.invoiceAmountProof !== undefined) {
            InvoiceAmountProof.encode(message.invoiceAmountProof, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvoiceAmount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.valueSats = longToNumber(reader.uint64());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.invoiceAmountProof = InvoiceAmountProof.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            valueSats: isSet(object.valueSats) ? globalThis.Number(object.valueSats) : 0,
            invoiceAmountProof: isSet(object.invoiceAmountProof)
                ? InvoiceAmountProof.fromJSON(object.invoiceAmountProof)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.valueSats !== 0) {
            obj.valueSats = Math.round(message.valueSats);
        }
        if (message.invoiceAmountProof !== undefined) {
            obj.invoiceAmountProof = InvoiceAmountProof.toJSON(message.invoiceAmountProof);
        }
        return obj;
    },
    create(base) {
        return InvoiceAmount.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInvoiceAmount();
        message.valueSats = object.valueSats ?? 0;
        message.invoiceAmountProof = (object.invoiceAmountProof !== undefined && object.invoiceAmountProof !== null)
            ? InvoiceAmountProof.fromPartial(object.invoiceAmountProof)
            : undefined;
        return message;
    },
};
function createBaseInitiatePreimageSwapRequest() {
    return {
        paymentHash: new Uint8Array(0),
        userSignedRefunds: [],
        invoiceAmount: undefined,
        reason: 0,
        transfer: undefined,
        receiverIdentityPublicKey: new Uint8Array(0),
        feeSats: 0,
    };
}
export const InitiatePreimageSwapRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.paymentHash.length !== 0) {
            writer.uint32(10).bytes(message.paymentHash);
        }
        for (const v of message.userSignedRefunds) {
            UserSignedRefund.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.invoiceAmount !== undefined) {
            InvoiceAmount.encode(message.invoiceAmount, writer.uint32(26).fork()).join();
        }
        if (message.reason !== 0) {
            writer.uint32(32).int32(message.reason);
        }
        if (message.transfer !== undefined) {
            StartSendTransferRequest.encode(message.transfer, writer.uint32(42).fork()).join();
        }
        if (message.receiverIdentityPublicKey.length !== 0) {
            writer.uint32(50).bytes(message.receiverIdentityPublicKey);
        }
        if (message.feeSats !== 0) {
            writer.uint32(56).uint64(message.feeSats);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitiatePreimageSwapRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paymentHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.userSignedRefunds.push(UserSignedRefund.decode(reader, reader.uint32()));
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.invoiceAmount = InvoiceAmount.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.reason = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.transfer = StartSendTransferRequest.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.receiverIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.feeSats = longToNumber(reader.uint64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
            userSignedRefunds: globalThis.Array.isArray(object?.userSignedRefunds)
                ? object.userSignedRefunds.map((e) => UserSignedRefund.fromJSON(e))
                : [],
            invoiceAmount: isSet(object.invoiceAmount) ? InvoiceAmount.fromJSON(object.invoiceAmount) : undefined,
            reason: isSet(object.reason) ? initiatePreimageSwapRequest_ReasonFromJSON(object.reason) : 0,
            transfer: isSet(object.transfer) ? StartSendTransferRequest.fromJSON(object.transfer) : undefined,
            receiverIdentityPublicKey: isSet(object.receiverIdentityPublicKey)
                ? bytesFromBase64(object.receiverIdentityPublicKey)
                : new Uint8Array(0),
            feeSats: isSet(object.feeSats) ? globalThis.Number(object.feeSats) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paymentHash.length !== 0) {
            obj.paymentHash = base64FromBytes(message.paymentHash);
        }
        if (message.userSignedRefunds?.length) {
            obj.userSignedRefunds = message.userSignedRefunds.map((e) => UserSignedRefund.toJSON(e));
        }
        if (message.invoiceAmount !== undefined) {
            obj.invoiceAmount = InvoiceAmount.toJSON(message.invoiceAmount);
        }
        if (message.reason !== 0) {
            obj.reason = initiatePreimageSwapRequest_ReasonToJSON(message.reason);
        }
        if (message.transfer !== undefined) {
            obj.transfer = StartSendTransferRequest.toJSON(message.transfer);
        }
        if (message.receiverIdentityPublicKey.length !== 0) {
            obj.receiverIdentityPublicKey = base64FromBytes(message.receiverIdentityPublicKey);
        }
        if (message.feeSats !== 0) {
            obj.feeSats = Math.round(message.feeSats);
        }
        return obj;
    },
    create(base) {
        return InitiatePreimageSwapRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInitiatePreimageSwapRequest();
        message.paymentHash = object.paymentHash ?? new Uint8Array(0);
        message.userSignedRefunds = object.userSignedRefunds?.map((e) => UserSignedRefund.fromPartial(e)) || [];
        message.invoiceAmount = (object.invoiceAmount !== undefined && object.invoiceAmount !== null)
            ? InvoiceAmount.fromPartial(object.invoiceAmount)
            : undefined;
        message.reason = object.reason ?? 0;
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? StartSendTransferRequest.fromPartial(object.transfer)
            : undefined;
        message.receiverIdentityPublicKey = object.receiverIdentityPublicKey ?? new Uint8Array(0);
        message.feeSats = object.feeSats ?? 0;
        return message;
    },
};
function createBaseInitiatePreimageSwapResponse() {
    return { preimage: new Uint8Array(0), transfer: undefined };
}
export const InitiatePreimageSwapResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.preimage.length !== 0) {
            writer.uint32(10).bytes(message.preimage);
        }
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitiatePreimageSwapResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.preimage = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            preimage: isSet(object.preimage) ? bytesFromBase64(object.preimage) : new Uint8Array(0),
            transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.preimage.length !== 0) {
            obj.preimage = base64FromBytes(message.preimage);
        }
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        return obj;
    },
    create(base) {
        return InitiatePreimageSwapResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInitiatePreimageSwapResponse();
        message.preimage = object.preimage ?? new Uint8Array(0);
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        return message;
    },
};
function createBaseOutPoint() {
    return { txid: new Uint8Array(0), vout: 0 };
}
export const OutPoint = {
    encode(message, writer = new BinaryWriter()) {
        if (message.txid.length !== 0) {
            writer.uint32(10).bytes(message.txid);
        }
        if (message.vout !== 0) {
            writer.uint32(16).uint32(message.vout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutPoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.txid = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.vout = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            txid: isSet(object.txid) ? bytesFromBase64(object.txid) : new Uint8Array(0),
            vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.txid.length !== 0) {
            obj.txid = base64FromBytes(message.txid);
        }
        if (message.vout !== 0) {
            obj.vout = Math.round(message.vout);
        }
        return obj;
    },
    create(base) {
        return OutPoint.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutPoint();
        message.txid = object.txid ?? new Uint8Array(0);
        message.vout = object.vout ?? 0;
        return message;
    },
};
function createBaseCooperativeExitRequest() {
    return { transfer: undefined, exitId: "", exitTxid: new Uint8Array(0) };
}
export const CooperativeExitRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            StartSendTransferRequest.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        if (message.exitId !== "") {
            writer.uint32(18).string(message.exitId);
        }
        if (message.exitTxid.length !== 0) {
            writer.uint32(26).bytes(message.exitTxid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCooperativeExitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = StartSendTransferRequest.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.exitId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.exitTxid = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfer: isSet(object.transfer) ? StartSendTransferRequest.fromJSON(object.transfer) : undefined,
            exitId: isSet(object.exitId) ? globalThis.String(object.exitId) : "",
            exitTxid: isSet(object.exitTxid) ? bytesFromBase64(object.exitTxid) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = StartSendTransferRequest.toJSON(message.transfer);
        }
        if (message.exitId !== "") {
            obj.exitId = message.exitId;
        }
        if (message.exitTxid.length !== 0) {
            obj.exitTxid = base64FromBytes(message.exitTxid);
        }
        return obj;
    },
    create(base) {
        return CooperativeExitRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCooperativeExitRequest();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? StartSendTransferRequest.fromPartial(object.transfer)
            : undefined;
        message.exitId = object.exitId ?? "";
        message.exitTxid = object.exitTxid ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCooperativeExitResponse() {
    return { transfer: undefined, signingResults: [] };
}
export const CooperativeExitResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        for (const v of message.signingResults) {
            LeafRefundTxSigningResult.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCooperativeExitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
            signingResults: globalThis.Array.isArray(object?.signingResults)
                ? object.signingResults.map((e) => LeafRefundTxSigningResult.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        if (message.signingResults?.length) {
            obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CooperativeExitResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCooperativeExitResponse();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
        return message;
    },
};
function createBaseLeafSwapRequest() {
    return { transfer: undefined, swapId: "", adaptorPublicKey: new Uint8Array(0) };
}
export const LeafSwapRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            StartSendTransferRequest.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        if (message.swapId !== "") {
            writer.uint32(18).string(message.swapId);
        }
        if (message.adaptorPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.adaptorPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeafSwapRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = StartSendTransferRequest.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.swapId = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.adaptorPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfer: isSet(object.transfer) ? StartSendTransferRequest.fromJSON(object.transfer) : undefined,
            swapId: isSet(object.swapId) ? globalThis.String(object.swapId) : "",
            adaptorPublicKey: isSet(object.adaptorPublicKey) ? bytesFromBase64(object.adaptorPublicKey) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = StartSendTransferRequest.toJSON(message.transfer);
        }
        if (message.swapId !== "") {
            obj.swapId = message.swapId;
        }
        if (message.adaptorPublicKey.length !== 0) {
            obj.adaptorPublicKey = base64FromBytes(message.adaptorPublicKey);
        }
        return obj;
    },
    create(base) {
        return LeafSwapRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLeafSwapRequest();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? StartSendTransferRequest.fromPartial(object.transfer)
            : undefined;
        message.swapId = object.swapId ?? "";
        message.adaptorPublicKey = object.adaptorPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseLeafSwapResponse() {
    return { transfer: undefined, signingResults: [] };
}
export const LeafSwapResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        for (const v of message.signingResults) {
            LeafRefundTxSigningResult.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLeafSwapResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.signingResults.push(LeafRefundTxSigningResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined,
            signingResults: globalThis.Array.isArray(object?.signingResults)
                ? object.signingResults.map((e) => LeafRefundTxSigningResult.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        if (message.signingResults?.length) {
            obj.signingResults = message.signingResults.map((e) => LeafRefundTxSigningResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return LeafSwapResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLeafSwapResponse();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        message.signingResults = object.signingResults?.map((e) => LeafRefundTxSigningResult.fromPartial(e)) || [];
        return message;
    },
};
function createBaseRefreshTimelockRequest() {
    return { leafId: "", ownerIdentityPublicKey: new Uint8Array(0), signingJobs: [] };
}
export const RefreshTimelockRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerIdentityPublicKey);
        }
        for (const v of message.signingJobs) {
            SigningJob.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshTimelockRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signingJobs.push(SigningJob.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            signingJobs: globalThis.Array.isArray(object?.signingJobs)
                ? object.signingJobs.map((e) => SigningJob.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.signingJobs?.length) {
            obj.signingJobs = message.signingJobs.map((e) => SigningJob.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return RefreshTimelockRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRefreshTimelockRequest();
        message.leafId = object.leafId ?? "";
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.signingJobs = object.signingJobs?.map((e) => SigningJob.fromPartial(e)) || [];
        return message;
    },
};
function createBaseRefreshTimelockSigningResult() {
    return { signingResult: undefined, verifyingKey: new Uint8Array(0) };
}
export const RefreshTimelockSigningResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.signingResult !== undefined) {
            SigningResult.encode(message.signingResult, writer.uint32(10).fork()).join();
        }
        if (message.verifyingKey.length !== 0) {
            writer.uint32(18).bytes(message.verifyingKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshTimelockSigningResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.verifyingKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingResult: isSet(object.signingResult) ? SigningResult.fromJSON(object.signingResult) : undefined,
            verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingResult !== undefined) {
            obj.signingResult = SigningResult.toJSON(message.signingResult);
        }
        if (message.verifyingKey.length !== 0) {
            obj.verifyingKey = base64FromBytes(message.verifyingKey);
        }
        return obj;
    },
    create(base) {
        return RefreshTimelockSigningResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRefreshTimelockSigningResult();
        message.signingResult = (object.signingResult !== undefined && object.signingResult !== null)
            ? SigningResult.fromPartial(object.signingResult)
            : undefined;
        message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRefreshTimelockResponse() {
    return { signingResults: [] };
}
export const RefreshTimelockResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.signingResults) {
            RefreshTimelockSigningResult.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRefreshTimelockResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingResults.push(RefreshTimelockSigningResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingResults: globalThis.Array.isArray(object?.signingResults)
                ? object.signingResults.map((e) => RefreshTimelockSigningResult.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingResults?.length) {
            obj.signingResults = message.signingResults.map((e) => RefreshTimelockSigningResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return RefreshTimelockResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRefreshTimelockResponse();
        message.signingResults = object.signingResults?.map((e) => RefreshTimelockSigningResult.fromPartial(e)) || [];
        return message;
    },
};
function createBaseExtendLeafRequest() {
    return {
        leafId: "",
        ownerIdentityPublicKey: new Uint8Array(0),
        nodeTxSigningJob: undefined,
        refundTxSigningJob: undefined,
    };
}
export const ExtendLeafRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.ownerIdentityPublicKey);
        }
        if (message.nodeTxSigningJob !== undefined) {
            SigningJob.encode(message.nodeTxSigningJob, writer.uint32(26).fork()).join();
        }
        if (message.refundTxSigningJob !== undefined) {
            SigningJob.encode(message.refundTxSigningJob, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendLeafRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerIdentityPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            ownerIdentityPublicKey: isSet(object.ownerIdentityPublicKey)
                ? bytesFromBase64(object.ownerIdentityPublicKey)
                : new Uint8Array(0),
            nodeTxSigningJob: isSet(object.nodeTxSigningJob) ? SigningJob.fromJSON(object.nodeTxSigningJob) : undefined,
            refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.ownerIdentityPublicKey.length !== 0) {
            obj.ownerIdentityPublicKey = base64FromBytes(message.ownerIdentityPublicKey);
        }
        if (message.nodeTxSigningJob !== undefined) {
            obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
        }
        if (message.refundTxSigningJob !== undefined) {
            obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
        }
        return obj;
    },
    create(base) {
        return ExtendLeafRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExtendLeafRequest();
        message.leafId = object.leafId ?? "";
        message.ownerIdentityPublicKey = object.ownerIdentityPublicKey ?? new Uint8Array(0);
        message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
            ? SigningJob.fromPartial(object.nodeTxSigningJob)
            : undefined;
        message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
            ? SigningJob.fromPartial(object.refundTxSigningJob)
            : undefined;
        return message;
    },
};
function createBaseExtendLeafSigningResult() {
    return { signingResult: undefined, verifyingKey: new Uint8Array(0) };
}
export const ExtendLeafSigningResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.signingResult !== undefined) {
            SigningResult.encode(message.signingResult, writer.uint32(10).fork()).join();
        }
        if (message.verifyingKey.length !== 0) {
            writer.uint32(18).bytes(message.verifyingKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendLeafSigningResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.signingResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.verifyingKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingResult: isSet(object.signingResult) ? SigningResult.fromJSON(object.signingResult) : undefined,
            verifyingKey: isSet(object.verifyingKey) ? bytesFromBase64(object.verifyingKey) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingResult !== undefined) {
            obj.signingResult = SigningResult.toJSON(message.signingResult);
        }
        if (message.verifyingKey.length !== 0) {
            obj.verifyingKey = base64FromBytes(message.verifyingKey);
        }
        return obj;
    },
    create(base) {
        return ExtendLeafSigningResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExtendLeafSigningResult();
        message.signingResult = (object.signingResult !== undefined && object.signingResult !== null)
            ? SigningResult.fromPartial(object.signingResult)
            : undefined;
        message.verifyingKey = object.verifyingKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseExtendLeafResponse() {
    return { leafId: "", nodeTxSigningResult: undefined, refundTxSigningResult: undefined };
}
export const ExtendLeafResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.leafId !== "") {
            writer.uint32(10).string(message.leafId);
        }
        if (message.nodeTxSigningResult !== undefined) {
            ExtendLeafSigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
        }
        if (message.refundTxSigningResult !== undefined) {
            ExtendLeafSigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExtendLeafResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.leafId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nodeTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.refundTxSigningResult = ExtendLeafSigningResult.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            leafId: isSet(object.leafId) ? globalThis.String(object.leafId) : "",
            nodeTxSigningResult: isSet(object.nodeTxSigningResult)
                ? ExtendLeafSigningResult.fromJSON(object.nodeTxSigningResult)
                : undefined,
            refundTxSigningResult: isSet(object.refundTxSigningResult)
                ? ExtendLeafSigningResult.fromJSON(object.refundTxSigningResult)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.leafId !== "") {
            obj.leafId = message.leafId;
        }
        if (message.nodeTxSigningResult !== undefined) {
            obj.nodeTxSigningResult = ExtendLeafSigningResult.toJSON(message.nodeTxSigningResult);
        }
        if (message.refundTxSigningResult !== undefined) {
            obj.refundTxSigningResult = ExtendLeafSigningResult.toJSON(message.refundTxSigningResult);
        }
        return obj;
    },
    create(base) {
        return ExtendLeafResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExtendLeafResponse();
        message.leafId = object.leafId ?? "";
        message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
            ? ExtendLeafSigningResult.fromPartial(object.nodeTxSigningResult)
            : undefined;
        message.refundTxSigningResult =
            (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
                ? ExtendLeafSigningResult.fromPartial(object.refundTxSigningResult)
                : undefined;
        return message;
    },
};
function createBaseAddressRequestNode() {
    return { userPublicKey: new Uint8Array(0), children: [] };
}
export const AddressRequestNode = {
    encode(message, writer = new BinaryWriter()) {
        if (message.userPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.userPublicKey);
        }
        for (const v of message.children) {
            AddressRequestNode.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressRequestNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.userPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.children.push(AddressRequestNode.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userPublicKey: isSet(object.userPublicKey) ? bytesFromBase64(object.userPublicKey) : new Uint8Array(0),
            children: globalThis.Array.isArray(object?.children)
                ? object.children.map((e) => AddressRequestNode.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userPublicKey.length !== 0) {
            obj.userPublicKey = base64FromBytes(message.userPublicKey);
        }
        if (message.children?.length) {
            obj.children = message.children.map((e) => AddressRequestNode.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return AddressRequestNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddressRequestNode();
        message.userPublicKey = object.userPublicKey ?? new Uint8Array(0);
        message.children = object.children?.map((e) => AddressRequestNode.fromPartial(e)) || [];
        return message;
    },
};
function createBasePrepareTreeAddressRequest() {
    return { source: undefined, node: undefined, userIdentityPublicKey: new Uint8Array(0) };
}
export const PrepareTreeAddressRequest = {
    encode(message, writer = new BinaryWriter()) {
        switch (message.source?.$case) {
            case "parentNodeOutput":
                NodeOutput.encode(message.source.parentNodeOutput, writer.uint32(10).fork()).join();
                break;
            case "onChainUtxo":
                UTXO.encode(message.source.onChainUtxo, writer.uint32(18).fork()).join();
                break;
        }
        if (message.node !== undefined) {
            AddressRequestNode.encode(message.node, writer.uint32(26).fork()).join();
        }
        if (message.userIdentityPublicKey.length !== 0) {
            writer.uint32(34).bytes(message.userIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrepareTreeAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.source = { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.decode(reader, reader.uint32()) };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.decode(reader, reader.uint32()) };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.node = AddressRequestNode.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.userIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            source: isSet(object.parentNodeOutput)
                ? { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.fromJSON(object.parentNodeOutput) }
                : isSet(object.onChainUtxo)
                    ? { $case: "onChainUtxo", onChainUtxo: UTXO.fromJSON(object.onChainUtxo) }
                    : undefined,
            node: isSet(object.node) ? AddressRequestNode.fromJSON(object.node) : undefined,
            userIdentityPublicKey: isSet(object.userIdentityPublicKey)
                ? bytesFromBase64(object.userIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source?.$case === "parentNodeOutput") {
            obj.parentNodeOutput = NodeOutput.toJSON(message.source.parentNodeOutput);
        }
        else if (message.source?.$case === "onChainUtxo") {
            obj.onChainUtxo = UTXO.toJSON(message.source.onChainUtxo);
        }
        if (message.node !== undefined) {
            obj.node = AddressRequestNode.toJSON(message.node);
        }
        if (message.userIdentityPublicKey.length !== 0) {
            obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return PrepareTreeAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePrepareTreeAddressRequest();
        switch (object.source?.$case) {
            case "parentNodeOutput": {
                if (object.source?.parentNodeOutput !== undefined && object.source?.parentNodeOutput !== null) {
                    message.source = {
                        $case: "parentNodeOutput",
                        parentNodeOutput: NodeOutput.fromPartial(object.source.parentNodeOutput),
                    };
                }
                break;
            }
            case "onChainUtxo": {
                if (object.source?.onChainUtxo !== undefined && object.source?.onChainUtxo !== null) {
                    message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.fromPartial(object.source.onChainUtxo) };
                }
                break;
            }
        }
        message.node = (object.node !== undefined && object.node !== null)
            ? AddressRequestNode.fromPartial(object.node)
            : undefined;
        message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseAddressNode() {
    return { address: undefined, children: [] };
}
export const AddressNode = {
    encode(message, writer = new BinaryWriter()) {
        if (message.address !== undefined) {
            Address.encode(message.address, writer.uint32(10).fork()).join();
        }
        for (const v of message.children) {
            AddressNode.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.address = Address.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.children.push(AddressNode.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? Address.fromJSON(object.address) : undefined,
            children: globalThis.Array.isArray(object?.children)
                ? object.children.map((e) => AddressNode.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== undefined) {
            obj.address = Address.toJSON(message.address);
        }
        if (message.children?.length) {
            obj.children = message.children.map((e) => AddressNode.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return AddressNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddressNode();
        message.address = (object.address !== undefined && object.address !== null)
            ? Address.fromPartial(object.address)
            : undefined;
        message.children = object.children?.map((e) => AddressNode.fromPartial(e)) || [];
        return message;
    },
};
function createBasePrepareTreeAddressResponse() {
    return { node: undefined };
}
export const PrepareTreeAddressResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.node !== undefined) {
            AddressNode.encode(message.node, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrepareTreeAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.node = AddressNode.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { node: isSet(object.node) ? AddressNode.fromJSON(object.node) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.node !== undefined) {
            obj.node = AddressNode.toJSON(message.node);
        }
        return obj;
    },
    create(base) {
        return PrepareTreeAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePrepareTreeAddressResponse();
        message.node = (object.node !== undefined && object.node !== null)
            ? AddressNode.fromPartial(object.node)
            : undefined;
        return message;
    },
};
function createBaseCreationNode() {
    return { nodeTxSigningJob: undefined, refundTxSigningJob: undefined, children: [] };
}
export const CreationNode = {
    encode(message, writer = new BinaryWriter()) {
        if (message.nodeTxSigningJob !== undefined) {
            SigningJob.encode(message.nodeTxSigningJob, writer.uint32(10).fork()).join();
        }
        if (message.refundTxSigningJob !== undefined) {
            SigningJob.encode(message.refundTxSigningJob, writer.uint32(18).fork()).join();
        }
        for (const v of message.children) {
            CreationNode.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreationNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.refundTxSigningJob = SigningJob.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.children.push(CreationNode.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeTxSigningJob: isSet(object.nodeTxSigningJob) ? SigningJob.fromJSON(object.nodeTxSigningJob) : undefined,
            refundTxSigningJob: isSet(object.refundTxSigningJob) ? SigningJob.fromJSON(object.refundTxSigningJob) : undefined,
            children: globalThis.Array.isArray(object?.children)
                ? object.children.map((e) => CreationNode.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeTxSigningJob !== undefined) {
            obj.nodeTxSigningJob = SigningJob.toJSON(message.nodeTxSigningJob);
        }
        if (message.refundTxSigningJob !== undefined) {
            obj.refundTxSigningJob = SigningJob.toJSON(message.refundTxSigningJob);
        }
        if (message.children?.length) {
            obj.children = message.children.map((e) => CreationNode.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreationNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreationNode();
        message.nodeTxSigningJob = (object.nodeTxSigningJob !== undefined && object.nodeTxSigningJob !== null)
            ? SigningJob.fromPartial(object.nodeTxSigningJob)
            : undefined;
        message.refundTxSigningJob = (object.refundTxSigningJob !== undefined && object.refundTxSigningJob !== null)
            ? SigningJob.fromPartial(object.refundTxSigningJob)
            : undefined;
        message.children = object.children?.map((e) => CreationNode.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateTreeRequest() {
    return { source: undefined, node: undefined, userIdentityPublicKey: new Uint8Array(0) };
}
export const CreateTreeRequest = {
    encode(message, writer = new BinaryWriter()) {
        switch (message.source?.$case) {
            case "parentNodeOutput":
                NodeOutput.encode(message.source.parentNodeOutput, writer.uint32(10).fork()).join();
                break;
            case "onChainUtxo":
                UTXO.encode(message.source.onChainUtxo, writer.uint32(18).fork()).join();
                break;
        }
        if (message.node !== undefined) {
            CreationNode.encode(message.node, writer.uint32(26).fork()).join();
        }
        if (message.userIdentityPublicKey.length !== 0) {
            writer.uint32(34).bytes(message.userIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateTreeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.source = { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.decode(reader, reader.uint32()) };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.decode(reader, reader.uint32()) };
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.node = CreationNode.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.userIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            source: isSet(object.parentNodeOutput)
                ? { $case: "parentNodeOutput", parentNodeOutput: NodeOutput.fromJSON(object.parentNodeOutput) }
                : isSet(object.onChainUtxo)
                    ? { $case: "onChainUtxo", onChainUtxo: UTXO.fromJSON(object.onChainUtxo) }
                    : undefined,
            node: isSet(object.node) ? CreationNode.fromJSON(object.node) : undefined,
            userIdentityPublicKey: isSet(object.userIdentityPublicKey)
                ? bytesFromBase64(object.userIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source?.$case === "parentNodeOutput") {
            obj.parentNodeOutput = NodeOutput.toJSON(message.source.parentNodeOutput);
        }
        else if (message.source?.$case === "onChainUtxo") {
            obj.onChainUtxo = UTXO.toJSON(message.source.onChainUtxo);
        }
        if (message.node !== undefined) {
            obj.node = CreationNode.toJSON(message.node);
        }
        if (message.userIdentityPublicKey.length !== 0) {
            obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return CreateTreeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateTreeRequest();
        switch (object.source?.$case) {
            case "parentNodeOutput": {
                if (object.source?.parentNodeOutput !== undefined && object.source?.parentNodeOutput !== null) {
                    message.source = {
                        $case: "parentNodeOutput",
                        parentNodeOutput: NodeOutput.fromPartial(object.source.parentNodeOutput),
                    };
                }
                break;
            }
            case "onChainUtxo": {
                if (object.source?.onChainUtxo !== undefined && object.source?.onChainUtxo !== null) {
                    message.source = { $case: "onChainUtxo", onChainUtxo: UTXO.fromPartial(object.source.onChainUtxo) };
                }
                break;
            }
        }
        message.node = (object.node !== undefined && object.node !== null)
            ? CreationNode.fromPartial(object.node)
            : undefined;
        message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCreationResponseNode() {
    return { nodeId: "", nodeTxSigningResult: undefined, refundTxSigningResult: undefined, children: [] };
}
export const CreationResponseNode = {
    encode(message, writer = new BinaryWriter()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.nodeTxSigningResult !== undefined) {
            SigningResult.encode(message.nodeTxSigningResult, writer.uint32(18).fork()).join();
        }
        if (message.refundTxSigningResult !== undefined) {
            SigningResult.encode(message.refundTxSigningResult, writer.uint32(26).fork()).join();
        }
        for (const v of message.children) {
            CreationResponseNode.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreationResponseNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.nodeTxSigningResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.refundTxSigningResult = SigningResult.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.children.push(CreationResponseNode.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            nodeTxSigningResult: isSet(object.nodeTxSigningResult)
                ? SigningResult.fromJSON(object.nodeTxSigningResult)
                : undefined,
            refundTxSigningResult: isSet(object.refundTxSigningResult)
                ? SigningResult.fromJSON(object.refundTxSigningResult)
                : undefined,
            children: globalThis.Array.isArray(object?.children)
                ? object.children.map((e) => CreationResponseNode.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.nodeTxSigningResult !== undefined) {
            obj.nodeTxSigningResult = SigningResult.toJSON(message.nodeTxSigningResult);
        }
        if (message.refundTxSigningResult !== undefined) {
            obj.refundTxSigningResult = SigningResult.toJSON(message.refundTxSigningResult);
        }
        if (message.children?.length) {
            obj.children = message.children.map((e) => CreationResponseNode.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CreationResponseNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreationResponseNode();
        message.nodeId = object.nodeId ?? "";
        message.nodeTxSigningResult = (object.nodeTxSigningResult !== undefined && object.nodeTxSigningResult !== null)
            ? SigningResult.fromPartial(object.nodeTxSigningResult)
            : undefined;
        message.refundTxSigningResult =
            (object.refundTxSigningResult !== undefined && object.refundTxSigningResult !== null)
                ? SigningResult.fromPartial(object.refundTxSigningResult)
                : undefined;
        message.children = object.children?.map((e) => CreationResponseNode.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCreateTreeResponse() {
    return { node: undefined };
}
export const CreateTreeResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.node !== undefined) {
            CreationResponseNode.encode(message.node, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateTreeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.node = CreationResponseNode.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { node: isSet(object.node) ? CreationResponseNode.fromJSON(object.node) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.node !== undefined) {
            obj.node = CreationResponseNode.toJSON(message.node);
        }
        return obj;
    },
    create(base) {
        return CreateTreeResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCreateTreeResponse();
        message.node = (object.node !== undefined && object.node !== null)
            ? CreationResponseNode.fromPartial(object.node)
            : undefined;
        return message;
    },
};
function createBaseSigningOperatorInfo() {
    return { index: 0, identifier: "", publicKey: new Uint8Array(0), address: "" };
}
export const SigningOperatorInfo = {
    encode(message, writer = new BinaryWriter()) {
        if (message.index !== 0) {
            writer.uint32(8).uint64(message.index);
        }
        if (message.identifier !== "") {
            writer.uint32(18).string(message.identifier);
        }
        if (message.publicKey.length !== 0) {
            writer.uint32(26).bytes(message.publicKey);
        }
        if (message.address !== "") {
            writer.uint32(34).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSigningOperatorInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.index = longToNumber(reader.uint64());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.identifier = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.publicKey = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet(object.index) ? globalThis.Number(object.index) : 0,
            identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
            publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
            address: isSet(object.address) ? globalThis.String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.identifier !== "") {
            obj.identifier = message.identifier;
        }
        if (message.publicKey.length !== 0) {
            obj.publicKey = base64FromBytes(message.publicKey);
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return SigningOperatorInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSigningOperatorInfo();
        message.index = object.index ?? 0;
        message.identifier = object.identifier ?? "";
        message.publicKey = object.publicKey ?? new Uint8Array(0);
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseGetSigningOperatorListResponse() {
    return { signingOperators: {} };
}
export const GetSigningOperatorListResponse = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.signingOperators).forEach(([key, value]) => {
            GetSigningOperatorListResponse_SigningOperatorsEntry.encode({ key: key, value }, writer.uint32(10).fork())
                .join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSigningOperatorListResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = GetSigningOperatorListResponse_SigningOperatorsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.signingOperators[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signingOperators: isObject(object.signingOperators)
                ? Object.entries(object.signingOperators).reduce((acc, [key, value]) => {
                    acc[key] = SigningOperatorInfo.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signingOperators) {
            const entries = Object.entries(message.signingOperators);
            if (entries.length > 0) {
                obj.signingOperators = {};
                entries.forEach(([k, v]) => {
                    obj.signingOperators[k] = SigningOperatorInfo.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return GetSigningOperatorListResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSigningOperatorListResponse();
        message.signingOperators = Object.entries(object.signingOperators ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SigningOperatorInfo.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseGetSigningOperatorListResponse_SigningOperatorsEntry() {
    return { key: "", value: undefined };
}
export const GetSigningOperatorListResponse_SigningOperatorsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SigningOperatorInfo.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SigningOperatorInfo.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SigningOperatorInfo.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SigningOperatorInfo.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return GetSigningOperatorListResponse_SigningOperatorsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGetSigningOperatorListResponse_SigningOperatorsEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SigningOperatorInfo.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseQueryUserSignedRefundsRequest() {
    return { paymentHash: new Uint8Array(0), identityPublicKey: new Uint8Array(0) };
}
export const QueryUserSignedRefundsRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.paymentHash.length !== 0) {
            writer.uint32(10).bytes(message.paymentHash);
        }
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.identityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUserSignedRefundsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paymentHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paymentHash.length !== 0) {
            obj.paymentHash = base64FromBytes(message.paymentHash);
        }
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        return obj;
    },
    create(base) {
        return QueryUserSignedRefundsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryUserSignedRefundsRequest();
        message.paymentHash = object.paymentHash ?? new Uint8Array(0);
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseQueryUserSignedRefundsResponse() {
    return { userSignedRefunds: [] };
}
export const QueryUserSignedRefundsResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.userSignedRefunds) {
            UserSignedRefund.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUserSignedRefundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.userSignedRefunds.push(UserSignedRefund.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userSignedRefunds: globalThis.Array.isArray(object?.userSignedRefunds)
                ? object.userSignedRefunds.map((e) => UserSignedRefund.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userSignedRefunds?.length) {
            obj.userSignedRefunds = message.userSignedRefunds.map((e) => UserSignedRefund.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return QueryUserSignedRefundsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryUserSignedRefundsResponse();
        message.userSignedRefunds = object.userSignedRefunds?.map((e) => UserSignedRefund.fromPartial(e)) || [];
        return message;
    },
};
function createBaseProvidePreimageRequest() {
    return { paymentHash: new Uint8Array(0), preimage: new Uint8Array(0), identityPublicKey: new Uint8Array(0) };
}
export const ProvidePreimageRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.paymentHash.length !== 0) {
            writer.uint32(10).bytes(message.paymentHash);
        }
        if (message.preimage.length !== 0) {
            writer.uint32(18).bytes(message.preimage);
        }
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.identityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProvidePreimageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paymentHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.preimage = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
            preimage: isSet(object.preimage) ? bytesFromBase64(object.preimage) : new Uint8Array(0),
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paymentHash.length !== 0) {
            obj.paymentHash = base64FromBytes(message.paymentHash);
        }
        if (message.preimage.length !== 0) {
            obj.preimage = base64FromBytes(message.preimage);
        }
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        return obj;
    },
    create(base) {
        return ProvidePreimageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProvidePreimageRequest();
        message.paymentHash = object.paymentHash ?? new Uint8Array(0);
        message.preimage = object.preimage ?? new Uint8Array(0);
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseProvidePreimageResponse() {
    return { transfer: undefined };
}
export const ProvidePreimageResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProvidePreimageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        return obj;
    },
    create(base) {
        return ProvidePreimageResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProvidePreimageResponse();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        return message;
    },
};
function createBaseReturnLightningPaymentRequest() {
    return { paymentHash: new Uint8Array(0), userIdentityPublicKey: new Uint8Array(0) };
}
export const ReturnLightningPaymentRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.paymentHash.length !== 0) {
            writer.uint32(10).bytes(message.paymentHash);
        }
        if (message.userIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.userIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReturnLightningPaymentRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.paymentHash = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.userIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            paymentHash: isSet(object.paymentHash) ? bytesFromBase64(object.paymentHash) : new Uint8Array(0),
            userIdentityPublicKey: isSet(object.userIdentityPublicKey)
                ? bytesFromBase64(object.userIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.paymentHash.length !== 0) {
            obj.paymentHash = base64FromBytes(message.paymentHash);
        }
        if (message.userIdentityPublicKey.length !== 0) {
            obj.userIdentityPublicKey = base64FromBytes(message.userIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return ReturnLightningPaymentRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseReturnLightningPaymentRequest();
        message.paymentHash = object.paymentHash ?? new Uint8Array(0);
        message.userIdentityPublicKey = object.userIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseTreeNodeIds() {
    return { nodeIds: [] };
}
export const TreeNodeIds = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.nodeIds) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTreeNodeIds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeIds.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeIds: globalThis.Array.isArray(object?.nodeIds) ? object.nodeIds.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeIds?.length) {
            obj.nodeIds = message.nodeIds;
        }
        return obj;
    },
    create(base) {
        return TreeNodeIds.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTreeNodeIds();
        message.nodeIds = object.nodeIds?.map((e) => e) || [];
        return message;
    },
};
function createBaseQueryNodesRequest() {
    return { source: undefined, includeParents: false };
}
export const QueryNodesRequest = {
    encode(message, writer = new BinaryWriter()) {
        switch (message.source?.$case) {
            case "ownerIdentityPubkey":
                writer.uint32(10).bytes(message.source.ownerIdentityPubkey);
                break;
            case "nodeIds":
                TreeNodeIds.encode(message.source.nodeIds, writer.uint32(18).fork()).join();
                break;
        }
        if (message.includeParents !== false) {
            writer.uint32(24).bool(message.includeParents);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNodesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.source = { $case: "ownerIdentityPubkey", ownerIdentityPubkey: reader.bytes() };
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.source = { $case: "nodeIds", nodeIds: TreeNodeIds.decode(reader, reader.uint32()) };
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.includeParents = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            source: isSet(object.ownerIdentityPubkey)
                ? { $case: "ownerIdentityPubkey", ownerIdentityPubkey: bytesFromBase64(object.ownerIdentityPubkey) }
                : isSet(object.nodeIds)
                    ? { $case: "nodeIds", nodeIds: TreeNodeIds.fromJSON(object.nodeIds) }
                    : undefined,
            includeParents: isSet(object.includeParents) ? globalThis.Boolean(object.includeParents) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.source?.$case === "ownerIdentityPubkey") {
            obj.ownerIdentityPubkey = base64FromBytes(message.source.ownerIdentityPubkey);
        }
        else if (message.source?.$case === "nodeIds") {
            obj.nodeIds = TreeNodeIds.toJSON(message.source.nodeIds);
        }
        if (message.includeParents !== false) {
            obj.includeParents = message.includeParents;
        }
        return obj;
    },
    create(base) {
        return QueryNodesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNodesRequest();
        switch (object.source?.$case) {
            case "ownerIdentityPubkey": {
                if (object.source?.ownerIdentityPubkey !== undefined && object.source?.ownerIdentityPubkey !== null) {
                    message.source = { $case: "ownerIdentityPubkey", ownerIdentityPubkey: object.source.ownerIdentityPubkey };
                }
                break;
            }
            case "nodeIds": {
                if (object.source?.nodeIds !== undefined && object.source?.nodeIds !== null) {
                    message.source = { $case: "nodeIds", nodeIds: TreeNodeIds.fromPartial(object.source.nodeIds) };
                }
                break;
            }
        }
        message.includeParents = object.includeParents ?? false;
        return message;
    },
};
function createBaseQueryNodesResponse() {
    return { nodes: {} };
}
export const QueryNodesResponse = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.nodes).forEach(([key, value]) => {
            QueryNodesResponse_NodesEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNodesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = QueryNodesResponse_NodesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.nodes[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodes: isObject(object.nodes)
                ? Object.entries(object.nodes).reduce((acc, [key, value]) => {
                    acc[key] = TreeNode.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodes) {
            const entries = Object.entries(message.nodes);
            if (entries.length > 0) {
                obj.nodes = {};
                entries.forEach(([k, v]) => {
                    obj.nodes[k] = TreeNode.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return QueryNodesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNodesResponse();
        message.nodes = Object.entries(object.nodes ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = TreeNode.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseQueryNodesResponse_NodesEntry() {
    return { key: "", value: undefined };
}
export const QueryNodesResponse_NodesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            TreeNode.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNodesResponse_NodesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = TreeNode.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? TreeNode.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = TreeNode.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return QueryNodesResponse_NodesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNodesResponse_NodesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? TreeNode.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseCancelSendTransferRequest() {
    return { transferId: "", senderIdentityPublicKey: new Uint8Array(0) };
}
export const CancelSendTransferRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transferId !== "") {
            writer.uint32(10).string(message.transferId);
        }
        if (message.senderIdentityPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.senderIdentityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelSendTransferRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transferId = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.senderIdentityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
            senderIdentityPublicKey: isSet(object.senderIdentityPublicKey)
                ? bytesFromBase64(object.senderIdentityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transferId !== "") {
            obj.transferId = message.transferId;
        }
        if (message.senderIdentityPublicKey.length !== 0) {
            obj.senderIdentityPublicKey = base64FromBytes(message.senderIdentityPublicKey);
        }
        return obj;
    },
    create(base) {
        return CancelSendTransferRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCancelSendTransferRequest();
        message.transferId = object.transferId ?? "";
        message.senderIdentityPublicKey = object.senderIdentityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCancelSendTransferResponse() {
    return { transfer: undefined };
}
export const CancelSendTransferResponse = {
    encode(message, writer = new BinaryWriter()) {
        if (message.transfer !== undefined) {
            Transfer.encode(message.transfer, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCancelSendTransferResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfer = Transfer.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { transfer: isSet(object.transfer) ? Transfer.fromJSON(object.transfer) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfer !== undefined) {
            obj.transfer = Transfer.toJSON(message.transfer);
        }
        return obj;
    },
    create(base) {
        return CancelSendTransferResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCancelSendTransferResponse();
        message.transfer = (object.transfer !== undefined && object.transfer !== null)
            ? Transfer.fromPartial(object.transfer)
            : undefined;
        return message;
    },
};
function createBaseQueryAllTransfersRequest() {
    return { identityPublicKey: new Uint8Array(0), limit: 0, offset: 0 };
}
export const QueryAllTransfersRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.identityPublicKey);
        }
        if (message.limit !== 0) {
            writer.uint32(16).int64(message.limit);
        }
        if (message.offset !== 0) {
            writer.uint32(24).int64(message.offset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllTransfersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = longToNumber(reader.int64());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.offset = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
            offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        if (message.offset !== 0) {
            obj.offset = Math.round(message.offset);
        }
        return obj;
    },
    create(base) {
        return QueryAllTransfersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllTransfersRequest();
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        message.limit = object.limit ?? 0;
        message.offset = object.offset ?? 0;
        return message;
    },
};
function createBaseQueryAllTransfersResponse() {
    return { transfers: [], offset: 0 };
}
export const QueryAllTransfersResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.transfers) {
            Transfer.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.offset !== 0) {
            writer.uint32(16).int64(message.offset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllTransfersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.transfers.push(Transfer.decode(reader, reader.uint32()));
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.offset = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfers: globalThis.Array.isArray(object?.transfers)
                ? object.transfers.map((e) => Transfer.fromJSON(e))
                : [],
            offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfers?.length) {
            obj.transfers = message.transfers.map((e) => Transfer.toJSON(e));
        }
        if (message.offset !== 0) {
            obj.offset = Math.round(message.offset);
        }
        return obj;
    },
    create(base) {
        return QueryAllTransfersResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllTransfersResponse();
        message.transfers = object.transfers?.map((e) => Transfer.fromPartial(e)) || [];
        message.offset = object.offset ?? 0;
        return message;
    },
};
function createBaseQueryUnusedDepositAddressesRequest() {
    return { identityPublicKey: new Uint8Array(0) };
}
export const QueryUnusedDepositAddressesRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(10).bytes(message.identityPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnusedDepositAddressesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        return obj;
    },
    create(base) {
        return QueryUnusedDepositAddressesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryUnusedDepositAddressesRequest();
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseDepositAddressQueryResult() {
    return { depositAddress: "", userSigningPublicKey: new Uint8Array(0), verifyingPublicKey: new Uint8Array(0) };
}
export const DepositAddressQueryResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.depositAddress !== "") {
            writer.uint32(10).string(message.depositAddress);
        }
        if (message.userSigningPublicKey.length !== 0) {
            writer.uint32(18).bytes(message.userSigningPublicKey);
        }
        if (message.verifyingPublicKey.length !== 0) {
            writer.uint32(26).bytes(message.verifyingPublicKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositAddressQueryResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.depositAddress = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.userSigningPublicKey = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.verifyingPublicKey = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
            userSigningPublicKey: isSet(object.userSigningPublicKey)
                ? bytesFromBase64(object.userSigningPublicKey)
                : new Uint8Array(0),
            verifyingPublicKey: isSet(object.verifyingPublicKey)
                ? bytesFromBase64(object.verifyingPublicKey)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.depositAddress !== "") {
            obj.depositAddress = message.depositAddress;
        }
        if (message.userSigningPublicKey.length !== 0) {
            obj.userSigningPublicKey = base64FromBytes(message.userSigningPublicKey);
        }
        if (message.verifyingPublicKey.length !== 0) {
            obj.verifyingPublicKey = base64FromBytes(message.verifyingPublicKey);
        }
        return obj;
    },
    create(base) {
        return DepositAddressQueryResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDepositAddressQueryResult();
        message.depositAddress = object.depositAddress ?? "";
        message.userSigningPublicKey = object.userSigningPublicKey ?? new Uint8Array(0);
        message.verifyingPublicKey = object.verifyingPublicKey ?? new Uint8Array(0);
        return message;
    },
};
function createBaseQueryUnusedDepositAddressesResponse() {
    return { depositAddresses: [] };
}
export const QueryUnusedDepositAddressesResponse = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.depositAddresses) {
            DepositAddressQueryResult.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnusedDepositAddressesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.depositAddresses.push(DepositAddressQueryResult.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            depositAddresses: globalThis.Array.isArray(object?.depositAddresses)
                ? object.depositAddresses.map((e) => DepositAddressQueryResult.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.depositAddresses?.length) {
            obj.depositAddresses = message.depositAddresses.map((e) => DepositAddressQueryResult.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return QueryUnusedDepositAddressesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryUnusedDepositAddressesResponse();
        message.depositAddresses = object.depositAddresses?.map((e) => DepositAddressQueryResult.fromPartial(e)) || [];
        return message;
    },
};
export const SparkServiceDefinition = {
    name: "SparkService",
    fullName: "spark.SparkService",
    methods: {
        generate_deposit_address: {
            name: "generate_deposit_address",
            requestType: GenerateDepositAddressRequest,
            requestStream: false,
            responseType: GenerateDepositAddressResponse,
            responseStream: false,
            options: {},
        },
        start_tree_creation: {
            name: "start_tree_creation",
            requestType: StartTreeCreationRequest,
            requestStream: false,
            responseType: StartTreeCreationResponse,
            responseStream: false,
            options: {},
        },
        finalize_node_signatures: {
            name: "finalize_node_signatures",
            requestType: FinalizeNodeSignaturesRequest,
            requestStream: false,
            responseType: FinalizeNodeSignaturesResponse,
            responseStream: false,
            options: {},
        },
        start_send_transfer: {
            name: "start_send_transfer",
            requestType: StartSendTransferRequest,
            requestStream: false,
            responseType: StartSendTransferResponse,
            responseStream: false,
            options: {},
        },
        complete_send_transfer: {
            name: "complete_send_transfer",
            requestType: CompleteSendTransferRequest,
            requestStream: false,
            responseType: CompleteSendTransferResponse,
            responseStream: false,
            options: {},
        },
        query_pending_transfers: {
            name: "query_pending_transfers",
            requestType: QueryPendingTransfersRequest,
            requestStream: false,
            responseType: QueryPendingTransfersResponse,
            responseStream: false,
            options: {},
        },
        query_all_transfers: {
            name: "query_all_transfers",
            requestType: QueryAllTransfersRequest,
            requestStream: false,
            responseType: QueryAllTransfersResponse,
            responseStream: false,
            options: {},
        },
        claim_transfer_tweak_keys: {
            name: "claim_transfer_tweak_keys",
            requestType: ClaimTransferTweakKeysRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        claim_transfer_sign_refunds: {
            name: "claim_transfer_sign_refunds",
            requestType: ClaimTransferSignRefundsRequest,
            requestStream: false,
            responseType: ClaimTransferSignRefundsResponse,
            responseStream: false,
            options: {},
        },
        aggregate_nodes: {
            name: "aggregate_nodes",
            requestType: AggregateNodesRequest,
            requestStream: false,
            responseType: AggregateNodesResponse,
            responseStream: false,
            options: {},
        },
        store_preimage_share: {
            name: "store_preimage_share",
            requestType: StorePreimageShareRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        get_signing_commitments: {
            name: "get_signing_commitments",
            requestType: GetSigningCommitmentsRequest,
            requestStream: false,
            responseType: GetSigningCommitmentsResponse,
            responseStream: false,
            options: {},
        },
        cooperative_exit: {
            name: "cooperative_exit",
            requestType: CooperativeExitRequest,
            requestStream: false,
            responseType: CooperativeExitResponse,
            responseStream: false,
            options: {},
        },
        initiate_preimage_swap: {
            name: "initiate_preimage_swap",
            requestType: InitiatePreimageSwapRequest,
            requestStream: false,
            responseType: InitiatePreimageSwapResponse,
            responseStream: false,
            options: {},
        },
        provide_preimage: {
            name: "provide_preimage",
            requestType: ProvidePreimageRequest,
            requestStream: false,
            responseType: ProvidePreimageResponse,
            responseStream: false,
            options: {},
        },
        leaf_swap: {
            name: "leaf_swap",
            requestType: LeafSwapRequest,
            requestStream: false,
            responseType: LeafSwapResponse,
            responseStream: false,
            options: {},
        },
        refresh_timelock: {
            name: "refresh_timelock",
            requestType: RefreshTimelockRequest,
            requestStream: false,
            responseType: RefreshTimelockResponse,
            responseStream: false,
            options: {},
        },
        extend_leaf: {
            name: "extend_leaf",
            requestType: ExtendLeafRequest,
            requestStream: false,
            responseType: ExtendLeafResponse,
            responseStream: false,
            options: {},
        },
        prepare_tree_address: {
            name: "prepare_tree_address",
            requestType: PrepareTreeAddressRequest,
            requestStream: false,
            responseType: PrepareTreeAddressResponse,
            responseStream: false,
            options: {},
        },
        create_tree: {
            name: "create_tree",
            requestType: CreateTreeRequest,
            requestStream: false,
            responseType: CreateTreeResponse,
            responseStream: false,
            options: {},
        },
        get_signing_operator_list: {
            name: "get_signing_operator_list",
            requestType: Empty,
            requestStream: false,
            responseType: GetSigningOperatorListResponse,
            responseStream: false,
            options: {},
        },
        query_nodes: {
            name: "query_nodes",
            requestType: QueryNodesRequest,
            requestStream: false,
            responseType: QueryNodesResponse,
            responseStream: false,
            options: {},
        },
        query_user_signed_refunds: {
            name: "query_user_signed_refunds",
            requestType: QueryUserSignedRefundsRequest,
            requestStream: false,
            responseType: QueryUserSignedRefundsResponse,
            responseStream: false,
            options: {},
        },
        /** Token RPCs */
        start_token_transaction: {
            name: "start_token_transaction",
            requestType: StartTokenTransactionRequest,
            requestStream: false,
            responseType: StartTokenTransactionResponse,
            responseStream: false,
            options: {},
        },
        sign_token_transaction: {
            name: "sign_token_transaction",
            requestType: SignTokenTransactionRequest,
            requestStream: false,
            responseType: SignTokenTransactionResponse,
            responseStream: false,
            options: {},
        },
        finalize_token_transaction: {
            name: "finalize_token_transaction",
            requestType: FinalizeTokenTransactionRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        freeze_tokens: {
            name: "freeze_tokens",
            requestType: FreezeTokensRequest,
            requestStream: false,
            responseType: FreezeTokensResponse,
            responseStream: false,
            options: {},
        },
        get_owned_token_leaves: {
            name: "get_owned_token_leaves",
            requestType: GetOwnedTokenLeavesRequest,
            requestStream: false,
            responseType: GetOwnedTokenLeavesResponse,
            responseStream: false,
            options: {},
        },
        return_lightning_payment: {
            name: "return_lightning_payment",
            requestType: ReturnLightningPaymentRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        cancel_send_transfer: {
            name: "cancel_send_transfer",
            requestType: CancelSendTransferRequest,
            requestStream: false,
            responseType: CancelSendTransferResponse,
            responseStream: false,
            options: {},
        },
        query_unused_deposit_addresses: {
            name: "query_unused_deposit_addresses",
            requestType: QueryUnusedDepositAddressesRequest,
            requestStream: false,
            responseType: QueryUnusedDepositAddressesResponse,
            responseStream: false,
            options: {},
        },
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1_000);
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=spark.js.map