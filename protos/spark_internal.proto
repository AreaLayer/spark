syntax = "proto3";

package spark_internal;

option go_package = "github.com/lightsparkdev/spark-go/proto/spark_internal";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "common.proto";
import "spark.proto";

service SparkInternalService {
    rpc mark_keyshares_as_used(MarkKeysharesAsUsedRequest) returns (google.protobuf.Empty) {}
    rpc mark_keyshare_for_deposit_address(MarkKeyshareForDepositAddressRequest) returns (MarkKeyshareForDepositAddressResponse) {}
    rpc finalize_tree_creation(FinalizeTreeCreationRequest) returns (google.protobuf.Empty) {}

    rpc frost_round1(FrostRound1Request) returns (FrostRound1Response) {}
    rpc frost_round2(FrostRound2Request) returns (FrostRound2Response) {}

    rpc prepare_split_keyshares(PrepareSplitKeysharesRequest) returns (google.protobuf.Empty) {}
    rpc finalize_node_split(FinalizeNodeSplitRequest) returns (google.protobuf.Empty) {}

    rpc aggregate_nodes(spark.AggregateNodesRequest) returns (google.protobuf.Empty) {}
    rpc finalize_nodes_aggregation(FinalizeNodesAggregationRequest) returns (google.protobuf.Empty) {}

    rpc finalize_transfer(FinalizeTransferRequest) returns (google.protobuf.Empty) {}

    rpc get_preimage_share(GetPreimageShareRequest) returns (GetPreimageShareResponse) {}

    rpc prepare_tree_address(PrepareTreeAddressRequest) returns (PrepareTreeAddressResponse) {}
}

message MarkKeysharesAsUsedRequest {
    repeated string keyshare_id = 1;
}

message MarkKeyshareForDepositAddressRequest {
    string keyshare_id = 1;
    string address = 2;
    bytes owner_identity_public_key = 3;
    bytes owner_signing_public_key = 4;
}

message MarkKeyshareForDepositAddressResponse {
    bytes address_signature = 1;
}

message FrostRound1Request {
    repeated string keyshare_ids = 1;
}

message FrostRound1Response {   
    repeated common.SigningCommitment signing_commitments = 1;
}

message SigningJob {
    // The unique identifier for the signing job.
    string job_id = 1;
    
    // The message to sign.
    bytes message = 2;

    // The secret package from DKG round 3.
    string keyshare_id = 3;

    // The verifying key. This should be the total public key for both user and StatechainEntity.
    bytes verifying_key = 4;

    // The commitments for all participants of the statechain.
    map<string, common.SigningCommitment> commitments = 5;

    // The commitments for all participants of the user.
    common.SigningCommitment user_commitments = 6;
}

message FrostRound2Request {
    repeated SigningJob signing_jobs = 1;
}

message FrostRound2Response {
    map<string, common.SigningResult> results = 1;
}

message PrepareSplitKeysharesRequest {
    string node_id = 1;
    string target_keyshare_id = 2;
    repeated string selected_keyshare_ids = 3;
    string last_keyshare_id = 4;
}

message FinalizeTreeCreationRequest {
    repeated TreeNode nodes = 1;
}

message FinalizeNodeSplitRequest {
    string parent_node_id = 1;
    repeated TreeNode child_nodes = 2;
}

message FinalizeNodesAggregationRequest {
    repeated TreeNode nodes = 1;
}

message FinalizeTransferRequest {
    string transfer_id = 1;
    repeated TreeNode nodes = 2;
    google.protobuf.Timestamp timestamp = 3;
}

message TreeNode {
    string id = 1;
    uint64 value = 2;
    bytes verifying_pubkey = 3;
    bytes owner_identity_pubkey = 4;
    bytes owner_signing_pubkey = 5;
    bytes raw_tx = 6;
    bytes raw_refund_tx = 7;
    string tree_id = 8;
    optional string parent_node_id = 9;
    string signing_keyshare_id = 10;
    uint32 vout = 11;
    uint32 refund_timelock = 12;
}

message GetPreimageShareRequest {
    bytes payment_hash = 1;
    repeated spark.UserSignedRefund user_signed_refunds = 2;
    spark.InvoiceAmount invoice_amount = 3;
}

message GetPreimageShareResponse {
    bytes preimage_share = 1;
}

message PrepareTreeAddressNode {
    string signing_keyshare_id = 1;
    bytes user_public_key = 2;
    repeated PrepareTreeAddressNode children = 3;
}

message PrepareTreeAddressRequest {
    string target_keyshare_id = 1;
    PrepareTreeAddressNode node = 2;

    // TODO: This should be removed once we have a proper auth process.
    bytes user_identity_public_key = 3;
}

message PrepareTreeAddressResponse {
    map<string, bytes> signatures = 1;
}
