syntax = "proto3";

package spark;

option go_package = "github.com/lightsparkdev/spark-go/proto/spark";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "common.proto";

service SparkService {
    rpc generate_deposit_address(GenerateDepositAddressRequest) returns (GenerateDepositAddressResponse) {}
    rpc start_tree_creation(StartTreeCreationRequest) returns (StartTreeCreationResponse) {}
    rpc prepare_split_address(PrepareSplitAddressRequest) returns (PrepareSplitAddressResponse) {}
    rpc split_node(SplitNodeRequest) returns (SplitNodeResponse) {}
    rpc finalize_node_signatures(FinalizeNodeSignaturesRequest) returns (FinalizeNodeSignaturesResponse) {}
    rpc send_transfer(SendTransferRequest) returns (SendTransferResponse) {}
    rpc query_pending_transfers(QueryPendingTransfersRequest) returns (QueryPendingTransfersResponse) {}
    rpc claim_transfer_tweak_keys(ClaimTransferTweakKeysRequest) returns (google.protobuf.Empty) {}
    rpc claim_transfer_sign_refunds(ClaimTransferSignRefundsRequest) returns (ClaimTransferSignRefundsResponse) {}
    rpc aggregate_nodes(AggregateNodesRequest) returns (AggregateNodesResponse) {}
    rpc store_preimage_share(StorePreimageShareRequest) returns (google.protobuf.Empty) {}
}

message DepositAddressProof {
    map<string, bytes> address_signatures = 1;
    bytes proof_of_possession_signature = 2;
}

message GenerateDepositAddressRequest {
    bytes signing_public_key = 1;
    bytes identity_public_key = 2;
}

message Address {
    string address = 1;
    bytes verifying_key = 2;
    DepositAddressProof deposit_address_proof = 3;
}

message GenerateDepositAddressResponse {
    Address deposit_address = 1;
}

message UTXO {
    string txid = 1;
    uint32 vout = 2;
}

message SigningJob {
    bytes signing_public_key = 1;
    bytes raw_tx = 2;
    common.SigningCommitment signing_nonce_commitment = 3;
}


message SigningResult {
    map<string, bytes> public_keys = 1;
    map<string, common.SigningCommitment> signing_nonce_commitments = 2;
    map<string, bytes> signature_shares = 3;
}

message NodeSignatureShares {
    string node_id = 1;
    SigningResult node_tx_signing_result = 2;
    SigningResult refund_tx_signing_result = 3;
    bytes verifying_key = 4;
}

message NodeSignatures {
    string node_id = 1;
    bytes node_tx_signature = 2;
    bytes refund_tx_signature = 3;
}

message StartTreeCreationRequest {
    bytes identity_public_key = 1;
    UTXO on_chain_utxo = 2;
    SigningJob root_tx_signing_job = 3;
    SigningJob refund_tx_signing_job = 4;
}


message StartTreeCreationResponse {
    string tree_id = 1;
    NodeSignatureShares root_node_signature_shares = 2;
}

message TreeNode {
    string id = 1;
    string tree_id = 2;
    uint64 value = 3;
    optional string parent_node_id = 4;
    bytes node_tx = 5;
    bytes refund_tx = 6;
    uint32 vout = 7;
    bytes verifying_public_key = 8;
    bytes owner_identity_public_key = 9;
    uint32 refund_timelock = 10;
}

message Split {
    bytes signing_public_key = 1;
    SigningJob refund_signing_job = 2;
    uint64 value = 3;
    uint32 vout = 4;
}

message SplitNodeRequest {
    string node_id = 1;
    SigningJob parent_tx_signing_job = 2;
    repeated Split splits = 3;
}

message SplitResult {
    string node_id = 1;
    SigningResult refund_tx_signing_result = 2;
    bytes verifying_key = 3;
    bytes user_public_key = 4;
}

message SplitNodeResponse {
    string parent_node_id = 1;
    SigningResult parent_tx_signing_result = 2;
    repeated SplitResult split_results = 3;
}

message FinalizeNodeSignaturesRequest {
    common.SignatureIntent intent = 1;
    repeated NodeSignatures node_signatures = 2;
}

message FinalizeNodeSignaturesResponse {
    repeated TreeNode nodes = 1;
}

message PrepareSplitAddressRequest {
    string node_id = 1;
    repeated bytes signing_public_keys = 2;
}

message PrepareSplitAddressResponse {
    repeated Address addresses = 1;
}

message SecretShareTweak {
    bytes tweak = 1;
    repeated bytes proofs = 2;
}

message SendLeafKeyTweak {
    string leaf_id = 1;
    SecretShareTweak secret_share_tweak = 2;
    map<string, bytes> pubkey_shares_tweak = 3;
    bytes secret_cipher = 4;
    // Signature over Sha256(leaf_id||transfer_id||secret_cipher)
    bytes signature = 5;
}

message SendTransferRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated SendLeafKeyTweak leaves_to_send = 3;
    bytes receiver_identity_public_key = 4;
    google.protobuf.Timestamp expiry_time = 5;
}

enum TransferStatus {
    TRANSFER_STATUS_INITIATED = 0; 
    TRANSFER_STATUS_KEY_TWEAKED = 1;
    TRANSFER_STATUSR_REFUND_SIGNED = 2;
    TRANSFER_STATUS_COMPLETED = 3;
    TRANSFER_STATUS_EXPIRED = 4;
}

message Transfer {
    string id = 1;
    bytes sender_identity_public_key = 2;
    bytes receiver_identity_public_key = 3;
    TransferStatus status = 4;
    uint64 total_value = 5;
    google.protobuf.Timestamp expiry_time = 6;
    repeated TransferLeaf leaves = 7;
}

message TransferLeaf {
    TreeNode leaf = 1;
    bytes secret_cipher = 2;
    bytes signature = 3;
}

message SendTransferResponse {
    Transfer transfer = 1;
}

message QueryPendingTransfersRequest {
    bytes receiver_identity_public_key = 1;
}

message QueryPendingTransfersResponse {
    repeated Transfer transfers = 1;
}

message ClaimLeafKeyTweak {
    string leaf_id = 1;
    SecretShareTweak secret_share_tweak = 2;
    map<string, bytes> pubkey_shares_tweak = 3;
}

message ClaimTransferTweakKeysRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated ClaimLeafKeyTweak leaves_to_receive = 3;
}

message ClaimLeafSigningJob {
    string leaf_id = 1;
    SigningJob refund_tx_signing_job = 2;
}

message ClaimTransferSignRefundsRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated ClaimLeafSigningJob signing_jobs = 3;
}

message ClaimLeafSigningResult {
    string leaf_id = 1;
    SigningResult refund_tx_signing_result = 2;
    bytes verifying_key = 3;
}

message ClaimTransferSignRefundsResponse {
    repeated ClaimLeafSigningResult signing_results = 1;
}


message AggregateNodesRequest {
    repeated string node_ids = 1;
    SigningJob signing_job = 2;
    // Serves as a temporary identity public key, this should be get from auth process.
    bytes owner_identity_public_key = 3;
}

message AggregateNodesResponse {
    SigningResult aggregate_signature = 1;
    bytes verifying_key = 2;
    bytes parent_node_tx = 3;
    uint32 parent_node_vout = 4;
}

message StorePreimageShareRequest {
    bytes payment_hash = 1;
    bytes preimage_share = 2;
    bytes threshold = 3;
}
