syntax = "proto3";

package spark;

option go_package = "github.com/lightsparkdev/spark-go/proto/spark";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";
import "common.proto";

service SparkService {
    rpc generate_deposit_address(GenerateDepositAddressRequest) returns (GenerateDepositAddressResponse) {}
    rpc start_tree_creation(StartTreeCreationRequest) returns (StartTreeCreationResponse) {}
    rpc finalize_node_signatures(FinalizeNodeSignaturesRequest) returns (FinalizeNodeSignaturesResponse) {}
    rpc start_send_transfer(StartSendTransferRequest) returns (StartSendTransferResponse) {}
    rpc complete_send_transfer(CompleteSendTransferRequest) returns (CompleteSendTransferResponse) {}
    rpc query_pending_transfers(QueryPendingTransfersRequest) returns (QueryPendingTransfersResponse) {}
    rpc claim_transfer_tweak_keys(ClaimTransferTweakKeysRequest) returns (google.protobuf.Empty) {}
    rpc claim_transfer_sign_refunds(ClaimTransferSignRefundsRequest) returns (ClaimTransferSignRefundsResponse) {}
    rpc aggregate_nodes(AggregateNodesRequest) returns (AggregateNodesResponse) {}
    rpc store_preimage_share(StorePreimageShareRequest) returns (google.protobuf.Empty) {}
    rpc get_signing_commitments(GetSigningCommitmentsRequest) returns (GetSigningCommitmentsResponse) {}
    rpc cooperative_exit(CooperativeExitRequest) returns (CooperativeExitResponse) {}
    rpc initiate_preimage_swap(InitiatePreimageSwapRequest) returns (InitiatePreimageSwapResponse) {}
    rpc leaf_swap(LeafSwapRequest) returns (LeafSwapResponse) {}

    rpc prepare_tree_address(PrepareTreeAddressRequest) returns (PrepareTreeAddressResponse) {}
    rpc create_tree(CreateTreeRequest) returns (CreateTreeResponse) {}
    rpc get_signing_operator_list(google.protobuf.Empty) returns (GetSigningOperatorListResponse) {}

    rpc generate_revocation_public_key(google.protobuf.Empty) returns (GenerateRevocationPublicKeyResponse) {}
    rpc start_token_transaction(StartTokenTransactionRequest) returns (StartTokenTransactionResponse) {}
    rpc finalize_token_transaction(FinalizeTokenTransactionRequest) returns (google.protobuf.Empty) {}
    rpc query_user_signed_refunds(QueryUserSignedRefundsRequest) returns (QueryUserSignedRefundsResponse) {}
}

message DepositAddressProof {
    map<string, bytes> address_signatures = 1;
    bytes proof_of_possession_signature = 2;
}

message GenerateDepositAddressRequest {
    bytes signing_public_key = 1;
    bytes identity_public_key = 2;
}

message Address {
    string address = 1;
    bytes verifying_key = 2;
    DepositAddressProof deposit_address_proof = 3;
}

message GenerateDepositAddressResponse {
    Address deposit_address = 1;
}

message UTXO {
    string txid = 1;
    uint32 vout = 2;
    bytes raw_tx = 3;
}

message NodeOutput {
    string node_id = 1;
    uint32 vout = 2;
}

message SigningJob {
    bytes signing_public_key = 1;
    bytes raw_tx = 2;
    common.SigningCommitment signing_nonce_commitment = 3;
}

message SigningKeyshare {
    repeated string owner_identifiers = 1;
    uint32 threshold = 2;
}


message SigningResult {
    map<string, bytes> public_keys = 1;
    map<string, common.SigningCommitment> signing_nonce_commitments = 2;
    map<string, bytes> signature_shares = 3;
    SigningKeyshare signing_keyshare = 4;
}

message NodeSignatureShares {
    string node_id = 1;
    SigningResult node_tx_signing_result = 2;
    SigningResult refund_tx_signing_result = 3;
    bytes verifying_key = 4;
}

message NodeSignatures {
    string node_id = 1;
    bytes node_tx_signature = 2;
    bytes refund_tx_signature = 3;
}

message StartTreeCreationRequest {
    bytes identity_public_key = 1;
    UTXO on_chain_utxo = 2;
    SigningJob root_tx_signing_job = 3;
    SigningJob refund_tx_signing_job = 4;
}

message StartTreeCreationResponse {
    string tree_id = 1;
    NodeSignatureShares root_node_signature_shares = 2;
}

// This proto is included by the wallet in a token transaction request 
// to inform the SO set of the nonce and signing public key that the
// wallet will use for this token transaction.
message TokenTransactionSigningJob {
    bytes leaf_id = 1;
    common.SigningCommitment signing_nonce_commitment = 2;
    // Signature of the partial token transaction hash to prove that the requesting
    // wallet has the signing key necessary to spend the leaves before SO's resolve
    // the revocation private key.
    // Note that actual combined signing will happen later.
    bytes ownership_signature = 3;
}


// This proto is returned to the wallet after the initial token transaction
// request so that it can verify the SE combined signature, generate the final
// aggregate signature, and finalize the transaction with the SE.
message TokenTransactionSignatureShares {
    bytes token_transaction_hash = 1;
    SigningResult token_transaction_signing_result = 2;
    bytes verifying_key = 3;
}

// This proto is constructed by the wallet (without a revocation private key initially)
// to specify leaves it wants to spend as part of a token transaction. Upon starting
// the private key field will be filled and returned by the Coordinator SO so that the
// wallet can validate the full transaction hash before finalizng the transaction.
message TokenLeafToSpend {
    bytes token_transaction_hash = 1;
    uint32 token_leaf_index = 2;
    bytes revocation_private_key = 3;   
}

// This proto is constructed by the wallet to specify leaves it wants to create
// as part of a token transaction.
message TokenLeafToCreate {
    string id = 1;
    bytes verifying_key = 2;
    bytes owner_identity_public_key = 3;
    bytes revocation_public_key = 4;
    uint64 withdrawal_bond_sats = 5;
    uint64 withdrawal_locktime = 6;
    bytes token_public_key = 7;
    bytes token_amount = 8;  // Decoded uint128
}

// This proto is constructed by the wallet and is the core transaction data structure.
// This proto is deterministically hashed to generate the token_transaction_hash that 
// is cooperatively signed by the SO group to confirm a token transaction.
message TokenTransaction {    
    // For issuance transactions there will be 0 input leaves and one or more output leaves.
    // For transfer transactions the token amount in the input leaves must match the token amount in the output leaves.
    repeated TokenLeafToSpend leaves_to_spend = 1;
    repeated TokenLeafToCreate leaves_to_create = 2;
}

message GenerateRevocationPublicKeyResponse {
    bytes revocation_public_key = 1;
}

message StartTokenTransactionRequest {
    bytes identity_public_key = 1;
    TokenTransaction partial_token_transaction = 2;
    // For issuance transactions this should have one signing job where the signing public key 
    // is the same as the wallets identity public key (which is also the token public key).
    // For transfer transactions this should have one signing job for each leaf in 
    // leaves_to_spend within the token transaction.
    repeated TokenTransactionSigningJob signing_jobs = 4;
}

message StartTokenTransactionResponse {
    // This is the same token transaction sent by the wallet with the revocation
    // private key for each spent leaf filled in by the SO.  This is the final transaction
    // that will be signed and used for the token transaction hash.
    // Note that for issuance (because no leaves are spent) this will match the 
    // token transaction provided by the wallet.
    TokenTransaction finalized_token_transaction = 1;
    repeated TokenTransactionSignatureShares signature_shares = 2;
}

message FinalizeTokenTransactionRequest {
     // Deterministic hash of token transaction payload
    bytes token_transaction_hash = 1;
     // Combined signatures by the SO set and User.
     // For issuance this will be one signature for the entire operation.
     // For transfer this will be multiple signatures in the same order as the provided TokenLeafToSpend objects
     // when constructing the TokenTransaction.
    repeated bytes signatures = 2;
}

message TreeNode {
    string id = 1;
    string tree_id = 2;
    uint64 value = 3;
    optional string parent_node_id = 4;
    bytes node_tx = 5;
    bytes refund_tx = 6;
    uint32 vout = 7;
    bytes verifying_public_key = 8;
    bytes owner_identity_public_key = 9;
    uint32 refund_timelock = 10;
}

message FinalizeNodeSignaturesRequest {
    common.SignatureIntent intent = 1;
    repeated NodeSignatures node_signatures = 2;
}

message FinalizeNodeSignaturesResponse {
    repeated TreeNode nodes = 1;
}

message SecretShare {
    bytes secret_share = 1;
    repeated bytes proofs = 2;
}

message LeafRefundTxSigningJob {
    string leaf_id = 1;
    SigningJob refund_tx_signing_job = 2;
}

message LeafRefundTxSigningResult {
    string leaf_id = 1;
    SigningResult refund_tx_signing_result = 2;
    bytes verifying_key = 3;
}

message StartSendTransferRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated LeafRefundTxSigningJob leaves_to_send = 3;
    bytes receiver_identity_public_key = 4;
    google.protobuf.Timestamp expiry_time = 5;
}

message StartSendTransferResponse {
    Transfer transfer = 1;
    repeated LeafRefundTxSigningResult signing_results = 2;
}

message SendLeafKeyTweak {
    string leaf_id = 1;
    SecretShare secret_share_tweak = 2;
    map<string, bytes> pubkey_shares_tweak = 3;
    bytes secret_cipher = 4;
    // Signature over Sha256(leaf_id||transfer_id||secret_cipher)
    bytes signature = 5;
    bytes refund_signature = 6;
}

message CompleteSendTransferRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated SendLeafKeyTweak leaves_to_send = 3;
}

enum TransferStatus {
    TRANSFER_STATUS_SENDER_INITIATED = 0; 
    TRANSFER_STATUS_SENDER_KEY_TWEAKED = 1;
    TRANSFER_STATUS_RECEIVER_KEY_TWEAKED = 2;
    TRANSFER_STATUSR_RECEIVER_REFUND_SIGNED = 3;
    TRANSFER_STATUS_COMPLETED = 4;
    TRANSFER_STATUS_EXPIRED = 5;
}

message Transfer {
    string id = 1;
    bytes sender_identity_public_key = 2;
    bytes receiver_identity_public_key = 3;
    TransferStatus status = 4;
    uint64 total_value = 5;
    google.protobuf.Timestamp expiry_time = 6;
    repeated TransferLeaf leaves = 7;
}

message TransferLeaf {
    TreeNode leaf = 1;
    bytes secret_cipher = 2;
    bytes signature = 3;
    bytes intermediate_refund_tx = 4;
    SigningKeyshare signing_keyshare = 5;
}

message CompleteSendTransferResponse {
    Transfer transfer = 1;
}

message QueryPendingTransfersRequest {
    bytes receiver_identity_public_key = 1;
}

message QueryPendingTransfersResponse {
    repeated Transfer transfers = 1;
}

message ClaimLeafKeyTweak {
    string leaf_id = 1;
    SecretShare secret_share_tweak = 2;
    map<string, bytes> pubkey_shares_tweak = 3;
}

message ClaimTransferTweakKeysRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated ClaimLeafKeyTweak leaves_to_receive = 3;
}

message ClaimTransferSignRefundsRequest {
    string transfer_id = 1;
    bytes owner_identity_public_key = 2;
    repeated LeafRefundTxSigningJob signing_jobs = 3;
}


message ClaimTransferSignRefundsResponse {
    repeated LeafRefundTxSigningResult signing_results = 1;
}

message AggregateNodesRequest {
    repeated string node_ids = 1;
    SigningJob signing_job = 2;
    // Serves as a temporary identity public key, this should be get from auth process.
    bytes owner_identity_public_key = 3;
}

message AggregateNodesResponse {
    SigningResult aggregate_signature = 1;
    bytes verifying_key = 2;
    bytes parent_node_tx = 3;
    uint32 parent_node_vout = 4;
}

message StorePreimageShareRequest {
    bytes payment_hash = 1;
    SecretShare preimage_share = 2;
    uint32 threshold = 3;
    string invoice_string = 4;
    // TODO: This should be removed once we have a proper auth process.
    bytes user_identity_public_key = 5;
}

message RequestedSigningCommitments {
    map<string, common.SigningCommitment> signing_nonce_commitments = 1;
}

message GetSigningCommitmentsRequest {
    repeated string node_ids = 1;
}

message GetSigningCommitmentsResponse {
    repeated RequestedSigningCommitments signing_commitments = 1;
}

message SigningCommitments {
    map<string, common.SigningCommitment> signing_commitments = 1;
}

message UserSignedRefund {
    string node_id = 1;
    bytes refund_tx = 2;
    bytes user_signature = 3;
    SigningCommitments signing_commitments = 4;
    common.SigningCommitment user_signature_commitment = 5;
}

message InvoiceAmountProof {
    string bolt11_invoice = 1;
}

message InvoiceAmount {
    uint64 value_sats = 1;
    InvoiceAmountProof invoice_amount_proof = 2;
}

message InitiatePreimageSwapRequest {
    bytes payment_hash = 1;
    repeated UserSignedRefund user_signed_refunds = 2;
    InvoiceAmount invoice_amount = 3;
    enum Reason {
        REASON_SEND = 0;
        REASON_RECEIVE = 1;
    }
    Reason reason = 4;
    StartSendTransferRequest transfer = 5;
    bytes receiver_identity_public_key = 6;
}

message InitiatePreimageSwapResponse {
    bytes preimage = 1;
    Transfer transfer = 2;
}

message OutPoint {
    bytes txid = 1;
    uint32 vout = 2;
}

message CooperativeExitRequest {
    StartSendTransferRequest transfer = 1;
    string exit_id = 2;
    bytes exit_txid = 3;
    // TODO: provide signatures for the leaves so SE can be watchtower
}

message CooperativeExitResponse {
    Transfer transfer = 1;
    repeated LeafRefundTxSigningResult signing_results = 2;
}

message LeafSwapRequest {
    StartSendTransferRequest transfer = 1;
    string swap_id = 2;
    bytes adaptor_public_key = 3;
}

message LeafSwapResponse {
    Transfer transfer = 1;
    repeated LeafRefundTxSigningResult signing_results = 2;
}

message AddressRequestNode {
    bytes user_public_key = 1;
    repeated AddressRequestNode children = 2;
}

message PrepareTreeAddressRequest {
    oneof source {
        NodeOutput parent_node_output = 1;
        UTXO on_chain_utxo = 2;
    }

    // The tx on this node is to spend the source's utxo.
    // The user's public key should already be registered with the SE for the root node.
    AddressRequestNode node = 3;

    // TODO: This should be removed once we have a proper auth process.
    bytes user_identity_public_key = 4;
}

message AddressNode {
    Address address = 1;
    repeated AddressNode children = 2;
}

message PrepareTreeAddressResponse {
    AddressNode node = 1;
}

message CreationNode {
    // This is the tx that spends the parent node's output.
    SigningJob node_tx_signing_job = 1;
    // The refund tx can only exist if there's no children.
    SigningJob refund_tx_signing_job = 2;

    // The children will spend the output of the node's tx. Vout is the index of the child.
    repeated CreationNode children = 3;
}

message CreateTreeRequest {
    oneof source {
        NodeOutput parent_node_output = 1;
        UTXO on_chain_utxo = 2;
    }
    // The node should contain the tx that spends the source's utxo.
    CreationNode node = 3;
    
    // The owner of the tree.
    bytes user_identity_public_key = 4;
}

message CreationResponseNode {
    string node_id = 1;
    SigningResult node_tx_signing_result = 2;
    SigningResult refund_tx_signing_result = 3; 
    repeated CreationResponseNode children = 4;
}

message CreateTreeResponse {
    CreationResponseNode node = 1;
}

message SigningOperatorInfo {
    uint64 index = 1;
    string identifier = 2;
    bytes public_key = 3;
    string address = 4;
}

message GetSigningOperatorListResponse {
    map<string, SigningOperatorInfo> signing_operators = 1;
}

message QueryUserSignedRefundsRequest {
    bytes payment_hash = 1;
}

message QueryUserSignedRefundsResponse {
    repeated UserSignedRefund user_signed_refunds = 1;
}
