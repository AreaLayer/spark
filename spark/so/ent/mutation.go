// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/lightsparkdev/spark-go/so/ent/depositaddress"
	"github.com/lightsparkdev/spark-go/so/ent/predicate"
	"github.com/lightsparkdev/spark-go/so/ent/schema"
	"github.com/lightsparkdev/spark-go/so/ent/signingkeyshare"
	"github.com/lightsparkdev/spark-go/so/ent/signingnonce"
	"github.com/lightsparkdev/spark-go/so/ent/transfer"
	"github.com/lightsparkdev/spark-go/so/ent/transferleaf"
	"github.com/lightsparkdev/spark-go/so/ent/tree"
	"github.com/lightsparkdev/spark-go/so/ent/treenode"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDepositAddress  = "DepositAddress"
	TypeSigningKeyshare = "SigningKeyshare"
	TypeSigningNonce    = "SigningNonce"
	TypeTransfer        = "Transfer"
	TypeTransferLeaf    = "TransferLeaf"
	TypeTree            = "Tree"
	TypeTreeNode        = "TreeNode"
)

// DepositAddressMutation represents an operation that mutates the DepositAddress nodes in the graph.
type DepositAddressMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	address                 *string
	owner_identity_pubkey   *[]byte
	owner_signing_pubkey    *[]byte
	clearedFields           map[string]struct{}
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	done                    bool
	oldValue                func(context.Context) (*DepositAddress, error)
	predicates              []predicate.DepositAddress
}

var _ ent.Mutation = (*DepositAddressMutation)(nil)

// depositaddressOption allows management of the mutation configuration using functional options.
type depositaddressOption func(*DepositAddressMutation)

// newDepositAddressMutation creates new mutation for the DepositAddress entity.
func newDepositAddressMutation(c config, op Op, opts ...depositaddressOption) *DepositAddressMutation {
	m := &DepositAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeDepositAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositAddressID sets the ID field of the mutation.
func withDepositAddressID(id uuid.UUID) depositaddressOption {
	return func(m *DepositAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *DepositAddress
		)
		m.oldValue = func(ctx context.Context) (*DepositAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DepositAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepositAddress sets the old DepositAddress of the mutation.
func withDepositAddress(node *DepositAddress) depositaddressOption {
	return func(m *DepositAddressMutation) {
		m.oldValue = func(context.Context) (*DepositAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DepositAddress entities.
func (m *DepositAddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepositAddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepositAddressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DepositAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DepositAddressMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DepositAddressMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DepositAddressMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DepositAddressMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DepositAddressMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DepositAddressMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAddress sets the "address" field.
func (m *DepositAddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *DepositAddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *DepositAddressMutation) ResetAddress() {
	m.address = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) SetOwnerSigningPubkey(b []byte) {
	m.owner_signing_pubkey = &b
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerSigningPubkey() (r []byte, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerSigningPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *DepositAddressMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *DepositAddressMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *DepositAddressMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *DepositAddressMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *DepositAddressMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *DepositAddressMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// Where appends a list predicates to the DepositAddressMutation builder.
func (m *DepositAddressMutation) Where(ps ...predicate.DepositAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepositAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepositAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DepositAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepositAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepositAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DepositAddress).
func (m *DepositAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepositAddressMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, depositaddress.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, depositaddress.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, depositaddress.FieldAddress)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerSigningPubkey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepositAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.CreateTime()
	case depositaddress.FieldUpdateTime:
		return m.UpdateTime()
	case depositaddress.FieldAddress:
		return m.Address()
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepositAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case depositaddress.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case depositaddress.FieldAddress:
		return m.OldAddress(ctx)
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	}
	return nil, fmt.Errorf("unknown DepositAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case depositaddress.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case depositaddress.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case depositaddress.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepositAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepositAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DepositAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepositAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepositAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DepositAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepositAddressMutation) ResetField(name string) error {
	switch name {
	case depositaddress.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case depositaddress.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case depositaddress.FieldAddress:
		m.ResetAddress()
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepositAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.signing_keyshare != nil {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepositAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepositAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepositAddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepositAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsigning_keyshare {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepositAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepositAddressMutation) ClearEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepositAddressMutation) ResetEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress edge %s", name)
}

// SigningKeyshareMutation represents an operation that mutates the SigningKeyshare nodes in the graph.
type SigningKeyshareMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	create_time          *time.Time
	update_time          *time.Time
	status               *schema.SigningKeyshareStatus
	secret_share         *[]byte
	public_shares        *map[string][]uint8
	public_key           *[]byte
	min_signers          *uint32
	addmin_signers       *int32
	coordinator_index    *uint64
	addcoordinator_index *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SigningKeyshare, error)
	predicates           []predicate.SigningKeyshare
}

var _ ent.Mutation = (*SigningKeyshareMutation)(nil)

// signingkeyshareOption allows management of the mutation configuration using functional options.
type signingkeyshareOption func(*SigningKeyshareMutation)

// newSigningKeyshareMutation creates new mutation for the SigningKeyshare entity.
func newSigningKeyshareMutation(c config, op Op, opts ...signingkeyshareOption) *SigningKeyshareMutation {
	m := &SigningKeyshareMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningKeyshare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningKeyshareID sets the ID field of the mutation.
func withSigningKeyshareID(id uuid.UUID) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningKeyshare
		)
		m.oldValue = func(ctx context.Context) (*SigningKeyshare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningKeyshare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningKeyshare sets the old SigningKeyshare of the mutation.
func withSigningKeyshare(node *SigningKeyshare) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		m.oldValue = func(context.Context) (*SigningKeyshare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningKeyshareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningKeyshareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningKeyshare entities.
func (m *SigningKeyshareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningKeyshareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningKeyshareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningKeyshare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningKeyshareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningKeyshareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningKeyshareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningKeyshareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningKeyshareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningKeyshareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *SigningKeyshareMutation) SetStatus(sks schema.SigningKeyshareStatus) {
	m.status = &sks
}

// Status returns the value of the "status" field in the mutation.
func (m *SigningKeyshareMutation) Status() (r schema.SigningKeyshareStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldStatus(ctx context.Context) (v schema.SigningKeyshareStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SigningKeyshareMutation) ResetStatus() {
	m.status = nil
}

// SetSecretShare sets the "secret_share" field.
func (m *SigningKeyshareMutation) SetSecretShare(b []byte) {
	m.secret_share = &b
}

// SecretShare returns the value of the "secret_share" field in the mutation.
func (m *SigningKeyshareMutation) SecretShare() (r []byte, exists bool) {
	v := m.secret_share
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretShare returns the old "secret_share" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldSecretShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretShare: %w", err)
	}
	return oldValue.SecretShare, nil
}

// ResetSecretShare resets all changes to the "secret_share" field.
func (m *SigningKeyshareMutation) ResetSecretShare() {
	m.secret_share = nil
}

// SetPublicShares sets the "public_shares" field.
func (m *SigningKeyshareMutation) SetPublicShares(value map[string][]uint8) {
	m.public_shares = &value
}

// PublicShares returns the value of the "public_shares" field in the mutation.
func (m *SigningKeyshareMutation) PublicShares() (r map[string][]uint8, exists bool) {
	v := m.public_shares
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicShares returns the old "public_shares" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicShares(ctx context.Context) (v map[string][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicShares is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicShares requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicShares: %w", err)
	}
	return oldValue.PublicShares, nil
}

// ResetPublicShares resets all changes to the "public_shares" field.
func (m *SigningKeyshareMutation) ResetPublicShares() {
	m.public_shares = nil
}

// SetPublicKey sets the "public_key" field.
func (m *SigningKeyshareMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *SigningKeyshareMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *SigningKeyshareMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetMinSigners sets the "min_signers" field.
func (m *SigningKeyshareMutation) SetMinSigners(u uint32) {
	m.min_signers = &u
	m.addmin_signers = nil
}

// MinSigners returns the value of the "min_signers" field in the mutation.
func (m *SigningKeyshareMutation) MinSigners() (r uint32, exists bool) {
	v := m.min_signers
	if v == nil {
		return
	}
	return *v, true
}

// OldMinSigners returns the old "min_signers" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldMinSigners(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinSigners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinSigners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinSigners: %w", err)
	}
	return oldValue.MinSigners, nil
}

// AddMinSigners adds u to the "min_signers" field.
func (m *SigningKeyshareMutation) AddMinSigners(u int32) {
	if m.addmin_signers != nil {
		*m.addmin_signers += u
	} else {
		m.addmin_signers = &u
	}
}

// AddedMinSigners returns the value that was added to the "min_signers" field in this mutation.
func (m *SigningKeyshareMutation) AddedMinSigners() (r int32, exists bool) {
	v := m.addmin_signers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinSigners resets all changes to the "min_signers" field.
func (m *SigningKeyshareMutation) ResetMinSigners() {
	m.min_signers = nil
	m.addmin_signers = nil
}

// SetCoordinatorIndex sets the "coordinator_index" field.
func (m *SigningKeyshareMutation) SetCoordinatorIndex(u uint64) {
	m.coordinator_index = &u
	m.addcoordinator_index = nil
}

// CoordinatorIndex returns the value of the "coordinator_index" field in the mutation.
func (m *SigningKeyshareMutation) CoordinatorIndex() (r uint64, exists bool) {
	v := m.coordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinatorIndex returns the old "coordinator_index" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCoordinatorIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinatorIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinatorIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinatorIndex: %w", err)
	}
	return oldValue.CoordinatorIndex, nil
}

// AddCoordinatorIndex adds u to the "coordinator_index" field.
func (m *SigningKeyshareMutation) AddCoordinatorIndex(u int64) {
	if m.addcoordinator_index != nil {
		*m.addcoordinator_index += u
	} else {
		m.addcoordinator_index = &u
	}
}

// AddedCoordinatorIndex returns the value that was added to the "coordinator_index" field in this mutation.
func (m *SigningKeyshareMutation) AddedCoordinatorIndex() (r int64, exists bool) {
	v := m.addcoordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoordinatorIndex resets all changes to the "coordinator_index" field.
func (m *SigningKeyshareMutation) ResetCoordinatorIndex() {
	m.coordinator_index = nil
	m.addcoordinator_index = nil
}

// Where appends a list predicates to the SigningKeyshareMutation builder.
func (m *SigningKeyshareMutation) Where(ps ...predicate.SigningKeyshare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningKeyshareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningKeyshareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningKeyshare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningKeyshareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningKeyshareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningKeyshare).
func (m *SigningKeyshareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningKeyshareMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, signingkeyshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingkeyshare.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, signingkeyshare.FieldStatus)
	}
	if m.secret_share != nil {
		fields = append(fields, signingkeyshare.FieldSecretShare)
	}
	if m.public_shares != nil {
		fields = append(fields, signingkeyshare.FieldPublicShares)
	}
	if m.public_key != nil {
		fields = append(fields, signingkeyshare.FieldPublicKey)
	}
	if m.min_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.coordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningKeyshareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.CreateTime()
	case signingkeyshare.FieldUpdateTime:
		return m.UpdateTime()
	case signingkeyshare.FieldStatus:
		return m.Status()
	case signingkeyshare.FieldSecretShare:
		return m.SecretShare()
	case signingkeyshare.FieldPublicShares:
		return m.PublicShares()
	case signingkeyshare.FieldPublicKey:
		return m.PublicKey()
	case signingkeyshare.FieldMinSigners:
		return m.MinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.CoordinatorIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningKeyshareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingkeyshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingkeyshare.FieldStatus:
		return m.OldStatus(ctx)
	case signingkeyshare.FieldSecretShare:
		return m.OldSecretShare(ctx)
	case signingkeyshare.FieldPublicShares:
		return m.OldPublicShares(ctx)
	case signingkeyshare.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case signingkeyshare.FieldMinSigners:
		return m.OldMinSigners(ctx)
	case signingkeyshare.FieldCoordinatorIndex:
		return m.OldCoordinatorIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingkeyshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingkeyshare.FieldStatus:
		v, ok := value.(schema.SigningKeyshareStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signingkeyshare.FieldSecretShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretShare(v)
		return nil
	case signingkeyshare.FieldPublicShares:
		v, ok := value.(map[string][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicShares(v)
		return nil
	case signingkeyshare.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningKeyshareMutation) AddedFields() []string {
	var fields []string
	if m.addmin_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.addcoordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningKeyshareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldMinSigners:
		return m.AddedMinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.AddedCoordinatorIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningKeyshareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningKeyshareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningKeyshare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ResetField(name string) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingkeyshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingkeyshare.FieldStatus:
		m.ResetStatus()
		return nil
	case signingkeyshare.FieldSecretShare:
		m.ResetSecretShare()
		return nil
	case signingkeyshare.FieldPublicShares:
		m.ResetPublicShares()
		return nil
	case signingkeyshare.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case signingkeyshare.FieldMinSigners:
		m.ResetMinSigners()
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		m.ResetCoordinatorIndex()
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningKeyshareMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningKeyshareMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningKeyshareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningKeyshareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningKeyshareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningKeyshareMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningKeyshareMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningKeyshareMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare edge %s", name)
}

// SigningNonceMutation represents an operation that mutates the SigningNonce nodes in the graph.
type SigningNonceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	nonce            *[]byte
	nonce_commitment *[]byte
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*SigningNonce, error)
	predicates       []predicate.SigningNonce
}

var _ ent.Mutation = (*SigningNonceMutation)(nil)

// signingnonceOption allows management of the mutation configuration using functional options.
type signingnonceOption func(*SigningNonceMutation)

// newSigningNonceMutation creates new mutation for the SigningNonce entity.
func newSigningNonceMutation(c config, op Op, opts ...signingnonceOption) *SigningNonceMutation {
	m := &SigningNonceMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningNonce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningNonceID sets the ID field of the mutation.
func withSigningNonceID(id uuid.UUID) signingnonceOption {
	return func(m *SigningNonceMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningNonce
		)
		m.oldValue = func(ctx context.Context) (*SigningNonce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningNonce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningNonce sets the old SigningNonce of the mutation.
func withSigningNonce(node *SigningNonce) signingnonceOption {
	return func(m *SigningNonceMutation) {
		m.oldValue = func(context.Context) (*SigningNonce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningNonceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningNonceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningNonce entities.
func (m *SigningNonceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningNonceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningNonceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningNonce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningNonceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningNonceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningNonceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningNonceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningNonceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningNonceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNonce sets the "nonce" field.
func (m *SigningNonceMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *SigningNonceMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *SigningNonceMutation) ResetNonce() {
	m.nonce = nil
}

// SetNonceCommitment sets the "nonce_commitment" field.
func (m *SigningNonceMutation) SetNonceCommitment(b []byte) {
	m.nonce_commitment = &b
}

// NonceCommitment returns the value of the "nonce_commitment" field in the mutation.
func (m *SigningNonceMutation) NonceCommitment() (r []byte, exists bool) {
	v := m.nonce_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldNonceCommitment returns the old "nonce_commitment" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonceCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonceCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonceCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonceCommitment: %w", err)
	}
	return oldValue.NonceCommitment, nil
}

// ResetNonceCommitment resets all changes to the "nonce_commitment" field.
func (m *SigningNonceMutation) ResetNonceCommitment() {
	m.nonce_commitment = nil
}

// Where appends a list predicates to the SigningNonceMutation builder.
func (m *SigningNonceMutation) Where(ps ...predicate.SigningNonce) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningNonceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningNonceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningNonce, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningNonceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningNonceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningNonce).
func (m *SigningNonceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningNonceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, signingnonce.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingnonce.FieldUpdateTime)
	}
	if m.nonce != nil {
		fields = append(fields, signingnonce.FieldNonce)
	}
	if m.nonce_commitment != nil {
		fields = append(fields, signingnonce.FieldNonceCommitment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningNonceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.CreateTime()
	case signingnonce.FieldUpdateTime:
		return m.UpdateTime()
	case signingnonce.FieldNonce:
		return m.Nonce()
	case signingnonce.FieldNonceCommitment:
		return m.NonceCommitment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningNonceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingnonce.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingnonce.FieldNonce:
		return m.OldNonce(ctx)
	case signingnonce.FieldNonceCommitment:
		return m.OldNonceCommitment(ctx)
	}
	return nil, fmt.Errorf("unknown SigningNonce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingnonce.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingnonce.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingnonce.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case signingnonce.FieldNonceCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonceCommitment(v)
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningNonceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningNonceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SigningNonce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningNonceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningNonceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningNonceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningNonce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningNonceMutation) ResetField(name string) error {
	switch name {
	case signingnonce.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingnonce.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingnonce.FieldNonce:
		m.ResetNonce()
		return nil
	case signingnonce.FieldNonceCommitment:
		m.ResetNonceCommitment()
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningNonceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningNonceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningNonceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningNonceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningNonceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningNonceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningNonceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningNonceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	sender_identity_pubkey   *[]byte
	receiver_identity_pubkey *[]byte
	total_value              *uint64
	addtotal_value           *int64
	status                   *schema.TransferStatus
	expiry_time              *time.Time
	completion_time          *time.Time
	clearedFields            map[string]struct{}
	transfer_leaves          map[uuid.UUID]struct{}
	removedtransfer_leaves   map[uuid.UUID]struct{}
	clearedtransfer_leaves   bool
	done                     bool
	oldValue                 func(context.Context) (*Transfer, error)
	predicates               []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uuid.UUID) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSenderIdentityPubkey sets the "sender_identity_pubkey" field.
func (m *TransferMutation) SetSenderIdentityPubkey(b []byte) {
	m.sender_identity_pubkey = &b
}

// SenderIdentityPubkey returns the value of the "sender_identity_pubkey" field in the mutation.
func (m *TransferMutation) SenderIdentityPubkey() (r []byte, exists bool) {
	v := m.sender_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderIdentityPubkey returns the old "sender_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldSenderIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderIdentityPubkey: %w", err)
	}
	return oldValue.SenderIdentityPubkey, nil
}

// ResetSenderIdentityPubkey resets all changes to the "sender_identity_pubkey" field.
func (m *TransferMutation) ResetSenderIdentityPubkey() {
	m.sender_identity_pubkey = nil
}

// SetReceiverIdentityPubkey sets the "receiver_identity_pubkey" field.
func (m *TransferMutation) SetReceiverIdentityPubkey(b []byte) {
	m.receiver_identity_pubkey = &b
}

// ReceiverIdentityPubkey returns the value of the "receiver_identity_pubkey" field in the mutation.
func (m *TransferMutation) ReceiverIdentityPubkey() (r []byte, exists bool) {
	v := m.receiver_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverIdentityPubkey returns the old "receiver_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldReceiverIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverIdentityPubkey: %w", err)
	}
	return oldValue.ReceiverIdentityPubkey, nil
}

// ResetReceiverIdentityPubkey resets all changes to the "receiver_identity_pubkey" field.
func (m *TransferMutation) ResetReceiverIdentityPubkey() {
	m.receiver_identity_pubkey = nil
}

// SetTotalValue sets the "total_value" field.
func (m *TransferMutation) SetTotalValue(u uint64) {
	m.total_value = &u
	m.addtotal_value = nil
}

// TotalValue returns the value of the "total_value" field in the mutation.
func (m *TransferMutation) TotalValue() (r uint64, exists bool) {
	v := m.total_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalValue returns the old "total_value" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTotalValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalValue: %w", err)
	}
	return oldValue.TotalValue, nil
}

// AddTotalValue adds u to the "total_value" field.
func (m *TransferMutation) AddTotalValue(u int64) {
	if m.addtotal_value != nil {
		*m.addtotal_value += u
	} else {
		m.addtotal_value = &u
	}
}

// AddedTotalValue returns the value that was added to the "total_value" field in this mutation.
func (m *TransferMutation) AddedTotalValue() (r int64, exists bool) {
	v := m.addtotal_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalValue resets all changes to the "total_value" field.
func (m *TransferMutation) ResetTotalValue() {
	m.total_value = nil
	m.addtotal_value = nil
}

// SetStatus sets the "status" field.
func (m *TransferMutation) SetStatus(ss schema.TransferStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferMutation) Status() (r schema.TransferStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldStatus(ctx context.Context) (v schema.TransferStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferMutation) ResetStatus() {
	m.status = nil
}

// SetExpiryTime sets the "expiry_time" field.
func (m *TransferMutation) SetExpiryTime(t time.Time) {
	m.expiry_time = &t
}

// ExpiryTime returns the value of the "expiry_time" field in the mutation.
func (m *TransferMutation) ExpiryTime() (r time.Time, exists bool) {
	v := m.expiry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryTime returns the old "expiry_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryTime: %w", err)
	}
	return oldValue.ExpiryTime, nil
}

// ResetExpiryTime resets all changes to the "expiry_time" field.
func (m *TransferMutation) ResetExpiryTime() {
	m.expiry_time = nil
}

// SetCompletionTime sets the "completion_time" field.
func (m *TransferMutation) SetCompletionTime(t time.Time) {
	m.completion_time = &t
}

// CompletionTime returns the value of the "completion_time" field in the mutation.
func (m *TransferMutation) CompletionTime() (r time.Time, exists bool) {
	v := m.completion_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTime returns the old "completion_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCompletionTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTime: %w", err)
	}
	return oldValue.CompletionTime, nil
}

// ClearCompletionTime clears the value of the "completion_time" field.
func (m *TransferMutation) ClearCompletionTime() {
	m.completion_time = nil
	m.clearedFields[transfer.FieldCompletionTime] = struct{}{}
}

// CompletionTimeCleared returns if the "completion_time" field was cleared in this mutation.
func (m *TransferMutation) CompletionTimeCleared() bool {
	_, ok := m.clearedFields[transfer.FieldCompletionTime]
	return ok
}

// ResetCompletionTime resets all changes to the "completion_time" field.
func (m *TransferMutation) ResetCompletionTime() {
	m.completion_time = nil
	delete(m.clearedFields, transfer.FieldCompletionTime)
}

// AddTransferLeafeIDs adds the "transfer_leaves" edge to the TransferLeaf entity by ids.
func (m *TransferMutation) AddTransferLeafeIDs(ids ...uuid.UUID) {
	if m.transfer_leaves == nil {
		m.transfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transfer_leaves[ids[i]] = struct{}{}
	}
}

// ClearTransferLeaves clears the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) ClearTransferLeaves() {
	m.clearedtransfer_leaves = true
}

// TransferLeavesCleared reports if the "transfer_leaves" edge to the TransferLeaf entity was cleared.
func (m *TransferMutation) TransferLeavesCleared() bool {
	return m.clearedtransfer_leaves
}

// RemoveTransferLeafeIDs removes the "transfer_leaves" edge to the TransferLeaf entity by IDs.
func (m *TransferMutation) RemoveTransferLeafeIDs(ids ...uuid.UUID) {
	if m.removedtransfer_leaves == nil {
		m.removedtransfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transfer_leaves, ids[i])
		m.removedtransfer_leaves[ids[i]] = struct{}{}
	}
}

// RemovedTransferLeaves returns the removed IDs of the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) RemovedTransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.removedtransfer_leaves {
		ids = append(ids, id)
	}
	return
}

// TransferLeavesIDs returns the "transfer_leaves" edge IDs in the mutation.
func (m *TransferMutation) TransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.transfer_leaves {
		ids = append(ids, id)
	}
	return
}

// ResetTransferLeaves resets all changes to the "transfer_leaves" edge.
func (m *TransferMutation) ResetTransferLeaves() {
	m.transfer_leaves = nil
	m.clearedtransfer_leaves = false
	m.removedtransfer_leaves = nil
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transfer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, transfer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transfer.FieldUpdateTime)
	}
	if m.sender_identity_pubkey != nil {
		fields = append(fields, transfer.FieldSenderIdentityPubkey)
	}
	if m.receiver_identity_pubkey != nil {
		fields = append(fields, transfer.FieldReceiverIdentityPubkey)
	}
	if m.total_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	if m.status != nil {
		fields = append(fields, transfer.FieldStatus)
	}
	if m.expiry_time != nil {
		fields = append(fields, transfer.FieldExpiryTime)
	}
	if m.completion_time != nil {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreateTime:
		return m.CreateTime()
	case transfer.FieldUpdateTime:
		return m.UpdateTime()
	case transfer.FieldSenderIdentityPubkey:
		return m.SenderIdentityPubkey()
	case transfer.FieldReceiverIdentityPubkey:
		return m.ReceiverIdentityPubkey()
	case transfer.FieldTotalValue:
		return m.TotalValue()
	case transfer.FieldStatus:
		return m.Status()
	case transfer.FieldExpiryTime:
		return m.ExpiryTime()
	case transfer.FieldCompletionTime:
		return m.CompletionTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transfer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transfer.FieldSenderIdentityPubkey:
		return m.OldSenderIdentityPubkey(ctx)
	case transfer.FieldReceiverIdentityPubkey:
		return m.OldReceiverIdentityPubkey(ctx)
	case transfer.FieldTotalValue:
		return m.OldTotalValue(ctx)
	case transfer.FieldStatus:
		return m.OldStatus(ctx)
	case transfer.FieldExpiryTime:
		return m.OldExpiryTime(ctx)
	case transfer.FieldCompletionTime:
		return m.OldCompletionTime(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transfer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transfer.FieldSenderIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderIdentityPubkey(v)
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverIdentityPubkey(v)
		return nil
	case transfer.FieldTotalValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalValue(v)
		return nil
	case transfer.FieldStatus:
		v, ok := value.(schema.TransferStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transfer.FieldExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryTime(v)
		return nil
	case transfer.FieldCompletionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTime(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldTotalValue:
		return m.AddedTotalValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldTotalValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalValue(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfer.FieldCompletionTime) {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	switch name {
	case transfer.FieldCompletionTime:
		m.ClearCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transfer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transfer.FieldSenderIdentityPubkey:
		m.ResetSenderIdentityPubkey()
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		m.ResetReceiverIdentityPubkey()
		return nil
	case transfer.FieldTotalValue:
		m.ResetTotalValue()
		return nil
	case transfer.FieldStatus:
		m.ResetStatus()
		return nil
	case transfer.FieldExpiryTime:
		m.ResetExpiryTime()
		return nil
	case transfer.FieldCompletionTime:
		m.ResetCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.transfer_leaves))
		for id := range m.transfer_leaves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.removedtransfer_leaves))
		for id := range m.removedtransfer_leaves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransfer_leaves {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	switch name {
	case transfer.EdgeTransferLeaves:
		return m.clearedtransfer_leaves
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	switch name {
	case transfer.EdgeTransferLeaves:
		m.ResetTransferLeaves()
		return nil
	}
	return fmt.Errorf("unknown Transfer edge %s", name)
}

// TransferLeafMutation represents an operation that mutates the TransferLeaf nodes in the graph.
type TransferLeafMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	create_time     *time.Time
	update_time     *time.Time
	secret_cipher   *[]byte
	signature       *[]byte
	clearedFields   map[string]struct{}
	transfer        *uuid.UUID
	clearedtransfer bool
	leaf            *uuid.UUID
	clearedleaf     bool
	done            bool
	oldValue        func(context.Context) (*TransferLeaf, error)
	predicates      []predicate.TransferLeaf
}

var _ ent.Mutation = (*TransferLeafMutation)(nil)

// transferleafOption allows management of the mutation configuration using functional options.
type transferleafOption func(*TransferLeafMutation)

// newTransferLeafMutation creates new mutation for the TransferLeaf entity.
func newTransferLeafMutation(c config, op Op, opts ...transferleafOption) *TransferLeafMutation {
	m := &TransferLeafMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferLeaf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferLeafID sets the ID field of the mutation.
func withTransferLeafID(id uuid.UUID) transferleafOption {
	return func(m *TransferLeafMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferLeaf
		)
		m.oldValue = func(ctx context.Context) (*TransferLeaf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferLeaf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferLeaf sets the old TransferLeaf of the mutation.
func withTransferLeaf(node *TransferLeaf) transferleafOption {
	return func(m *TransferLeafMutation) {
		m.oldValue = func(context.Context) (*TransferLeaf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferLeafMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferLeafMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransferLeaf entities.
func (m *TransferLeafMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferLeafMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferLeafMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransferLeaf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferLeafMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferLeafMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferLeafMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferLeafMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferLeafMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferLeafMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSecretCipher sets the "secret_cipher" field.
func (m *TransferLeafMutation) SetSecretCipher(b []byte) {
	m.secret_cipher = &b
}

// SecretCipher returns the value of the "secret_cipher" field in the mutation.
func (m *TransferLeafMutation) SecretCipher() (r []byte, exists bool) {
	v := m.secret_cipher
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretCipher returns the old "secret_cipher" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSecretCipher(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretCipher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretCipher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretCipher: %w", err)
	}
	return oldValue.SecretCipher, nil
}

// ResetSecretCipher resets all changes to the "secret_cipher" field.
func (m *TransferLeafMutation) ResetSecretCipher() {
	m.secret_cipher = nil
}

// SetSignature sets the "signature" field.
func (m *TransferLeafMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *TransferLeafMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "signature" field.
func (m *TransferLeafMutation) ResetSignature() {
	m.signature = nil
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *TransferLeafMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *TransferLeafMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *TransferLeafMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *TransferLeafMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *TransferLeafMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// SetLeafID sets the "leaf" edge to the TreeNode entity by id.
func (m *TransferLeafMutation) SetLeafID(id uuid.UUID) {
	m.leaf = &id
}

// ClearLeaf clears the "leaf" edge to the TreeNode entity.
func (m *TransferLeafMutation) ClearLeaf() {
	m.clearedleaf = true
}

// LeafCleared reports if the "leaf" edge to the TreeNode entity was cleared.
func (m *TransferLeafMutation) LeafCleared() bool {
	return m.clearedleaf
}

// LeafID returns the "leaf" edge ID in the mutation.
func (m *TransferLeafMutation) LeafID() (id uuid.UUID, exists bool) {
	if m.leaf != nil {
		return *m.leaf, true
	}
	return
}

// LeafIDs returns the "leaf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeafID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) LeafIDs() (ids []uuid.UUID) {
	if id := m.leaf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeaf resets all changes to the "leaf" edge.
func (m *TransferLeafMutation) ResetLeaf() {
	m.leaf = nil
	m.clearedleaf = false
}

// Where appends a list predicates to the TransferLeafMutation builder.
func (m *TransferLeafMutation) Where(ps ...predicate.TransferLeaf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferLeafMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferLeafMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransferLeaf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferLeafMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferLeafMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransferLeaf).
func (m *TransferLeafMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferLeafMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, transferleaf.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transferleaf.FieldUpdateTime)
	}
	if m.secret_cipher != nil {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.signature != nil {
		fields = append(fields, transferleaf.FieldSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferLeafMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.CreateTime()
	case transferleaf.FieldUpdateTime:
		return m.UpdateTime()
	case transferleaf.FieldSecretCipher:
		return m.SecretCipher()
	case transferleaf.FieldSignature:
		return m.Signature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferLeafMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transferleaf.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transferleaf.FieldSecretCipher:
		return m.OldSecretCipher(ctx)
	case transferleaf.FieldSignature:
		return m.OldSignature(ctx)
	}
	return nil, fmt.Errorf("unknown TransferLeaf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transferleaf.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transferleaf.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transferleaf.FieldSecretCipher:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretCipher(v)
		return nil
	case transferleaf.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferLeafMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferLeafMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransferLeaf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferLeafMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferLeafMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferLeafMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransferLeaf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferLeafMutation) ResetField(name string) error {
	switch name {
	case transferleaf.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transferleaf.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transferleaf.FieldSecretCipher:
		m.ResetSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ResetSignature()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferLeafMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transfer != nil {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.leaf != nil {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferLeafMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transferleaf.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	case transferleaf.EdgeLeaf:
		if id := m.leaf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferLeafMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferLeafMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferLeafMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransfer {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.clearedleaf {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferLeafMutation) EdgeCleared(name string) bool {
	switch name {
	case transferleaf.EdgeTransfer:
		return m.clearedtransfer
	case transferleaf.EdgeLeaf:
		return m.clearedleaf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferLeafMutation) ClearEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ClearTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ClearLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferLeafMutation) ResetEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ResetTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ResetLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf edge %s", name)
}

// TreeMutation represents an operation that mutates the Tree nodes in the graph.
type TreeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	owner_identity_pubkey *[]byte
	clearedFields         map[string]struct{}
	root                  *uuid.UUID
	clearedroot           bool
	nodes                 map[uuid.UUID]struct{}
	removednodes          map[uuid.UUID]struct{}
	clearednodes          bool
	done                  bool
	oldValue              func(context.Context) (*Tree, error)
	predicates            []predicate.Tree
}

var _ ent.Mutation = (*TreeMutation)(nil)

// treeOption allows management of the mutation configuration using functional options.
type treeOption func(*TreeMutation)

// newTreeMutation creates new mutation for the Tree entity.
func newTreeMutation(c config, op Op, opts ...treeOption) *TreeMutation {
	m := &TreeMutation{
		config:        c,
		op:            op,
		typ:           TypeTree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeID sets the ID field of the mutation.
func withTreeID(id uuid.UUID) treeOption {
	return func(m *TreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Tree
		)
		m.oldValue = func(ctx context.Context) (*Tree, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTree sets the old Tree of the mutation.
func withTree(node *Tree) treeOption {
	return func(m *TreeMutation) {
		m.oldValue = func(context.Context) (*Tree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tree entities.
func (m *TreeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tree.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetRootID sets the "root" edge to the TreeNode entity by id.
func (m *TreeMutation) SetRootID(id uuid.UUID) {
	m.root = &id
}

// ClearRoot clears the "root" edge to the TreeNode entity.
func (m *TreeMutation) ClearRoot() {
	m.clearedroot = true
}

// RootCleared reports if the "root" edge to the TreeNode entity was cleared.
func (m *TreeMutation) RootCleared() bool {
	return m.clearedroot
}

// RootID returns the "root" edge ID in the mutation.
func (m *TreeMutation) RootID() (id uuid.UUID, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *TreeMutation) RootIDs() (ids []uuid.UUID) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *TreeMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddNodeIDs adds the "nodes" edge to the TreeNode entity by ids.
func (m *TreeMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the TreeNode entity was cleared.
func (m *TreeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the TreeNode entity by IDs.
func (m *TreeMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *TreeMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *TreeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the TreeMutation builder.
func (m *TreeMutation) Where(ps ...predicate.Tree) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tree, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tree).
func (m *TreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, tree.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tree.FieldUpdateTime)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, tree.FieldOwnerIdentityPubkey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tree.FieldCreateTime:
		return m.CreateTime()
	case tree.FieldUpdateTime:
		return m.UpdateTime()
	case tree.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tree.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tree.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tree.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	}
	return nil, fmt.Errorf("unknown Tree field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tree.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tree.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tree.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tree nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeMutation) ResetField(name string) error {
	switch name {
	case tree.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tree.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tree.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.root != nil {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.nodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroot {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.clearednodes {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeMutation) EdgeCleared(name string) bool {
	switch name {
	case tree.EdgeRoot:
		return m.clearedroot
	case tree.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeMutation) ClearEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ClearRoot()
		return nil
	}
	return fmt.Errorf("unknown Tree unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeMutation) ResetEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ResetRoot()
		return nil
	case tree.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Tree edge %s", name)
}

// TreeNodeMutation represents an operation that mutates the TreeNode nodes in the graph.
type TreeNodeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	value                   *uint64
	addvalue                *int64
	status                  *schema.TreeNodeStatus
	verifying_pubkey        *[]byte
	owner_identity_pubkey   *[]byte
	owner_signing_pubkey    *[]byte
	raw_tx                  *[]byte
	vout                    *uint16
	addvout                 *int16
	raw_refund_tx           *[]byte
	clearedFields           map[string]struct{}
	tree                    *uuid.UUID
	clearedtree             bool
	parent                  *uuid.UUID
	clearedparent           bool
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	children                map[uuid.UUID]struct{}
	removedchildren         map[uuid.UUID]struct{}
	clearedchildren         bool
	done                    bool
	oldValue                func(context.Context) (*TreeNode, error)
	predicates              []predicate.TreeNode
}

var _ ent.Mutation = (*TreeNodeMutation)(nil)

// treenodeOption allows management of the mutation configuration using functional options.
type treenodeOption func(*TreeNodeMutation)

// newTreeNodeMutation creates new mutation for the TreeNode entity.
func newTreeNodeMutation(c config, op Op, opts ...treenodeOption) *TreeNodeMutation {
	m := &TreeNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTreeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeNodeID sets the ID field of the mutation.
func withTreeNodeID(id uuid.UUID) treenodeOption {
	return func(m *TreeNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TreeNode
		)
		m.oldValue = func(ctx context.Context) (*TreeNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreeNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreeNode sets the old TreeNode of the mutation.
func withTreeNode(node *TreeNode) treenodeOption {
	return func(m *TreeNodeMutation) {
		m.oldValue = func(context.Context) (*TreeNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreeNode entities.
func (m *TreeNodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeNodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeNodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreeNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeNodeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeNodeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeNodeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeNodeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeNodeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeNodeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetValue sets the "value" field.
func (m *TreeNodeMutation) SetValue(u uint64) {
	m.value = &u
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *TreeNodeMutation) Value() (r uint64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds u to the "value" field.
func (m *TreeNodeMutation) AddValue(u int64) {
	if m.addvalue != nil {
		*m.addvalue += u
	} else {
		m.addvalue = &u
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *TreeNodeMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *TreeNodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *TreeNodeMutation) SetStatus(sns schema.TreeNodeStatus) {
	m.status = &sns
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeNodeMutation) Status() (r schema.TreeNodeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldStatus(ctx context.Context) (v schema.TreeNodeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeNodeMutation) ResetStatus() {
	m.status = nil
}

// SetVerifyingPubkey sets the "verifying_pubkey" field.
func (m *TreeNodeMutation) SetVerifyingPubkey(b []byte) {
	m.verifying_pubkey = &b
}

// VerifyingPubkey returns the value of the "verifying_pubkey" field in the mutation.
func (m *TreeNodeMutation) VerifyingPubkey() (r []byte, exists bool) {
	v := m.verifying_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyingPubkey returns the old "verifying_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVerifyingPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyingPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyingPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyingPubkey: %w", err)
	}
	return oldValue.VerifyingPubkey, nil
}

// ResetVerifyingPubkey resets all changes to the "verifying_pubkey" field.
func (m *TreeNodeMutation) ResetVerifyingPubkey() {
	m.verifying_pubkey = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) SetOwnerSigningPubkey(b []byte) {
	m.owner_signing_pubkey = &b
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerSigningPubkey() (r []byte, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerSigningPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetRawTx sets the "raw_tx" field.
func (m *TreeNodeMutation) SetRawTx(b []byte) {
	m.raw_tx = &b
}

// RawTx returns the value of the "raw_tx" field in the mutation.
func (m *TreeNodeMutation) RawTx() (r []byte, exists bool) {
	v := m.raw_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawTx returns the old "raw_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawTx: %w", err)
	}
	return oldValue.RawTx, nil
}

// ResetRawTx resets all changes to the "raw_tx" field.
func (m *TreeNodeMutation) ResetRawTx() {
	m.raw_tx = nil
}

// SetVout sets the "vout" field.
func (m *TreeNodeMutation) SetVout(u uint16) {
	m.vout = &u
	m.addvout = nil
}

// Vout returns the value of the "vout" field in the mutation.
func (m *TreeNodeMutation) Vout() (r uint16, exists bool) {
	v := m.vout
	if v == nil {
		return
	}
	return *v, true
}

// OldVout returns the old "vout" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVout(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVout: %w", err)
	}
	return oldValue.Vout, nil
}

// AddVout adds u to the "vout" field.
func (m *TreeNodeMutation) AddVout(u int16) {
	if m.addvout != nil {
		*m.addvout += u
	} else {
		m.addvout = &u
	}
}

// AddedVout returns the value that was added to the "vout" field in this mutation.
func (m *TreeNodeMutation) AddedVout() (r int16, exists bool) {
	v := m.addvout
	if v == nil {
		return
	}
	return *v, true
}

// ResetVout resets all changes to the "vout" field.
func (m *TreeNodeMutation) ResetVout() {
	m.vout = nil
	m.addvout = nil
}

// SetRawRefundTx sets the "raw_refund_tx" field.
func (m *TreeNodeMutation) SetRawRefundTx(b []byte) {
	m.raw_refund_tx = &b
}

// RawRefundTx returns the value of the "raw_refund_tx" field in the mutation.
func (m *TreeNodeMutation) RawRefundTx() (r []byte, exists bool) {
	v := m.raw_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawRefundTx returns the old "raw_refund_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawRefundTx: %w", err)
	}
	return oldValue.RawRefundTx, nil
}

// ResetRawRefundTx resets all changes to the "raw_refund_tx" field.
func (m *TreeNodeMutation) ResetRawRefundTx() {
	m.raw_refund_tx = nil
}

// SetTreeID sets the "tree" edge to the Tree entity by id.
func (m *TreeNodeMutation) SetTreeID(id uuid.UUID) {
	m.tree = &id
}

// ClearTree clears the "tree" edge to the Tree entity.
func (m *TreeNodeMutation) ClearTree() {
	m.clearedtree = true
}

// TreeCleared reports if the "tree" edge to the Tree entity was cleared.
func (m *TreeNodeMutation) TreeCleared() bool {
	return m.clearedtree
}

// TreeID returns the "tree" edge ID in the mutation.
func (m *TreeNodeMutation) TreeID() (id uuid.UUID, exists bool) {
	if m.tree != nil {
		return *m.tree, true
	}
	return
}

// TreeIDs returns the "tree" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) TreeIDs() (ids []uuid.UUID) {
	if id := m.tree; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTree resets all changes to the "tree" edge.
func (m *TreeNodeMutation) ResetTree() {
	m.tree = nil
	m.clearedtree = false
}

// SetParentID sets the "parent" edge to the TreeNode entity by id.
func (m *TreeNodeMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TreeNodeMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TreeNodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *TreeNodeMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *TreeNodeMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *TreeNodeMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *TreeNodeMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *TreeNodeMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// AddChildIDs adds the "children" edge to the TreeNode entity by ids.
func (m *TreeNodeMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TreeNode entity by IDs.
func (m *TreeNodeMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TreeNodeMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TreeNodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the TreeNodeMutation builder.
func (m *TreeNodeMutation) Where(ps ...predicate.TreeNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreeNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreeNode).
func (m *TreeNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeNodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, treenode.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, treenode.FieldUpdateTime)
	}
	if m.value != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, treenode.FieldStatus)
	}
	if m.verifying_pubkey != nil {
		fields = append(fields, treenode.FieldVerifyingPubkey)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerSigningPubkey)
	}
	if m.raw_tx != nil {
		fields = append(fields, treenode.FieldRawTx)
	}
	if m.vout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	if m.raw_refund_tx != nil {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldCreateTime:
		return m.CreateTime()
	case treenode.FieldUpdateTime:
		return m.UpdateTime()
	case treenode.FieldValue:
		return m.Value()
	case treenode.FieldStatus:
		return m.Status()
	case treenode.FieldVerifyingPubkey:
		return m.VerifyingPubkey()
	case treenode.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case treenode.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	case treenode.FieldRawTx:
		return m.RawTx()
	case treenode.FieldVout:
		return m.Vout()
	case treenode.FieldRawRefundTx:
		return m.RawRefundTx()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treenode.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case treenode.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case treenode.FieldValue:
		return m.OldValue(ctx)
	case treenode.FieldStatus:
		return m.OldStatus(ctx)
	case treenode.FieldVerifyingPubkey:
		return m.OldVerifyingPubkey(ctx)
	case treenode.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case treenode.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	case treenode.FieldRawTx:
		return m.OldRawTx(ctx)
	case treenode.FieldVout:
		return m.OldVout(ctx)
	case treenode.FieldRawRefundTx:
		return m.OldRawRefundTx(ctx)
	}
	return nil, fmt.Errorf("unknown TreeNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case treenode.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case treenode.FieldValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case treenode.FieldStatus:
		v, ok := value.(schema.TreeNodeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case treenode.FieldVerifyingPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyingPubkey(v)
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case treenode.FieldOwnerSigningPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	case treenode.FieldRawTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawTx(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVout(v)
		return nil
	case treenode.FieldRawRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawRefundTx(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeNodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.addvout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldValue:
		return m.AddedValue()
	case treenode.FieldVout:
		return m.AddedVout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVout(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreeNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeNodeMutation) ResetField(name string) error {
	switch name {
	case treenode.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case treenode.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case treenode.FieldValue:
		m.ResetValue()
		return nil
	case treenode.FieldStatus:
		m.ResetStatus()
		return nil
	case treenode.FieldVerifyingPubkey:
		m.ResetVerifyingPubkey()
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case treenode.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	case treenode.FieldRawTx:
		m.ResetRawTx()
		return nil
	case treenode.FieldVout:
		m.ResetVout()
		return nil
	case treenode.FieldRawRefundTx:
		m.ResetRawRefundTx()
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tree != nil {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.parent != nil {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.signing_keyshare != nil {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.children != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeTree:
		if id := m.tree; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtree {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.clearedparent {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.clearedsigning_keyshare {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.clearedchildren {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case treenode.EdgeTree:
		return m.clearedtree
	case treenode.EdgeParent:
		return m.clearedparent
	case treenode.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	case treenode.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeNodeMutation) ClearEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ClearTree()
		return nil
	case treenode.EdgeParent:
		m.ClearParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown TreeNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeNodeMutation) ResetEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ResetTree()
		return nil
	case treenode.EdgeParent:
		m.ResetParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	case treenode.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown TreeNode edge %s", name)
}
