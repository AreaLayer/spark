// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/lightsparkdev/spark-go/so/ent/cooperativeexit"
	"github.com/lightsparkdev/spark-go/so/ent/depositaddress"
	"github.com/lightsparkdev/spark-go/so/ent/predicate"
	"github.com/lightsparkdev/spark-go/so/ent/preimagerequest"
	"github.com/lightsparkdev/spark-go/so/ent/preimageshare"
	"github.com/lightsparkdev/spark-go/so/ent/schema"
	"github.com/lightsparkdev/spark-go/so/ent/signingkeyshare"
	"github.com/lightsparkdev/spark-go/so/ent/signingnonce"
	"github.com/lightsparkdev/spark-go/so/ent/transfer"
	"github.com/lightsparkdev/spark-go/so/ent/transferleaf"
	"github.com/lightsparkdev/spark-go/so/ent/tree"
	"github.com/lightsparkdev/spark-go/so/ent/treenode"
	"github.com/lightsparkdev/spark-go/so/ent/usersignedtransaction"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCooperativeExit       = "CooperativeExit"
	TypeDepositAddress        = "DepositAddress"
	TypePreimageRequest       = "PreimageRequest"
	TypePreimageShare         = "PreimageShare"
	TypeSigningKeyshare       = "SigningKeyshare"
	TypeSigningNonce          = "SigningNonce"
	TypeTransfer              = "Transfer"
	TypeTransferLeaf          = "TransferLeaf"
	TypeTree                  = "Tree"
	TypeTreeNode              = "TreeNode"
	TypeUserSignedTransaction = "UserSignedTransaction"
)

// CooperativeExitMutation represents an operation that mutates the CooperativeExit nodes in the graph.
type CooperativeExitMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	create_time     *time.Time
	update_time     *time.Time
	exit_txid       *[]byte
	clearedFields   map[string]struct{}
	transfer        *uuid.UUID
	clearedtransfer bool
	done            bool
	oldValue        func(context.Context) (*CooperativeExit, error)
	predicates      []predicate.CooperativeExit
}

var _ ent.Mutation = (*CooperativeExitMutation)(nil)

// cooperativeexitOption allows management of the mutation configuration using functional options.
type cooperativeexitOption func(*CooperativeExitMutation)

// newCooperativeExitMutation creates new mutation for the CooperativeExit entity.
func newCooperativeExitMutation(c config, op Op, opts ...cooperativeexitOption) *CooperativeExitMutation {
	m := &CooperativeExitMutation{
		config:        c,
		op:            op,
		typ:           TypeCooperativeExit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCooperativeExitID sets the ID field of the mutation.
func withCooperativeExitID(id uuid.UUID) cooperativeexitOption {
	return func(m *CooperativeExitMutation) {
		var (
			err   error
			once  sync.Once
			value *CooperativeExit
		)
		m.oldValue = func(ctx context.Context) (*CooperativeExit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CooperativeExit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCooperativeExit sets the old CooperativeExit of the mutation.
func withCooperativeExit(node *CooperativeExit) cooperativeexitOption {
	return func(m *CooperativeExitMutation) {
		m.oldValue = func(context.Context) (*CooperativeExit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CooperativeExitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CooperativeExitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CooperativeExit entities.
func (m *CooperativeExitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CooperativeExitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CooperativeExitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CooperativeExit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CooperativeExitMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CooperativeExitMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CooperativeExitMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CooperativeExitMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CooperativeExitMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CooperativeExitMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExitTxid sets the "exit_txid" field.
func (m *CooperativeExitMutation) SetExitTxid(b []byte) {
	m.exit_txid = &b
}

// ExitTxid returns the value of the "exit_txid" field in the mutation.
func (m *CooperativeExitMutation) ExitTxid() (r []byte, exists bool) {
	v := m.exit_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldExitTxid returns the old "exit_txid" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldExitTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitTxid: %w", err)
	}
	return oldValue.ExitTxid, nil
}

// ClearExitTxid clears the value of the "exit_txid" field.
func (m *CooperativeExitMutation) ClearExitTxid() {
	m.exit_txid = nil
	m.clearedFields[cooperativeexit.FieldExitTxid] = struct{}{}
}

// ExitTxidCleared returns if the "exit_txid" field was cleared in this mutation.
func (m *CooperativeExitMutation) ExitTxidCleared() bool {
	_, ok := m.clearedFields[cooperativeexit.FieldExitTxid]
	return ok
}

// ResetExitTxid resets all changes to the "exit_txid" field.
func (m *CooperativeExitMutation) ResetExitTxid() {
	m.exit_txid = nil
	delete(m.clearedFields, cooperativeexit.FieldExitTxid)
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *CooperativeExitMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *CooperativeExitMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *CooperativeExitMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *CooperativeExitMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *CooperativeExitMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *CooperativeExitMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// Where appends a list predicates to the CooperativeExitMutation builder.
func (m *CooperativeExitMutation) Where(ps ...predicate.CooperativeExit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CooperativeExitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CooperativeExitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CooperativeExit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CooperativeExitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CooperativeExitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CooperativeExit).
func (m *CooperativeExitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CooperativeExitMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, cooperativeexit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, cooperativeexit.FieldUpdateTime)
	}
	if m.exit_txid != nil {
		fields = append(fields, cooperativeexit.FieldExitTxid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CooperativeExitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cooperativeexit.FieldCreateTime:
		return m.CreateTime()
	case cooperativeexit.FieldUpdateTime:
		return m.UpdateTime()
	case cooperativeexit.FieldExitTxid:
		return m.ExitTxid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CooperativeExitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cooperativeexit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case cooperativeexit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case cooperativeexit.FieldExitTxid:
		return m.OldExitTxid(ctx)
	}
	return nil, fmt.Errorf("unknown CooperativeExit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooperativeExitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cooperativeexit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case cooperativeexit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case cooperativeexit.FieldExitTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitTxid(v)
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CooperativeExitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CooperativeExitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooperativeExitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CooperativeExit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CooperativeExitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cooperativeexit.FieldExitTxid) {
		fields = append(fields, cooperativeexit.FieldExitTxid)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CooperativeExitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CooperativeExitMutation) ClearField(name string) error {
	switch name {
	case cooperativeexit.FieldExitTxid:
		m.ClearExitTxid()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CooperativeExitMutation) ResetField(name string) error {
	switch name {
	case cooperativeexit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case cooperativeexit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case cooperativeexit.FieldExitTxid:
		m.ResetExitTxid()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CooperativeExitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transfer != nil {
		edges = append(edges, cooperativeexit.EdgeTransfer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CooperativeExitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cooperativeexit.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CooperativeExitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CooperativeExitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CooperativeExitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransfer {
		edges = append(edges, cooperativeexit.EdgeTransfer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CooperativeExitMutation) EdgeCleared(name string) bool {
	switch name {
	case cooperativeexit.EdgeTransfer:
		return m.clearedtransfer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CooperativeExitMutation) ClearEdge(name string) error {
	switch name {
	case cooperativeexit.EdgeTransfer:
		m.ClearTransfer()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CooperativeExitMutation) ResetEdge(name string) error {
	switch name {
	case cooperativeexit.EdgeTransfer:
		m.ResetTransfer()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit edge %s", name)
}

// DepositAddressMutation represents an operation that mutates the DepositAddress nodes in the graph.
type DepositAddressMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	address                 *string
	owner_identity_pubkey   *[]byte
	owner_signing_pubkey    *[]byte
	clearedFields           map[string]struct{}
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	done                    bool
	oldValue                func(context.Context) (*DepositAddress, error)
	predicates              []predicate.DepositAddress
}

var _ ent.Mutation = (*DepositAddressMutation)(nil)

// depositaddressOption allows management of the mutation configuration using functional options.
type depositaddressOption func(*DepositAddressMutation)

// newDepositAddressMutation creates new mutation for the DepositAddress entity.
func newDepositAddressMutation(c config, op Op, opts ...depositaddressOption) *DepositAddressMutation {
	m := &DepositAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeDepositAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositAddressID sets the ID field of the mutation.
func withDepositAddressID(id uuid.UUID) depositaddressOption {
	return func(m *DepositAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *DepositAddress
		)
		m.oldValue = func(ctx context.Context) (*DepositAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DepositAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepositAddress sets the old DepositAddress of the mutation.
func withDepositAddress(node *DepositAddress) depositaddressOption {
	return func(m *DepositAddressMutation) {
		m.oldValue = func(context.Context) (*DepositAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DepositAddress entities.
func (m *DepositAddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepositAddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepositAddressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DepositAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DepositAddressMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DepositAddressMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DepositAddressMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DepositAddressMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DepositAddressMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DepositAddressMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAddress sets the "address" field.
func (m *DepositAddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *DepositAddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *DepositAddressMutation) ResetAddress() {
	m.address = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) SetOwnerSigningPubkey(b []byte) {
	m.owner_signing_pubkey = &b
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerSigningPubkey() (r []byte, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerSigningPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *DepositAddressMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *DepositAddressMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *DepositAddressMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *DepositAddressMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *DepositAddressMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *DepositAddressMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// Where appends a list predicates to the DepositAddressMutation builder.
func (m *DepositAddressMutation) Where(ps ...predicate.DepositAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepositAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepositAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DepositAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepositAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepositAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DepositAddress).
func (m *DepositAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepositAddressMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, depositaddress.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, depositaddress.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, depositaddress.FieldAddress)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerSigningPubkey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepositAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.CreateTime()
	case depositaddress.FieldUpdateTime:
		return m.UpdateTime()
	case depositaddress.FieldAddress:
		return m.Address()
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepositAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case depositaddress.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case depositaddress.FieldAddress:
		return m.OldAddress(ctx)
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	}
	return nil, fmt.Errorf("unknown DepositAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case depositaddress.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case depositaddress.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case depositaddress.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepositAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepositAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DepositAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepositAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepositAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DepositAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepositAddressMutation) ResetField(name string) error {
	switch name {
	case depositaddress.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case depositaddress.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case depositaddress.FieldAddress:
		m.ResetAddress()
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepositAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.signing_keyshare != nil {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepositAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepositAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepositAddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepositAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsigning_keyshare {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepositAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepositAddressMutation) ClearEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepositAddressMutation) ResetEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress edge %s", name)
}

// PreimageRequestMutation represents an operation that mutates the PreimageRequest nodes in the graph.
type PreimageRequestMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	clearedFields          map[string]struct{}
	transactions           map[uuid.UUID]struct{}
	removedtransactions    map[uuid.UUID]struct{}
	clearedtransactions    bool
	preimage_shares        *uuid.UUID
	clearedpreimage_shares bool
	transfers              *uuid.UUID
	clearedtransfers       bool
	done                   bool
	oldValue               func(context.Context) (*PreimageRequest, error)
	predicates             []predicate.PreimageRequest
}

var _ ent.Mutation = (*PreimageRequestMutation)(nil)

// preimagerequestOption allows management of the mutation configuration using functional options.
type preimagerequestOption func(*PreimageRequestMutation)

// newPreimageRequestMutation creates new mutation for the PreimageRequest entity.
func newPreimageRequestMutation(c config, op Op, opts ...preimagerequestOption) *PreimageRequestMutation {
	m := &PreimageRequestMutation{
		config:        c,
		op:            op,
		typ:           TypePreimageRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreimageRequestID sets the ID field of the mutation.
func withPreimageRequestID(id uuid.UUID) preimagerequestOption {
	return func(m *PreimageRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *PreimageRequest
		)
		m.oldValue = func(ctx context.Context) (*PreimageRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PreimageRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreimageRequest sets the old PreimageRequest of the mutation.
func withPreimageRequest(node *PreimageRequest) preimagerequestOption {
	return func(m *PreimageRequestMutation) {
		m.oldValue = func(context.Context) (*PreimageRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreimageRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreimageRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PreimageRequest entities.
func (m *PreimageRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreimageRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreimageRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PreimageRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreimageRequestMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreimageRequestMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreimageRequestMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreimageRequestMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreimageRequestMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreimageRequestMutation) ResetUpdateTime() {
	m.update_time = nil
}

// AddTransactionIDs adds the "transactions" edge to the UserSignedTransaction entity by ids.
func (m *PreimageRequestMutation) AddTransactionIDs(ids ...uuid.UUID) {
	if m.transactions == nil {
		m.transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the UserSignedTransaction entity.
func (m *PreimageRequestMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the UserSignedTransaction entity was cleared.
func (m *PreimageRequestMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the UserSignedTransaction entity by IDs.
func (m *PreimageRequestMutation) RemoveTransactionIDs(ids ...uuid.UUID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the UserSignedTransaction entity.
func (m *PreimageRequestMutation) RemovedTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PreimageRequestMutation) TransactionsIDs() (ids []uuid.UUID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PreimageRequestMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// SetPreimageSharesID sets the "preimage_shares" edge to the PreimageShare entity by id.
func (m *PreimageRequestMutation) SetPreimageSharesID(id uuid.UUID) {
	m.preimage_shares = &id
}

// ClearPreimageShares clears the "preimage_shares" edge to the PreimageShare entity.
func (m *PreimageRequestMutation) ClearPreimageShares() {
	m.clearedpreimage_shares = true
}

// PreimageSharesCleared reports if the "preimage_shares" edge to the PreimageShare entity was cleared.
func (m *PreimageRequestMutation) PreimageSharesCleared() bool {
	return m.clearedpreimage_shares
}

// PreimageSharesID returns the "preimage_shares" edge ID in the mutation.
func (m *PreimageRequestMutation) PreimageSharesID() (id uuid.UUID, exists bool) {
	if m.preimage_shares != nil {
		return *m.preimage_shares, true
	}
	return
}

// PreimageSharesIDs returns the "preimage_shares" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageSharesID instead. It exists only for internal usage by the builders.
func (m *PreimageRequestMutation) PreimageSharesIDs() (ids []uuid.UUID) {
	if id := m.preimage_shares; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageShares resets all changes to the "preimage_shares" edge.
func (m *PreimageRequestMutation) ResetPreimageShares() {
	m.preimage_shares = nil
	m.clearedpreimage_shares = false
}

// SetTransfersID sets the "transfers" edge to the Transfer entity by id.
func (m *PreimageRequestMutation) SetTransfersID(id uuid.UUID) {
	m.transfers = &id
}

// ClearTransfers clears the "transfers" edge to the Transfer entity.
func (m *PreimageRequestMutation) ClearTransfers() {
	m.clearedtransfers = true
}

// TransfersCleared reports if the "transfers" edge to the Transfer entity was cleared.
func (m *PreimageRequestMutation) TransfersCleared() bool {
	return m.clearedtransfers
}

// TransfersID returns the "transfers" edge ID in the mutation.
func (m *PreimageRequestMutation) TransfersID() (id uuid.UUID, exists bool) {
	if m.transfers != nil {
		return *m.transfers, true
	}
	return
}

// TransfersIDs returns the "transfers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransfersID instead. It exists only for internal usage by the builders.
func (m *PreimageRequestMutation) TransfersIDs() (ids []uuid.UUID) {
	if id := m.transfers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfers resets all changes to the "transfers" edge.
func (m *PreimageRequestMutation) ResetTransfers() {
	m.transfers = nil
	m.clearedtransfers = false
}

// Where appends a list predicates to the PreimageRequestMutation builder.
func (m *PreimageRequestMutation) Where(ps ...predicate.PreimageRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PreimageRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PreimageRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PreimageRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PreimageRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PreimageRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PreimageRequest).
func (m *PreimageRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreimageRequestMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, preimagerequest.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preimagerequest.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreimageRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preimagerequest.FieldCreateTime:
		return m.CreateTime()
	case preimagerequest.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreimageRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preimagerequest.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preimagerequest.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown PreimageRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preimagerequest.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preimagerequest.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreimageRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreimageRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PreimageRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreimageRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreimageRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreimageRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PreimageRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreimageRequestMutation) ResetField(name string) error {
	switch name {
	case preimagerequest.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preimagerequest.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreimageRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.transactions != nil {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	if m.preimage_shares != nil {
		edges = append(edges, preimagerequest.EdgePreimageShares)
	}
	if m.transfers != nil {
		edges = append(edges, preimagerequest.EdgeTransfers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreimageRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preimagerequest.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case preimagerequest.EdgePreimageShares:
		if id := m.preimage_shares; id != nil {
			return []ent.Value{*id}
		}
	case preimagerequest.EdgeTransfers:
		if id := m.transfers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreimageRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransactions != nil {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreimageRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case preimagerequest.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreimageRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtransactions {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	if m.clearedpreimage_shares {
		edges = append(edges, preimagerequest.EdgePreimageShares)
	}
	if m.clearedtransfers {
		edges = append(edges, preimagerequest.EdgeTransfers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreimageRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case preimagerequest.EdgeTransactions:
		return m.clearedtransactions
	case preimagerequest.EdgePreimageShares:
		return m.clearedpreimage_shares
	case preimagerequest.EdgeTransfers:
		return m.clearedtransfers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreimageRequestMutation) ClearEdge(name string) error {
	switch name {
	case preimagerequest.EdgePreimageShares:
		m.ClearPreimageShares()
		return nil
	case preimagerequest.EdgeTransfers:
		m.ClearTransfers()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreimageRequestMutation) ResetEdge(name string) error {
	switch name {
	case preimagerequest.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case preimagerequest.EdgePreimageShares:
		m.ResetPreimageShares()
		return nil
	case preimagerequest.EdgeTransfers:
		m.ResetTransfers()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest edge %s", name)
}

// PreimageShareMutation represents an operation that mutates the PreimageShare nodes in the graph.
type PreimageShareMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	payment_hash            *[]byte
	preimage_share          *[]byte
	threshold               *uint32
	addthreshold            *int32
	owner_identity_pubkey   *[]byte
	invoice_string          *string
	clearedFields           map[string]struct{}
	preimage_request        *uuid.UUID
	clearedpreimage_request bool
	done                    bool
	oldValue                func(context.Context) (*PreimageShare, error)
	predicates              []predicate.PreimageShare
}

var _ ent.Mutation = (*PreimageShareMutation)(nil)

// preimageshareOption allows management of the mutation configuration using functional options.
type preimageshareOption func(*PreimageShareMutation)

// newPreimageShareMutation creates new mutation for the PreimageShare entity.
func newPreimageShareMutation(c config, op Op, opts ...preimageshareOption) *PreimageShareMutation {
	m := &PreimageShareMutation{
		config:        c,
		op:            op,
		typ:           TypePreimageShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreimageShareID sets the ID field of the mutation.
func withPreimageShareID(id uuid.UUID) preimageshareOption {
	return func(m *PreimageShareMutation) {
		var (
			err   error
			once  sync.Once
			value *PreimageShare
		)
		m.oldValue = func(ctx context.Context) (*PreimageShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PreimageShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreimageShare sets the old PreimageShare of the mutation.
func withPreimageShare(node *PreimageShare) preimageshareOption {
	return func(m *PreimageShareMutation) {
		m.oldValue = func(context.Context) (*PreimageShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreimageShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreimageShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PreimageShare entities.
func (m *PreimageShareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreimageShareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreimageShareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PreimageShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreimageShareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreimageShareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreimageShareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreimageShareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreimageShareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreimageShareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPaymentHash sets the "payment_hash" field.
func (m *PreimageShareMutation) SetPaymentHash(b []byte) {
	m.payment_hash = &b
}

// PaymentHash returns the value of the "payment_hash" field in the mutation.
func (m *PreimageShareMutation) PaymentHash() (r []byte, exists bool) {
	v := m.payment_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentHash returns the old "payment_hash" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldPaymentHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentHash: %w", err)
	}
	return oldValue.PaymentHash, nil
}

// ResetPaymentHash resets all changes to the "payment_hash" field.
func (m *PreimageShareMutation) ResetPaymentHash() {
	m.payment_hash = nil
}

// SetPreimageShare sets the "preimage_share" field.
func (m *PreimageShareMutation) SetPreimageShare(b []byte) {
	m.preimage_share = &b
}

// PreimageShare returns the value of the "preimage_share" field in the mutation.
func (m *PreimageShareMutation) PreimageShare() (r []byte, exists bool) {
	v := m.preimage_share
	if v == nil {
		return
	}
	return *v, true
}

// OldPreimageShare returns the old "preimage_share" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldPreimageShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreimageShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreimageShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreimageShare: %w", err)
	}
	return oldValue.PreimageShare, nil
}

// ResetPreimageShare resets all changes to the "preimage_share" field.
func (m *PreimageShareMutation) ResetPreimageShare() {
	m.preimage_share = nil
}

// SetThreshold sets the "threshold" field.
func (m *PreimageShareMutation) SetThreshold(u uint32) {
	m.threshold = &u
	m.addthreshold = nil
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *PreimageShareMutation) Threshold() (r uint32, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldThreshold(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// AddThreshold adds u to the "threshold" field.
func (m *PreimageShareMutation) AddThreshold(u int32) {
	if m.addthreshold != nil {
		*m.addthreshold += u
	} else {
		m.addthreshold = &u
	}
}

// AddedThreshold returns the value that was added to the "threshold" field in this mutation.
func (m *PreimageShareMutation) AddedThreshold() (r int32, exists bool) {
	v := m.addthreshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *PreimageShareMutation) ResetThreshold() {
	m.threshold = nil
	m.addthreshold = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *PreimageShareMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *PreimageShareMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *PreimageShareMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetInvoiceString sets the "invoice_string" field.
func (m *PreimageShareMutation) SetInvoiceString(s string) {
	m.invoice_string = &s
}

// InvoiceString returns the value of the "invoice_string" field in the mutation.
func (m *PreimageShareMutation) InvoiceString() (r string, exists bool) {
	v := m.invoice_string
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceString returns the old "invoice_string" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldInvoiceString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceString: %w", err)
	}
	return oldValue.InvoiceString, nil
}

// ResetInvoiceString resets all changes to the "invoice_string" field.
func (m *PreimageShareMutation) ResetInvoiceString() {
	m.invoice_string = nil
}

// SetPreimageRequestID sets the "preimage_request" edge to the PreimageRequest entity by id.
func (m *PreimageShareMutation) SetPreimageRequestID(id uuid.UUID) {
	m.preimage_request = &id
}

// ClearPreimageRequest clears the "preimage_request" edge to the PreimageRequest entity.
func (m *PreimageShareMutation) ClearPreimageRequest() {
	m.clearedpreimage_request = true
}

// PreimageRequestCleared reports if the "preimage_request" edge to the PreimageRequest entity was cleared.
func (m *PreimageShareMutation) PreimageRequestCleared() bool {
	return m.clearedpreimage_request
}

// PreimageRequestID returns the "preimage_request" edge ID in the mutation.
func (m *PreimageShareMutation) PreimageRequestID() (id uuid.UUID, exists bool) {
	if m.preimage_request != nil {
		return *m.preimage_request, true
	}
	return
}

// PreimageRequestIDs returns the "preimage_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageRequestID instead. It exists only for internal usage by the builders.
func (m *PreimageShareMutation) PreimageRequestIDs() (ids []uuid.UUID) {
	if id := m.preimage_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageRequest resets all changes to the "preimage_request" edge.
func (m *PreimageShareMutation) ResetPreimageRequest() {
	m.preimage_request = nil
	m.clearedpreimage_request = false
}

// Where appends a list predicates to the PreimageShareMutation builder.
func (m *PreimageShareMutation) Where(ps ...predicate.PreimageShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PreimageShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PreimageShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PreimageShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PreimageShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PreimageShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PreimageShare).
func (m *PreimageShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreimageShareMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, preimageshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preimageshare.FieldUpdateTime)
	}
	if m.payment_hash != nil {
		fields = append(fields, preimageshare.FieldPaymentHash)
	}
	if m.preimage_share != nil {
		fields = append(fields, preimageshare.FieldPreimageShare)
	}
	if m.threshold != nil {
		fields = append(fields, preimageshare.FieldThreshold)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, preimageshare.FieldOwnerIdentityPubkey)
	}
	if m.invoice_string != nil {
		fields = append(fields, preimageshare.FieldInvoiceString)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreimageShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preimageshare.FieldCreateTime:
		return m.CreateTime()
	case preimageshare.FieldUpdateTime:
		return m.UpdateTime()
	case preimageshare.FieldPaymentHash:
		return m.PaymentHash()
	case preimageshare.FieldPreimageShare:
		return m.PreimageShare()
	case preimageshare.FieldThreshold:
		return m.Threshold()
	case preimageshare.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case preimageshare.FieldInvoiceString:
		return m.InvoiceString()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreimageShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preimageshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preimageshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case preimageshare.FieldPaymentHash:
		return m.OldPaymentHash(ctx)
	case preimageshare.FieldPreimageShare:
		return m.OldPreimageShare(ctx)
	case preimageshare.FieldThreshold:
		return m.OldThreshold(ctx)
	case preimageshare.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case preimageshare.FieldInvoiceString:
		return m.OldInvoiceString(ctx)
	}
	return nil, fmt.Errorf("unknown PreimageShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preimageshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preimageshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case preimageshare.FieldPaymentHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentHash(v)
		return nil
	case preimageshare.FieldPreimageShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreimageShare(v)
		return nil
	case preimageshare.FieldThreshold:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case preimageshare.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case preimageshare.FieldInvoiceString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceString(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreimageShareMutation) AddedFields() []string {
	var fields []string
	if m.addthreshold != nil {
		fields = append(fields, preimageshare.FieldThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreimageShareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case preimageshare.FieldThreshold:
		return m.AddedThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case preimageshare.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreimageShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreimageShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreimageShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PreimageShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreimageShareMutation) ResetField(name string) error {
	switch name {
	case preimageshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preimageshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case preimageshare.FieldPaymentHash:
		m.ResetPaymentHash()
		return nil
	case preimageshare.FieldPreimageShare:
		m.ResetPreimageShare()
		return nil
	case preimageshare.FieldThreshold:
		m.ResetThreshold()
		return nil
	case preimageshare.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case preimageshare.FieldInvoiceString:
		m.ResetInvoiceString()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreimageShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.preimage_request != nil {
		edges = append(edges, preimageshare.EdgePreimageRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreimageShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preimageshare.EdgePreimageRequest:
		if id := m.preimage_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreimageShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreimageShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreimageShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpreimage_request {
		edges = append(edges, preimageshare.EdgePreimageRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreimageShareMutation) EdgeCleared(name string) bool {
	switch name {
	case preimageshare.EdgePreimageRequest:
		return m.clearedpreimage_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreimageShareMutation) ClearEdge(name string) error {
	switch name {
	case preimageshare.EdgePreimageRequest:
		m.ClearPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreimageShareMutation) ResetEdge(name string) error {
	switch name {
	case preimageshare.EdgePreimageRequest:
		m.ResetPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare edge %s", name)
}

// SigningKeyshareMutation represents an operation that mutates the SigningKeyshare nodes in the graph.
type SigningKeyshareMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	create_time          *time.Time
	update_time          *time.Time
	status               *schema.SigningKeyshareStatus
	secret_share         *[]byte
	public_shares        *map[string][]uint8
	public_key           *[]byte
	min_signers          *uint32
	addmin_signers       *int32
	coordinator_index    *uint64
	addcoordinator_index *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SigningKeyshare, error)
	predicates           []predicate.SigningKeyshare
}

var _ ent.Mutation = (*SigningKeyshareMutation)(nil)

// signingkeyshareOption allows management of the mutation configuration using functional options.
type signingkeyshareOption func(*SigningKeyshareMutation)

// newSigningKeyshareMutation creates new mutation for the SigningKeyshare entity.
func newSigningKeyshareMutation(c config, op Op, opts ...signingkeyshareOption) *SigningKeyshareMutation {
	m := &SigningKeyshareMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningKeyshare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningKeyshareID sets the ID field of the mutation.
func withSigningKeyshareID(id uuid.UUID) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningKeyshare
		)
		m.oldValue = func(ctx context.Context) (*SigningKeyshare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningKeyshare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningKeyshare sets the old SigningKeyshare of the mutation.
func withSigningKeyshare(node *SigningKeyshare) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		m.oldValue = func(context.Context) (*SigningKeyshare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningKeyshareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningKeyshareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningKeyshare entities.
func (m *SigningKeyshareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningKeyshareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningKeyshareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningKeyshare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningKeyshareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningKeyshareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningKeyshareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningKeyshareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningKeyshareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningKeyshareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *SigningKeyshareMutation) SetStatus(sks schema.SigningKeyshareStatus) {
	m.status = &sks
}

// Status returns the value of the "status" field in the mutation.
func (m *SigningKeyshareMutation) Status() (r schema.SigningKeyshareStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldStatus(ctx context.Context) (v schema.SigningKeyshareStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SigningKeyshareMutation) ResetStatus() {
	m.status = nil
}

// SetSecretShare sets the "secret_share" field.
func (m *SigningKeyshareMutation) SetSecretShare(b []byte) {
	m.secret_share = &b
}

// SecretShare returns the value of the "secret_share" field in the mutation.
func (m *SigningKeyshareMutation) SecretShare() (r []byte, exists bool) {
	v := m.secret_share
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretShare returns the old "secret_share" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldSecretShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretShare: %w", err)
	}
	return oldValue.SecretShare, nil
}

// ResetSecretShare resets all changes to the "secret_share" field.
func (m *SigningKeyshareMutation) ResetSecretShare() {
	m.secret_share = nil
}

// SetPublicShares sets the "public_shares" field.
func (m *SigningKeyshareMutation) SetPublicShares(value map[string][]uint8) {
	m.public_shares = &value
}

// PublicShares returns the value of the "public_shares" field in the mutation.
func (m *SigningKeyshareMutation) PublicShares() (r map[string][]uint8, exists bool) {
	v := m.public_shares
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicShares returns the old "public_shares" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicShares(ctx context.Context) (v map[string][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicShares is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicShares requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicShares: %w", err)
	}
	return oldValue.PublicShares, nil
}

// ResetPublicShares resets all changes to the "public_shares" field.
func (m *SigningKeyshareMutation) ResetPublicShares() {
	m.public_shares = nil
}

// SetPublicKey sets the "public_key" field.
func (m *SigningKeyshareMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *SigningKeyshareMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *SigningKeyshareMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetMinSigners sets the "min_signers" field.
func (m *SigningKeyshareMutation) SetMinSigners(u uint32) {
	m.min_signers = &u
	m.addmin_signers = nil
}

// MinSigners returns the value of the "min_signers" field in the mutation.
func (m *SigningKeyshareMutation) MinSigners() (r uint32, exists bool) {
	v := m.min_signers
	if v == nil {
		return
	}
	return *v, true
}

// OldMinSigners returns the old "min_signers" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldMinSigners(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinSigners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinSigners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinSigners: %w", err)
	}
	return oldValue.MinSigners, nil
}

// AddMinSigners adds u to the "min_signers" field.
func (m *SigningKeyshareMutation) AddMinSigners(u int32) {
	if m.addmin_signers != nil {
		*m.addmin_signers += u
	} else {
		m.addmin_signers = &u
	}
}

// AddedMinSigners returns the value that was added to the "min_signers" field in this mutation.
func (m *SigningKeyshareMutation) AddedMinSigners() (r int32, exists bool) {
	v := m.addmin_signers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinSigners resets all changes to the "min_signers" field.
func (m *SigningKeyshareMutation) ResetMinSigners() {
	m.min_signers = nil
	m.addmin_signers = nil
}

// SetCoordinatorIndex sets the "coordinator_index" field.
func (m *SigningKeyshareMutation) SetCoordinatorIndex(u uint64) {
	m.coordinator_index = &u
	m.addcoordinator_index = nil
}

// CoordinatorIndex returns the value of the "coordinator_index" field in the mutation.
func (m *SigningKeyshareMutation) CoordinatorIndex() (r uint64, exists bool) {
	v := m.coordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinatorIndex returns the old "coordinator_index" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCoordinatorIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinatorIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinatorIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinatorIndex: %w", err)
	}
	return oldValue.CoordinatorIndex, nil
}

// AddCoordinatorIndex adds u to the "coordinator_index" field.
func (m *SigningKeyshareMutation) AddCoordinatorIndex(u int64) {
	if m.addcoordinator_index != nil {
		*m.addcoordinator_index += u
	} else {
		m.addcoordinator_index = &u
	}
}

// AddedCoordinatorIndex returns the value that was added to the "coordinator_index" field in this mutation.
func (m *SigningKeyshareMutation) AddedCoordinatorIndex() (r int64, exists bool) {
	v := m.addcoordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoordinatorIndex resets all changes to the "coordinator_index" field.
func (m *SigningKeyshareMutation) ResetCoordinatorIndex() {
	m.coordinator_index = nil
	m.addcoordinator_index = nil
}

// Where appends a list predicates to the SigningKeyshareMutation builder.
func (m *SigningKeyshareMutation) Where(ps ...predicate.SigningKeyshare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningKeyshareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningKeyshareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningKeyshare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningKeyshareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningKeyshareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningKeyshare).
func (m *SigningKeyshareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningKeyshareMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, signingkeyshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingkeyshare.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, signingkeyshare.FieldStatus)
	}
	if m.secret_share != nil {
		fields = append(fields, signingkeyshare.FieldSecretShare)
	}
	if m.public_shares != nil {
		fields = append(fields, signingkeyshare.FieldPublicShares)
	}
	if m.public_key != nil {
		fields = append(fields, signingkeyshare.FieldPublicKey)
	}
	if m.min_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.coordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningKeyshareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.CreateTime()
	case signingkeyshare.FieldUpdateTime:
		return m.UpdateTime()
	case signingkeyshare.FieldStatus:
		return m.Status()
	case signingkeyshare.FieldSecretShare:
		return m.SecretShare()
	case signingkeyshare.FieldPublicShares:
		return m.PublicShares()
	case signingkeyshare.FieldPublicKey:
		return m.PublicKey()
	case signingkeyshare.FieldMinSigners:
		return m.MinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.CoordinatorIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningKeyshareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingkeyshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingkeyshare.FieldStatus:
		return m.OldStatus(ctx)
	case signingkeyshare.FieldSecretShare:
		return m.OldSecretShare(ctx)
	case signingkeyshare.FieldPublicShares:
		return m.OldPublicShares(ctx)
	case signingkeyshare.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case signingkeyshare.FieldMinSigners:
		return m.OldMinSigners(ctx)
	case signingkeyshare.FieldCoordinatorIndex:
		return m.OldCoordinatorIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingkeyshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingkeyshare.FieldStatus:
		v, ok := value.(schema.SigningKeyshareStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signingkeyshare.FieldSecretShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretShare(v)
		return nil
	case signingkeyshare.FieldPublicShares:
		v, ok := value.(map[string][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicShares(v)
		return nil
	case signingkeyshare.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningKeyshareMutation) AddedFields() []string {
	var fields []string
	if m.addmin_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.addcoordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningKeyshareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldMinSigners:
		return m.AddedMinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.AddedCoordinatorIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningKeyshareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningKeyshareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningKeyshare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ResetField(name string) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingkeyshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingkeyshare.FieldStatus:
		m.ResetStatus()
		return nil
	case signingkeyshare.FieldSecretShare:
		m.ResetSecretShare()
		return nil
	case signingkeyshare.FieldPublicShares:
		m.ResetPublicShares()
		return nil
	case signingkeyshare.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case signingkeyshare.FieldMinSigners:
		m.ResetMinSigners()
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		m.ResetCoordinatorIndex()
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningKeyshareMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningKeyshareMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningKeyshareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningKeyshareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningKeyshareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningKeyshareMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningKeyshareMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningKeyshareMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare edge %s", name)
}

// SigningNonceMutation represents an operation that mutates the SigningNonce nodes in the graph.
type SigningNonceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	nonce            *[]byte
	nonce_commitment *[]byte
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*SigningNonce, error)
	predicates       []predicate.SigningNonce
}

var _ ent.Mutation = (*SigningNonceMutation)(nil)

// signingnonceOption allows management of the mutation configuration using functional options.
type signingnonceOption func(*SigningNonceMutation)

// newSigningNonceMutation creates new mutation for the SigningNonce entity.
func newSigningNonceMutation(c config, op Op, opts ...signingnonceOption) *SigningNonceMutation {
	m := &SigningNonceMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningNonce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningNonceID sets the ID field of the mutation.
func withSigningNonceID(id uuid.UUID) signingnonceOption {
	return func(m *SigningNonceMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningNonce
		)
		m.oldValue = func(ctx context.Context) (*SigningNonce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningNonce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningNonce sets the old SigningNonce of the mutation.
func withSigningNonce(node *SigningNonce) signingnonceOption {
	return func(m *SigningNonceMutation) {
		m.oldValue = func(context.Context) (*SigningNonce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningNonceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningNonceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningNonce entities.
func (m *SigningNonceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningNonceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningNonceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningNonce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningNonceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningNonceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningNonceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningNonceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningNonceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningNonceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNonce sets the "nonce" field.
func (m *SigningNonceMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *SigningNonceMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *SigningNonceMutation) ResetNonce() {
	m.nonce = nil
}

// SetNonceCommitment sets the "nonce_commitment" field.
func (m *SigningNonceMutation) SetNonceCommitment(b []byte) {
	m.nonce_commitment = &b
}

// NonceCommitment returns the value of the "nonce_commitment" field in the mutation.
func (m *SigningNonceMutation) NonceCommitment() (r []byte, exists bool) {
	v := m.nonce_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldNonceCommitment returns the old "nonce_commitment" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonceCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonceCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonceCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonceCommitment: %w", err)
	}
	return oldValue.NonceCommitment, nil
}

// ResetNonceCommitment resets all changes to the "nonce_commitment" field.
func (m *SigningNonceMutation) ResetNonceCommitment() {
	m.nonce_commitment = nil
}

// Where appends a list predicates to the SigningNonceMutation builder.
func (m *SigningNonceMutation) Where(ps ...predicate.SigningNonce) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningNonceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningNonceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningNonce, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningNonceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningNonceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningNonce).
func (m *SigningNonceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningNonceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, signingnonce.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingnonce.FieldUpdateTime)
	}
	if m.nonce != nil {
		fields = append(fields, signingnonce.FieldNonce)
	}
	if m.nonce_commitment != nil {
		fields = append(fields, signingnonce.FieldNonceCommitment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningNonceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.CreateTime()
	case signingnonce.FieldUpdateTime:
		return m.UpdateTime()
	case signingnonce.FieldNonce:
		return m.Nonce()
	case signingnonce.FieldNonceCommitment:
		return m.NonceCommitment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningNonceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingnonce.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingnonce.FieldNonce:
		return m.OldNonce(ctx)
	case signingnonce.FieldNonceCommitment:
		return m.OldNonceCommitment(ctx)
	}
	return nil, fmt.Errorf("unknown SigningNonce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingnonce.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingnonce.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingnonce.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case signingnonce.FieldNonceCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonceCommitment(v)
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningNonceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningNonceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SigningNonce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningNonceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningNonceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningNonceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningNonce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningNonceMutation) ResetField(name string) error {
	switch name {
	case signingnonce.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingnonce.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingnonce.FieldNonce:
		m.ResetNonce()
		return nil
	case signingnonce.FieldNonceCommitment:
		m.ResetNonceCommitment()
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningNonceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningNonceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningNonceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningNonceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningNonceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningNonceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningNonceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningNonceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	sender_identity_pubkey   *[]byte
	receiver_identity_pubkey *[]byte
	total_value              *uint64
	addtotal_value           *int64
	status                   *schema.TransferStatus
	_type                    *schema.TransferType
	expiry_time              *time.Time
	completion_time          *time.Time
	clearedFields            map[string]struct{}
	transfer_leaves          map[uuid.UUID]struct{}
	removedtransfer_leaves   map[uuid.UUID]struct{}
	clearedtransfer_leaves   bool
	done                     bool
	oldValue                 func(context.Context) (*Transfer, error)
	predicates               []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uuid.UUID) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSenderIdentityPubkey sets the "sender_identity_pubkey" field.
func (m *TransferMutation) SetSenderIdentityPubkey(b []byte) {
	m.sender_identity_pubkey = &b
}

// SenderIdentityPubkey returns the value of the "sender_identity_pubkey" field in the mutation.
func (m *TransferMutation) SenderIdentityPubkey() (r []byte, exists bool) {
	v := m.sender_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderIdentityPubkey returns the old "sender_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldSenderIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderIdentityPubkey: %w", err)
	}
	return oldValue.SenderIdentityPubkey, nil
}

// ResetSenderIdentityPubkey resets all changes to the "sender_identity_pubkey" field.
func (m *TransferMutation) ResetSenderIdentityPubkey() {
	m.sender_identity_pubkey = nil
}

// SetReceiverIdentityPubkey sets the "receiver_identity_pubkey" field.
func (m *TransferMutation) SetReceiverIdentityPubkey(b []byte) {
	m.receiver_identity_pubkey = &b
}

// ReceiverIdentityPubkey returns the value of the "receiver_identity_pubkey" field in the mutation.
func (m *TransferMutation) ReceiverIdentityPubkey() (r []byte, exists bool) {
	v := m.receiver_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverIdentityPubkey returns the old "receiver_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldReceiverIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverIdentityPubkey: %w", err)
	}
	return oldValue.ReceiverIdentityPubkey, nil
}

// ResetReceiverIdentityPubkey resets all changes to the "receiver_identity_pubkey" field.
func (m *TransferMutation) ResetReceiverIdentityPubkey() {
	m.receiver_identity_pubkey = nil
}

// SetTotalValue sets the "total_value" field.
func (m *TransferMutation) SetTotalValue(u uint64) {
	m.total_value = &u
	m.addtotal_value = nil
}

// TotalValue returns the value of the "total_value" field in the mutation.
func (m *TransferMutation) TotalValue() (r uint64, exists bool) {
	v := m.total_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalValue returns the old "total_value" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTotalValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalValue: %w", err)
	}
	return oldValue.TotalValue, nil
}

// AddTotalValue adds u to the "total_value" field.
func (m *TransferMutation) AddTotalValue(u int64) {
	if m.addtotal_value != nil {
		*m.addtotal_value += u
	} else {
		m.addtotal_value = &u
	}
}

// AddedTotalValue returns the value that was added to the "total_value" field in this mutation.
func (m *TransferMutation) AddedTotalValue() (r int64, exists bool) {
	v := m.addtotal_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalValue resets all changes to the "total_value" field.
func (m *TransferMutation) ResetTotalValue() {
	m.total_value = nil
	m.addtotal_value = nil
}

// SetStatus sets the "status" field.
func (m *TransferMutation) SetStatus(ss schema.TransferStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferMutation) Status() (r schema.TransferStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldStatus(ctx context.Context) (v schema.TransferStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *TransferMutation) SetType(st schema.TransferType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransferMutation) GetType() (r schema.TransferType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldType(ctx context.Context) (v schema.TransferType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransferMutation) ResetType() {
	m._type = nil
}

// SetExpiryTime sets the "expiry_time" field.
func (m *TransferMutation) SetExpiryTime(t time.Time) {
	m.expiry_time = &t
}

// ExpiryTime returns the value of the "expiry_time" field in the mutation.
func (m *TransferMutation) ExpiryTime() (r time.Time, exists bool) {
	v := m.expiry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryTime returns the old "expiry_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryTime: %w", err)
	}
	return oldValue.ExpiryTime, nil
}

// ResetExpiryTime resets all changes to the "expiry_time" field.
func (m *TransferMutation) ResetExpiryTime() {
	m.expiry_time = nil
}

// SetCompletionTime sets the "completion_time" field.
func (m *TransferMutation) SetCompletionTime(t time.Time) {
	m.completion_time = &t
}

// CompletionTime returns the value of the "completion_time" field in the mutation.
func (m *TransferMutation) CompletionTime() (r time.Time, exists bool) {
	v := m.completion_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTime returns the old "completion_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCompletionTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTime: %w", err)
	}
	return oldValue.CompletionTime, nil
}

// ClearCompletionTime clears the value of the "completion_time" field.
func (m *TransferMutation) ClearCompletionTime() {
	m.completion_time = nil
	m.clearedFields[transfer.FieldCompletionTime] = struct{}{}
}

// CompletionTimeCleared returns if the "completion_time" field was cleared in this mutation.
func (m *TransferMutation) CompletionTimeCleared() bool {
	_, ok := m.clearedFields[transfer.FieldCompletionTime]
	return ok
}

// ResetCompletionTime resets all changes to the "completion_time" field.
func (m *TransferMutation) ResetCompletionTime() {
	m.completion_time = nil
	delete(m.clearedFields, transfer.FieldCompletionTime)
}

// AddTransferLeafeIDs adds the "transfer_leaves" edge to the TransferLeaf entity by ids.
func (m *TransferMutation) AddTransferLeafeIDs(ids ...uuid.UUID) {
	if m.transfer_leaves == nil {
		m.transfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transfer_leaves[ids[i]] = struct{}{}
	}
}

// ClearTransferLeaves clears the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) ClearTransferLeaves() {
	m.clearedtransfer_leaves = true
}

// TransferLeavesCleared reports if the "transfer_leaves" edge to the TransferLeaf entity was cleared.
func (m *TransferMutation) TransferLeavesCleared() bool {
	return m.clearedtransfer_leaves
}

// RemoveTransferLeafeIDs removes the "transfer_leaves" edge to the TransferLeaf entity by IDs.
func (m *TransferMutation) RemoveTransferLeafeIDs(ids ...uuid.UUID) {
	if m.removedtransfer_leaves == nil {
		m.removedtransfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transfer_leaves, ids[i])
		m.removedtransfer_leaves[ids[i]] = struct{}{}
	}
}

// RemovedTransferLeaves returns the removed IDs of the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) RemovedTransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.removedtransfer_leaves {
		ids = append(ids, id)
	}
	return
}

// TransferLeavesIDs returns the "transfer_leaves" edge IDs in the mutation.
func (m *TransferMutation) TransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.transfer_leaves {
		ids = append(ids, id)
	}
	return
}

// ResetTransferLeaves resets all changes to the "transfer_leaves" edge.
func (m *TransferMutation) ResetTransferLeaves() {
	m.transfer_leaves = nil
	m.clearedtransfer_leaves = false
	m.removedtransfer_leaves = nil
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transfer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, transfer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transfer.FieldUpdateTime)
	}
	if m.sender_identity_pubkey != nil {
		fields = append(fields, transfer.FieldSenderIdentityPubkey)
	}
	if m.receiver_identity_pubkey != nil {
		fields = append(fields, transfer.FieldReceiverIdentityPubkey)
	}
	if m.total_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	if m.status != nil {
		fields = append(fields, transfer.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, transfer.FieldType)
	}
	if m.expiry_time != nil {
		fields = append(fields, transfer.FieldExpiryTime)
	}
	if m.completion_time != nil {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreateTime:
		return m.CreateTime()
	case transfer.FieldUpdateTime:
		return m.UpdateTime()
	case transfer.FieldSenderIdentityPubkey:
		return m.SenderIdentityPubkey()
	case transfer.FieldReceiverIdentityPubkey:
		return m.ReceiverIdentityPubkey()
	case transfer.FieldTotalValue:
		return m.TotalValue()
	case transfer.FieldStatus:
		return m.Status()
	case transfer.FieldType:
		return m.GetType()
	case transfer.FieldExpiryTime:
		return m.ExpiryTime()
	case transfer.FieldCompletionTime:
		return m.CompletionTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transfer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transfer.FieldSenderIdentityPubkey:
		return m.OldSenderIdentityPubkey(ctx)
	case transfer.FieldReceiverIdentityPubkey:
		return m.OldReceiverIdentityPubkey(ctx)
	case transfer.FieldTotalValue:
		return m.OldTotalValue(ctx)
	case transfer.FieldStatus:
		return m.OldStatus(ctx)
	case transfer.FieldType:
		return m.OldType(ctx)
	case transfer.FieldExpiryTime:
		return m.OldExpiryTime(ctx)
	case transfer.FieldCompletionTime:
		return m.OldCompletionTime(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transfer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transfer.FieldSenderIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderIdentityPubkey(v)
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverIdentityPubkey(v)
		return nil
	case transfer.FieldTotalValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalValue(v)
		return nil
	case transfer.FieldStatus:
		v, ok := value.(schema.TransferStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transfer.FieldType:
		v, ok := value.(schema.TransferType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transfer.FieldExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryTime(v)
		return nil
	case transfer.FieldCompletionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTime(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldTotalValue:
		return m.AddedTotalValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldTotalValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalValue(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfer.FieldCompletionTime) {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	switch name {
	case transfer.FieldCompletionTime:
		m.ClearCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transfer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transfer.FieldSenderIdentityPubkey:
		m.ResetSenderIdentityPubkey()
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		m.ResetReceiverIdentityPubkey()
		return nil
	case transfer.FieldTotalValue:
		m.ResetTotalValue()
		return nil
	case transfer.FieldStatus:
		m.ResetStatus()
		return nil
	case transfer.FieldType:
		m.ResetType()
		return nil
	case transfer.FieldExpiryTime:
		m.ResetExpiryTime()
		return nil
	case transfer.FieldCompletionTime:
		m.ResetCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.transfer_leaves))
		for id := range m.transfer_leaves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.removedtransfer_leaves))
		for id := range m.removedtransfer_leaves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransfer_leaves {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	switch name {
	case transfer.EdgeTransferLeaves:
		return m.clearedtransfer_leaves
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	switch name {
	case transfer.EdgeTransferLeaves:
		m.ResetTransferLeaves()
		return nil
	}
	return fmt.Errorf("unknown Transfer edge %s", name)
}

// TransferLeafMutation represents an operation that mutates the TransferLeaf nodes in the graph.
type TransferLeafMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	secret_cipher          *[]byte
	signature              *[]byte
	previous_refund_tx     *[]byte
	intermediate_refund_tx *[]byte
	key_tweak              *[]byte
	clearedFields          map[string]struct{}
	transfer               *uuid.UUID
	clearedtransfer        bool
	leaf                   *uuid.UUID
	clearedleaf            bool
	done                   bool
	oldValue               func(context.Context) (*TransferLeaf, error)
	predicates             []predicate.TransferLeaf
}

var _ ent.Mutation = (*TransferLeafMutation)(nil)

// transferleafOption allows management of the mutation configuration using functional options.
type transferleafOption func(*TransferLeafMutation)

// newTransferLeafMutation creates new mutation for the TransferLeaf entity.
func newTransferLeafMutation(c config, op Op, opts ...transferleafOption) *TransferLeafMutation {
	m := &TransferLeafMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferLeaf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferLeafID sets the ID field of the mutation.
func withTransferLeafID(id uuid.UUID) transferleafOption {
	return func(m *TransferLeafMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferLeaf
		)
		m.oldValue = func(ctx context.Context) (*TransferLeaf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferLeaf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferLeaf sets the old TransferLeaf of the mutation.
func withTransferLeaf(node *TransferLeaf) transferleafOption {
	return func(m *TransferLeafMutation) {
		m.oldValue = func(context.Context) (*TransferLeaf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferLeafMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferLeafMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransferLeaf entities.
func (m *TransferLeafMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferLeafMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferLeafMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransferLeaf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferLeafMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferLeafMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferLeafMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferLeafMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferLeafMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferLeafMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSecretCipher sets the "secret_cipher" field.
func (m *TransferLeafMutation) SetSecretCipher(b []byte) {
	m.secret_cipher = &b
}

// SecretCipher returns the value of the "secret_cipher" field in the mutation.
func (m *TransferLeafMutation) SecretCipher() (r []byte, exists bool) {
	v := m.secret_cipher
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretCipher returns the old "secret_cipher" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSecretCipher(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretCipher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretCipher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretCipher: %w", err)
	}
	return oldValue.SecretCipher, nil
}

// ClearSecretCipher clears the value of the "secret_cipher" field.
func (m *TransferLeafMutation) ClearSecretCipher() {
	m.secret_cipher = nil
	m.clearedFields[transferleaf.FieldSecretCipher] = struct{}{}
}

// SecretCipherCleared returns if the "secret_cipher" field was cleared in this mutation.
func (m *TransferLeafMutation) SecretCipherCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSecretCipher]
	return ok
}

// ResetSecretCipher resets all changes to the "secret_cipher" field.
func (m *TransferLeafMutation) ResetSecretCipher() {
	m.secret_cipher = nil
	delete(m.clearedFields, transferleaf.FieldSecretCipher)
}

// SetSignature sets the "signature" field.
func (m *TransferLeafMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *TransferLeafMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *TransferLeafMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[transferleaf.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *TransferLeafMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *TransferLeafMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, transferleaf.FieldSignature)
}

// SetPreviousRefundTx sets the "previous_refund_tx" field.
func (m *TransferLeafMutation) SetPreviousRefundTx(b []byte) {
	m.previous_refund_tx = &b
}

// PreviousRefundTx returns the value of the "previous_refund_tx" field in the mutation.
func (m *TransferLeafMutation) PreviousRefundTx() (r []byte, exists bool) {
	v := m.previous_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousRefundTx returns the old "previous_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldPreviousRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousRefundTx: %w", err)
	}
	return oldValue.PreviousRefundTx, nil
}

// ResetPreviousRefundTx resets all changes to the "previous_refund_tx" field.
func (m *TransferLeafMutation) ResetPreviousRefundTx() {
	m.previous_refund_tx = nil
}

// SetIntermediateRefundTx sets the "intermediate_refund_tx" field.
func (m *TransferLeafMutation) SetIntermediateRefundTx(b []byte) {
	m.intermediate_refund_tx = &b
}

// IntermediateRefundTx returns the value of the "intermediate_refund_tx" field in the mutation.
func (m *TransferLeafMutation) IntermediateRefundTx() (r []byte, exists bool) {
	v := m.intermediate_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldIntermediateRefundTx returns the old "intermediate_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldIntermediateRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntermediateRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntermediateRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntermediateRefundTx: %w", err)
	}
	return oldValue.IntermediateRefundTx, nil
}

// ResetIntermediateRefundTx resets all changes to the "intermediate_refund_tx" field.
func (m *TransferLeafMutation) ResetIntermediateRefundTx() {
	m.intermediate_refund_tx = nil
}

// SetKeyTweak sets the "key_tweak" field.
func (m *TransferLeafMutation) SetKeyTweak(b []byte) {
	m.key_tweak = &b
}

// KeyTweak returns the value of the "key_tweak" field in the mutation.
func (m *TransferLeafMutation) KeyTweak() (r []byte, exists bool) {
	v := m.key_tweak
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyTweak returns the old "key_tweak" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldKeyTweak(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyTweak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyTweak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyTweak: %w", err)
	}
	return oldValue.KeyTweak, nil
}

// ClearKeyTweak clears the value of the "key_tweak" field.
func (m *TransferLeafMutation) ClearKeyTweak() {
	m.key_tweak = nil
	m.clearedFields[transferleaf.FieldKeyTweak] = struct{}{}
}

// KeyTweakCleared returns if the "key_tweak" field was cleared in this mutation.
func (m *TransferLeafMutation) KeyTweakCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldKeyTweak]
	return ok
}

// ResetKeyTweak resets all changes to the "key_tweak" field.
func (m *TransferLeafMutation) ResetKeyTweak() {
	m.key_tweak = nil
	delete(m.clearedFields, transferleaf.FieldKeyTweak)
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *TransferLeafMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *TransferLeafMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *TransferLeafMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *TransferLeafMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *TransferLeafMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// SetLeafID sets the "leaf" edge to the TreeNode entity by id.
func (m *TransferLeafMutation) SetLeafID(id uuid.UUID) {
	m.leaf = &id
}

// ClearLeaf clears the "leaf" edge to the TreeNode entity.
func (m *TransferLeafMutation) ClearLeaf() {
	m.clearedleaf = true
}

// LeafCleared reports if the "leaf" edge to the TreeNode entity was cleared.
func (m *TransferLeafMutation) LeafCleared() bool {
	return m.clearedleaf
}

// LeafID returns the "leaf" edge ID in the mutation.
func (m *TransferLeafMutation) LeafID() (id uuid.UUID, exists bool) {
	if m.leaf != nil {
		return *m.leaf, true
	}
	return
}

// LeafIDs returns the "leaf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeafID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) LeafIDs() (ids []uuid.UUID) {
	if id := m.leaf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeaf resets all changes to the "leaf" edge.
func (m *TransferLeafMutation) ResetLeaf() {
	m.leaf = nil
	m.clearedleaf = false
}

// Where appends a list predicates to the TransferLeafMutation builder.
func (m *TransferLeafMutation) Where(ps ...predicate.TransferLeaf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferLeafMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferLeafMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransferLeaf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferLeafMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferLeafMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransferLeaf).
func (m *TransferLeafMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferLeafMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, transferleaf.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transferleaf.FieldUpdateTime)
	}
	if m.secret_cipher != nil {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.signature != nil {
		fields = append(fields, transferleaf.FieldSignature)
	}
	if m.previous_refund_tx != nil {
		fields = append(fields, transferleaf.FieldPreviousRefundTx)
	}
	if m.intermediate_refund_tx != nil {
		fields = append(fields, transferleaf.FieldIntermediateRefundTx)
	}
	if m.key_tweak != nil {
		fields = append(fields, transferleaf.FieldKeyTweak)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferLeafMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.CreateTime()
	case transferleaf.FieldUpdateTime:
		return m.UpdateTime()
	case transferleaf.FieldSecretCipher:
		return m.SecretCipher()
	case transferleaf.FieldSignature:
		return m.Signature()
	case transferleaf.FieldPreviousRefundTx:
		return m.PreviousRefundTx()
	case transferleaf.FieldIntermediateRefundTx:
		return m.IntermediateRefundTx()
	case transferleaf.FieldKeyTweak:
		return m.KeyTweak()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferLeafMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transferleaf.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transferleaf.FieldSecretCipher:
		return m.OldSecretCipher(ctx)
	case transferleaf.FieldSignature:
		return m.OldSignature(ctx)
	case transferleaf.FieldPreviousRefundTx:
		return m.OldPreviousRefundTx(ctx)
	case transferleaf.FieldIntermediateRefundTx:
		return m.OldIntermediateRefundTx(ctx)
	case transferleaf.FieldKeyTweak:
		return m.OldKeyTweak(ctx)
	}
	return nil, fmt.Errorf("unknown TransferLeaf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transferleaf.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transferleaf.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transferleaf.FieldSecretCipher:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretCipher(v)
		return nil
	case transferleaf.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case transferleaf.FieldPreviousRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousRefundTx(v)
		return nil
	case transferleaf.FieldIntermediateRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntermediateRefundTx(v)
		return nil
	case transferleaf.FieldKeyTweak:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyTweak(v)
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferLeafMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferLeafMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransferLeaf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferLeafMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transferleaf.FieldSecretCipher) {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.FieldCleared(transferleaf.FieldSignature) {
		fields = append(fields, transferleaf.FieldSignature)
	}
	if m.FieldCleared(transferleaf.FieldKeyTweak) {
		fields = append(fields, transferleaf.FieldKeyTweak)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferLeafMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferLeafMutation) ClearField(name string) error {
	switch name {
	case transferleaf.FieldSecretCipher:
		m.ClearSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ClearSignature()
		return nil
	case transferleaf.FieldKeyTweak:
		m.ClearKeyTweak()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferLeafMutation) ResetField(name string) error {
	switch name {
	case transferleaf.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transferleaf.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transferleaf.FieldSecretCipher:
		m.ResetSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ResetSignature()
		return nil
	case transferleaf.FieldPreviousRefundTx:
		m.ResetPreviousRefundTx()
		return nil
	case transferleaf.FieldIntermediateRefundTx:
		m.ResetIntermediateRefundTx()
		return nil
	case transferleaf.FieldKeyTweak:
		m.ResetKeyTweak()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferLeafMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transfer != nil {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.leaf != nil {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferLeafMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transferleaf.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	case transferleaf.EdgeLeaf:
		if id := m.leaf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferLeafMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferLeafMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferLeafMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransfer {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.clearedleaf {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferLeafMutation) EdgeCleared(name string) bool {
	switch name {
	case transferleaf.EdgeTransfer:
		return m.clearedtransfer
	case transferleaf.EdgeLeaf:
		return m.clearedleaf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferLeafMutation) ClearEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ClearTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ClearLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferLeafMutation) ResetEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ResetTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ResetLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf edge %s", name)
}

// TreeMutation represents an operation that mutates the Tree nodes in the graph.
type TreeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	owner_identity_pubkey *[]byte
	status                *schema.TreeStatus
	clearedFields         map[string]struct{}
	root                  *uuid.UUID
	clearedroot           bool
	nodes                 map[uuid.UUID]struct{}
	removednodes          map[uuid.UUID]struct{}
	clearednodes          bool
	done                  bool
	oldValue              func(context.Context) (*Tree, error)
	predicates            []predicate.Tree
}

var _ ent.Mutation = (*TreeMutation)(nil)

// treeOption allows management of the mutation configuration using functional options.
type treeOption func(*TreeMutation)

// newTreeMutation creates new mutation for the Tree entity.
func newTreeMutation(c config, op Op, opts ...treeOption) *TreeMutation {
	m := &TreeMutation{
		config:        c,
		op:            op,
		typ:           TypeTree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeID sets the ID field of the mutation.
func withTreeID(id uuid.UUID) treeOption {
	return func(m *TreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Tree
		)
		m.oldValue = func(ctx context.Context) (*Tree, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTree sets the old Tree of the mutation.
func withTree(node *Tree) treeOption {
	return func(m *TreeMutation) {
		m.oldValue = func(context.Context) (*Tree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tree entities.
func (m *TreeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tree.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetStatus sets the "status" field.
func (m *TreeMutation) SetStatus(ss schema.TreeStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeMutation) Status() (r schema.TreeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldStatus(ctx context.Context) (v schema.TreeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeMutation) ResetStatus() {
	m.status = nil
}

// SetRootID sets the "root" edge to the TreeNode entity by id.
func (m *TreeMutation) SetRootID(id uuid.UUID) {
	m.root = &id
}

// ClearRoot clears the "root" edge to the TreeNode entity.
func (m *TreeMutation) ClearRoot() {
	m.clearedroot = true
}

// RootCleared reports if the "root" edge to the TreeNode entity was cleared.
func (m *TreeMutation) RootCleared() bool {
	return m.clearedroot
}

// RootID returns the "root" edge ID in the mutation.
func (m *TreeMutation) RootID() (id uuid.UUID, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *TreeMutation) RootIDs() (ids []uuid.UUID) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *TreeMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddNodeIDs adds the "nodes" edge to the TreeNode entity by ids.
func (m *TreeMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the TreeNode entity was cleared.
func (m *TreeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the TreeNode entity by IDs.
func (m *TreeMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *TreeMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *TreeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the TreeMutation builder.
func (m *TreeMutation) Where(ps ...predicate.Tree) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tree, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tree).
func (m *TreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, tree.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tree.FieldUpdateTime)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, tree.FieldOwnerIdentityPubkey)
	}
	if m.status != nil {
		fields = append(fields, tree.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tree.FieldCreateTime:
		return m.CreateTime()
	case tree.FieldUpdateTime:
		return m.UpdateTime()
	case tree.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case tree.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tree.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tree.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tree.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case tree.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Tree field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tree.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tree.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tree.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case tree.FieldStatus:
		v, ok := value.(schema.TreeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tree nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeMutation) ResetField(name string) error {
	switch name {
	case tree.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tree.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tree.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case tree.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.root != nil {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.nodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroot {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.clearednodes {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeMutation) EdgeCleared(name string) bool {
	switch name {
	case tree.EdgeRoot:
		return m.clearedroot
	case tree.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeMutation) ClearEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ClearRoot()
		return nil
	}
	return fmt.Errorf("unknown Tree unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeMutation) ResetEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ResetRoot()
		return nil
	case tree.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Tree edge %s", name)
}

// TreeNodeMutation represents an operation that mutates the TreeNode nodes in the graph.
type TreeNodeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	create_time                      *time.Time
	update_time                      *time.Time
	value                            *uint64
	addvalue                         *int64
	status                           *schema.TreeNodeStatus
	verifying_pubkey                 *[]byte
	owner_identity_pubkey            *[]byte
	owner_signing_pubkey             *[]byte
	raw_tx                           *[]byte
	vout                             *uint16
	addvout                          *int16
	raw_refund_tx                    *[]byte
	destination_lock_identity_pubkey *[]byte
	clearedFields                    map[string]struct{}
	tree                             *uuid.UUID
	clearedtree                      bool
	parent                           *uuid.UUID
	clearedparent                    bool
	signing_keyshare                 *uuid.UUID
	clearedsigning_keyshare          bool
	children                         map[uuid.UUID]struct{}
	removedchildren                  map[uuid.UUID]struct{}
	clearedchildren                  bool
	done                             bool
	oldValue                         func(context.Context) (*TreeNode, error)
	predicates                       []predicate.TreeNode
}

var _ ent.Mutation = (*TreeNodeMutation)(nil)

// treenodeOption allows management of the mutation configuration using functional options.
type treenodeOption func(*TreeNodeMutation)

// newTreeNodeMutation creates new mutation for the TreeNode entity.
func newTreeNodeMutation(c config, op Op, opts ...treenodeOption) *TreeNodeMutation {
	m := &TreeNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTreeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeNodeID sets the ID field of the mutation.
func withTreeNodeID(id uuid.UUID) treenodeOption {
	return func(m *TreeNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TreeNode
		)
		m.oldValue = func(ctx context.Context) (*TreeNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreeNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreeNode sets the old TreeNode of the mutation.
func withTreeNode(node *TreeNode) treenodeOption {
	return func(m *TreeNodeMutation) {
		m.oldValue = func(context.Context) (*TreeNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreeNode entities.
func (m *TreeNodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeNodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeNodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreeNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeNodeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeNodeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeNodeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeNodeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeNodeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeNodeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetValue sets the "value" field.
func (m *TreeNodeMutation) SetValue(u uint64) {
	m.value = &u
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *TreeNodeMutation) Value() (r uint64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds u to the "value" field.
func (m *TreeNodeMutation) AddValue(u int64) {
	if m.addvalue != nil {
		*m.addvalue += u
	} else {
		m.addvalue = &u
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *TreeNodeMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *TreeNodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *TreeNodeMutation) SetStatus(sns schema.TreeNodeStatus) {
	m.status = &sns
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeNodeMutation) Status() (r schema.TreeNodeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldStatus(ctx context.Context) (v schema.TreeNodeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeNodeMutation) ResetStatus() {
	m.status = nil
}

// SetVerifyingPubkey sets the "verifying_pubkey" field.
func (m *TreeNodeMutation) SetVerifyingPubkey(b []byte) {
	m.verifying_pubkey = &b
}

// VerifyingPubkey returns the value of the "verifying_pubkey" field in the mutation.
func (m *TreeNodeMutation) VerifyingPubkey() (r []byte, exists bool) {
	v := m.verifying_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyingPubkey returns the old "verifying_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVerifyingPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyingPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyingPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyingPubkey: %w", err)
	}
	return oldValue.VerifyingPubkey, nil
}

// ResetVerifyingPubkey resets all changes to the "verifying_pubkey" field.
func (m *TreeNodeMutation) ResetVerifyingPubkey() {
	m.verifying_pubkey = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) SetOwnerSigningPubkey(b []byte) {
	m.owner_signing_pubkey = &b
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerSigningPubkey() (r []byte, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerSigningPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetRawTx sets the "raw_tx" field.
func (m *TreeNodeMutation) SetRawTx(b []byte) {
	m.raw_tx = &b
}

// RawTx returns the value of the "raw_tx" field in the mutation.
func (m *TreeNodeMutation) RawTx() (r []byte, exists bool) {
	v := m.raw_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawTx returns the old "raw_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawTx: %w", err)
	}
	return oldValue.RawTx, nil
}

// ResetRawTx resets all changes to the "raw_tx" field.
func (m *TreeNodeMutation) ResetRawTx() {
	m.raw_tx = nil
}

// SetVout sets the "vout" field.
func (m *TreeNodeMutation) SetVout(u uint16) {
	m.vout = &u
	m.addvout = nil
}

// Vout returns the value of the "vout" field in the mutation.
func (m *TreeNodeMutation) Vout() (r uint16, exists bool) {
	v := m.vout
	if v == nil {
		return
	}
	return *v, true
}

// OldVout returns the old "vout" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVout(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVout: %w", err)
	}
	return oldValue.Vout, nil
}

// AddVout adds u to the "vout" field.
func (m *TreeNodeMutation) AddVout(u int16) {
	if m.addvout != nil {
		*m.addvout += u
	} else {
		m.addvout = &u
	}
}

// AddedVout returns the value that was added to the "vout" field in this mutation.
func (m *TreeNodeMutation) AddedVout() (r int16, exists bool) {
	v := m.addvout
	if v == nil {
		return
	}
	return *v, true
}

// ResetVout resets all changes to the "vout" field.
func (m *TreeNodeMutation) ResetVout() {
	m.vout = nil
	m.addvout = nil
}

// SetRawRefundTx sets the "raw_refund_tx" field.
func (m *TreeNodeMutation) SetRawRefundTx(b []byte) {
	m.raw_refund_tx = &b
}

// RawRefundTx returns the value of the "raw_refund_tx" field in the mutation.
func (m *TreeNodeMutation) RawRefundTx() (r []byte, exists bool) {
	v := m.raw_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawRefundTx returns the old "raw_refund_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawRefundTx: %w", err)
	}
	return oldValue.RawRefundTx, nil
}

// ClearRawRefundTx clears the value of the "raw_refund_tx" field.
func (m *TreeNodeMutation) ClearRawRefundTx() {
	m.raw_refund_tx = nil
	m.clearedFields[treenode.FieldRawRefundTx] = struct{}{}
}

// RawRefundTxCleared returns if the "raw_refund_tx" field was cleared in this mutation.
func (m *TreeNodeMutation) RawRefundTxCleared() bool {
	_, ok := m.clearedFields[treenode.FieldRawRefundTx]
	return ok
}

// ResetRawRefundTx resets all changes to the "raw_refund_tx" field.
func (m *TreeNodeMutation) ResetRawRefundTx() {
	m.raw_refund_tx = nil
	delete(m.clearedFields, treenode.FieldRawRefundTx)
}

// SetDestinationLockIdentityPubkey sets the "destination_lock_identity_pubkey" field.
func (m *TreeNodeMutation) SetDestinationLockIdentityPubkey(b []byte) {
	m.destination_lock_identity_pubkey = &b
}

// DestinationLockIdentityPubkey returns the value of the "destination_lock_identity_pubkey" field in the mutation.
func (m *TreeNodeMutation) DestinationLockIdentityPubkey() (r []byte, exists bool) {
	v := m.destination_lock_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationLockIdentityPubkey returns the old "destination_lock_identity_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldDestinationLockIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationLockIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationLockIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationLockIdentityPubkey: %w", err)
	}
	return oldValue.DestinationLockIdentityPubkey, nil
}

// ClearDestinationLockIdentityPubkey clears the value of the "destination_lock_identity_pubkey" field.
func (m *TreeNodeMutation) ClearDestinationLockIdentityPubkey() {
	m.destination_lock_identity_pubkey = nil
	m.clearedFields[treenode.FieldDestinationLockIdentityPubkey] = struct{}{}
}

// DestinationLockIdentityPubkeyCleared returns if the "destination_lock_identity_pubkey" field was cleared in this mutation.
func (m *TreeNodeMutation) DestinationLockIdentityPubkeyCleared() bool {
	_, ok := m.clearedFields[treenode.FieldDestinationLockIdentityPubkey]
	return ok
}

// ResetDestinationLockIdentityPubkey resets all changes to the "destination_lock_identity_pubkey" field.
func (m *TreeNodeMutation) ResetDestinationLockIdentityPubkey() {
	m.destination_lock_identity_pubkey = nil
	delete(m.clearedFields, treenode.FieldDestinationLockIdentityPubkey)
}

// SetTreeID sets the "tree" edge to the Tree entity by id.
func (m *TreeNodeMutation) SetTreeID(id uuid.UUID) {
	m.tree = &id
}

// ClearTree clears the "tree" edge to the Tree entity.
func (m *TreeNodeMutation) ClearTree() {
	m.clearedtree = true
}

// TreeCleared reports if the "tree" edge to the Tree entity was cleared.
func (m *TreeNodeMutation) TreeCleared() bool {
	return m.clearedtree
}

// TreeID returns the "tree" edge ID in the mutation.
func (m *TreeNodeMutation) TreeID() (id uuid.UUID, exists bool) {
	if m.tree != nil {
		return *m.tree, true
	}
	return
}

// TreeIDs returns the "tree" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) TreeIDs() (ids []uuid.UUID) {
	if id := m.tree; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTree resets all changes to the "tree" edge.
func (m *TreeNodeMutation) ResetTree() {
	m.tree = nil
	m.clearedtree = false
}

// SetParentID sets the "parent" edge to the TreeNode entity by id.
func (m *TreeNodeMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TreeNodeMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TreeNodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *TreeNodeMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *TreeNodeMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *TreeNodeMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *TreeNodeMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *TreeNodeMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// AddChildIDs adds the "children" edge to the TreeNode entity by ids.
func (m *TreeNodeMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TreeNode entity by IDs.
func (m *TreeNodeMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TreeNodeMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TreeNodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the TreeNodeMutation builder.
func (m *TreeNodeMutation) Where(ps ...predicate.TreeNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreeNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreeNode).
func (m *TreeNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeNodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, treenode.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, treenode.FieldUpdateTime)
	}
	if m.value != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, treenode.FieldStatus)
	}
	if m.verifying_pubkey != nil {
		fields = append(fields, treenode.FieldVerifyingPubkey)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerSigningPubkey)
	}
	if m.raw_tx != nil {
		fields = append(fields, treenode.FieldRawTx)
	}
	if m.vout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	if m.raw_refund_tx != nil {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	if m.destination_lock_identity_pubkey != nil {
		fields = append(fields, treenode.FieldDestinationLockIdentityPubkey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldCreateTime:
		return m.CreateTime()
	case treenode.FieldUpdateTime:
		return m.UpdateTime()
	case treenode.FieldValue:
		return m.Value()
	case treenode.FieldStatus:
		return m.Status()
	case treenode.FieldVerifyingPubkey:
		return m.VerifyingPubkey()
	case treenode.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case treenode.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	case treenode.FieldRawTx:
		return m.RawTx()
	case treenode.FieldVout:
		return m.Vout()
	case treenode.FieldRawRefundTx:
		return m.RawRefundTx()
	case treenode.FieldDestinationLockIdentityPubkey:
		return m.DestinationLockIdentityPubkey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treenode.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case treenode.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case treenode.FieldValue:
		return m.OldValue(ctx)
	case treenode.FieldStatus:
		return m.OldStatus(ctx)
	case treenode.FieldVerifyingPubkey:
		return m.OldVerifyingPubkey(ctx)
	case treenode.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case treenode.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	case treenode.FieldRawTx:
		return m.OldRawTx(ctx)
	case treenode.FieldVout:
		return m.OldVout(ctx)
	case treenode.FieldRawRefundTx:
		return m.OldRawRefundTx(ctx)
	case treenode.FieldDestinationLockIdentityPubkey:
		return m.OldDestinationLockIdentityPubkey(ctx)
	}
	return nil, fmt.Errorf("unknown TreeNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case treenode.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case treenode.FieldValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case treenode.FieldStatus:
		v, ok := value.(schema.TreeNodeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case treenode.FieldVerifyingPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyingPubkey(v)
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case treenode.FieldOwnerSigningPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	case treenode.FieldRawTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawTx(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVout(v)
		return nil
	case treenode.FieldRawRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawRefundTx(v)
		return nil
	case treenode.FieldDestinationLockIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationLockIdentityPubkey(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeNodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.addvout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldValue:
		return m.AddedValue()
	case treenode.FieldVout:
		return m.AddedVout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVout(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeNodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treenode.FieldRawRefundTx) {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	if m.FieldCleared(treenode.FieldDestinationLockIdentityPubkey) {
		fields = append(fields, treenode.FieldDestinationLockIdentityPubkey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeNodeMutation) ClearField(name string) error {
	switch name {
	case treenode.FieldRawRefundTx:
		m.ClearRawRefundTx()
		return nil
	case treenode.FieldDestinationLockIdentityPubkey:
		m.ClearDestinationLockIdentityPubkey()
		return nil
	}
	return fmt.Errorf("unknown TreeNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeNodeMutation) ResetField(name string) error {
	switch name {
	case treenode.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case treenode.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case treenode.FieldValue:
		m.ResetValue()
		return nil
	case treenode.FieldStatus:
		m.ResetStatus()
		return nil
	case treenode.FieldVerifyingPubkey:
		m.ResetVerifyingPubkey()
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case treenode.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	case treenode.FieldRawTx:
		m.ResetRawTx()
		return nil
	case treenode.FieldVout:
		m.ResetVout()
		return nil
	case treenode.FieldRawRefundTx:
		m.ResetRawRefundTx()
		return nil
	case treenode.FieldDestinationLockIdentityPubkey:
		m.ResetDestinationLockIdentityPubkey()
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tree != nil {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.parent != nil {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.signing_keyshare != nil {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.children != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeTree:
		if id := m.tree; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtree {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.clearedparent {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.clearedsigning_keyshare {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.clearedchildren {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case treenode.EdgeTree:
		return m.clearedtree
	case treenode.EdgeParent:
		return m.clearedparent
	case treenode.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	case treenode.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeNodeMutation) ClearEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ClearTree()
		return nil
	case treenode.EdgeParent:
		m.ClearParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown TreeNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeNodeMutation) ResetEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ResetTree()
		return nil
	case treenode.EdgeParent:
		m.ResetParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	case treenode.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown TreeNode edge %s", name)
}

// UserSignedTransactionMutation represents an operation that mutates the UserSignedTransaction nodes in the graph.
type UserSignedTransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	transaction             *[]byte
	user_signature          *[]byte
	signing_commitments     *[]byte
	clearedFields           map[string]struct{}
	tree_node               *uuid.UUID
	clearedtree_node        bool
	preimage_request        *uuid.UUID
	clearedpreimage_request bool
	done                    bool
	oldValue                func(context.Context) (*UserSignedTransaction, error)
	predicates              []predicate.UserSignedTransaction
}

var _ ent.Mutation = (*UserSignedTransactionMutation)(nil)

// usersignedtransactionOption allows management of the mutation configuration using functional options.
type usersignedtransactionOption func(*UserSignedTransactionMutation)

// newUserSignedTransactionMutation creates new mutation for the UserSignedTransaction entity.
func newUserSignedTransactionMutation(c config, op Op, opts ...usersignedtransactionOption) *UserSignedTransactionMutation {
	m := &UserSignedTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSignedTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSignedTransactionID sets the ID field of the mutation.
func withUserSignedTransactionID(id uuid.UUID) usersignedtransactionOption {
	return func(m *UserSignedTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSignedTransaction
		)
		m.oldValue = func(ctx context.Context) (*UserSignedTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSignedTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSignedTransaction sets the old UserSignedTransaction of the mutation.
func withUserSignedTransaction(node *UserSignedTransaction) usersignedtransactionOption {
	return func(m *UserSignedTransactionMutation) {
		m.oldValue = func(context.Context) (*UserSignedTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSignedTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSignedTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSignedTransaction entities.
func (m *UserSignedTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSignedTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSignedTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSignedTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserSignedTransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserSignedTransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserSignedTransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserSignedTransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserSignedTransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserSignedTransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTransaction sets the "transaction" field.
func (m *UserSignedTransactionMutation) SetTransaction(b []byte) {
	m.transaction = &b
}

// Transaction returns the value of the "transaction" field in the mutation.
func (m *UserSignedTransactionMutation) Transaction() (r []byte, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransaction returns the old "transaction" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldTransaction(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransaction: %w", err)
	}
	return oldValue.Transaction, nil
}

// ResetTransaction resets all changes to the "transaction" field.
func (m *UserSignedTransactionMutation) ResetTransaction() {
	m.transaction = nil
}

// SetUserSignature sets the "user_signature" field.
func (m *UserSignedTransactionMutation) SetUserSignature(b []byte) {
	m.user_signature = &b
}

// UserSignature returns the value of the "user_signature" field in the mutation.
func (m *UserSignedTransactionMutation) UserSignature() (r []byte, exists bool) {
	v := m.user_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSignature returns the old "user_signature" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUserSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSignature: %w", err)
	}
	return oldValue.UserSignature, nil
}

// ResetUserSignature resets all changes to the "user_signature" field.
func (m *UserSignedTransactionMutation) ResetUserSignature() {
	m.user_signature = nil
}

// SetSigningCommitments sets the "signing_commitments" field.
func (m *UserSignedTransactionMutation) SetSigningCommitments(b []byte) {
	m.signing_commitments = &b
}

// SigningCommitments returns the value of the "signing_commitments" field in the mutation.
func (m *UserSignedTransactionMutation) SigningCommitments() (r []byte, exists bool) {
	v := m.signing_commitments
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningCommitments returns the old "signing_commitments" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldSigningCommitments(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningCommitments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningCommitments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningCommitments: %w", err)
	}
	return oldValue.SigningCommitments, nil
}

// ResetSigningCommitments resets all changes to the "signing_commitments" field.
func (m *UserSignedTransactionMutation) ResetSigningCommitments() {
	m.signing_commitments = nil
}

// SetTreeNodeID sets the "tree_node" edge to the TreeNode entity by id.
func (m *UserSignedTransactionMutation) SetTreeNodeID(id uuid.UUID) {
	m.tree_node = &id
}

// ClearTreeNode clears the "tree_node" edge to the TreeNode entity.
func (m *UserSignedTransactionMutation) ClearTreeNode() {
	m.clearedtree_node = true
}

// TreeNodeCleared reports if the "tree_node" edge to the TreeNode entity was cleared.
func (m *UserSignedTransactionMutation) TreeNodeCleared() bool {
	return m.clearedtree_node
}

// TreeNodeID returns the "tree_node" edge ID in the mutation.
func (m *UserSignedTransactionMutation) TreeNodeID() (id uuid.UUID, exists bool) {
	if m.tree_node != nil {
		return *m.tree_node, true
	}
	return
}

// TreeNodeIDs returns the "tree_node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeNodeID instead. It exists only for internal usage by the builders.
func (m *UserSignedTransactionMutation) TreeNodeIDs() (ids []uuid.UUID) {
	if id := m.tree_node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreeNode resets all changes to the "tree_node" edge.
func (m *UserSignedTransactionMutation) ResetTreeNode() {
	m.tree_node = nil
	m.clearedtree_node = false
}

// SetPreimageRequestID sets the "preimage_request" edge to the PreimageRequest entity by id.
func (m *UserSignedTransactionMutation) SetPreimageRequestID(id uuid.UUID) {
	m.preimage_request = &id
}

// ClearPreimageRequest clears the "preimage_request" edge to the PreimageRequest entity.
func (m *UserSignedTransactionMutation) ClearPreimageRequest() {
	m.clearedpreimage_request = true
}

// PreimageRequestCleared reports if the "preimage_request" edge to the PreimageRequest entity was cleared.
func (m *UserSignedTransactionMutation) PreimageRequestCleared() bool {
	return m.clearedpreimage_request
}

// PreimageRequestID returns the "preimage_request" edge ID in the mutation.
func (m *UserSignedTransactionMutation) PreimageRequestID() (id uuid.UUID, exists bool) {
	if m.preimage_request != nil {
		return *m.preimage_request, true
	}
	return
}

// PreimageRequestIDs returns the "preimage_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageRequestID instead. It exists only for internal usage by the builders.
func (m *UserSignedTransactionMutation) PreimageRequestIDs() (ids []uuid.UUID) {
	if id := m.preimage_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageRequest resets all changes to the "preimage_request" edge.
func (m *UserSignedTransactionMutation) ResetPreimageRequest() {
	m.preimage_request = nil
	m.clearedpreimage_request = false
}

// Where appends a list predicates to the UserSignedTransactionMutation builder.
func (m *UserSignedTransactionMutation) Where(ps ...predicate.UserSignedTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSignedTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSignedTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSignedTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSignedTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSignedTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSignedTransaction).
func (m *UserSignedTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSignedTransactionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, usersignedtransaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usersignedtransaction.FieldUpdateTime)
	}
	if m.transaction != nil {
		fields = append(fields, usersignedtransaction.FieldTransaction)
	}
	if m.user_signature != nil {
		fields = append(fields, usersignedtransaction.FieldUserSignature)
	}
	if m.signing_commitments != nil {
		fields = append(fields, usersignedtransaction.FieldSigningCommitments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSignedTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		return m.CreateTime()
	case usersignedtransaction.FieldUpdateTime:
		return m.UpdateTime()
	case usersignedtransaction.FieldTransaction:
		return m.Transaction()
	case usersignedtransaction.FieldUserSignature:
		return m.UserSignature()
	case usersignedtransaction.FieldSigningCommitments:
		return m.SigningCommitments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSignedTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usersignedtransaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usersignedtransaction.FieldTransaction:
		return m.OldTransaction(ctx)
	case usersignedtransaction.FieldUserSignature:
		return m.OldUserSignature(ctx)
	case usersignedtransaction.FieldSigningCommitments:
		return m.OldSigningCommitments(ctx)
	}
	return nil, fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSignedTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usersignedtransaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usersignedtransaction.FieldTransaction:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransaction(v)
		return nil
	case usersignedtransaction.FieldUserSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSignature(v)
		return nil
	case usersignedtransaction.FieldSigningCommitments:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningCommitments(v)
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSignedTransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSignedTransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSignedTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSignedTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSignedTransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSignedTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSignedTransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSignedTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSignedTransactionMutation) ResetField(name string) error {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usersignedtransaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usersignedtransaction.FieldTransaction:
		m.ResetTransaction()
		return nil
	case usersignedtransaction.FieldUserSignature:
		m.ResetUserSignature()
		return nil
	case usersignedtransaction.FieldSigningCommitments:
		m.ResetSigningCommitments()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSignedTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tree_node != nil {
		edges = append(edges, usersignedtransaction.EdgeTreeNode)
	}
	if m.preimage_request != nil {
		edges = append(edges, usersignedtransaction.EdgePreimageRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSignedTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		if id := m.tree_node; id != nil {
			return []ent.Value{*id}
		}
	case usersignedtransaction.EdgePreimageRequest:
		if id := m.preimage_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSignedTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSignedTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSignedTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtree_node {
		edges = append(edges, usersignedtransaction.EdgeTreeNode)
	}
	if m.clearedpreimage_request {
		edges = append(edges, usersignedtransaction.EdgePreimageRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSignedTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		return m.clearedtree_node
	case usersignedtransaction.EdgePreimageRequest:
		return m.clearedpreimage_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSignedTransactionMutation) ClearEdge(name string) error {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		m.ClearTreeNode()
		return nil
	case usersignedtransaction.EdgePreimageRequest:
		m.ClearPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSignedTransactionMutation) ResetEdge(name string) error {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		m.ResetTreeNode()
		return nil
	case usersignedtransaction.EdgePreimageRequest:
		m.ResetPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction edge %s", name)
}
